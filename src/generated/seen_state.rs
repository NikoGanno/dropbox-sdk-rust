// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

/// Possible platforms on which a user may view content.
#[derive(Debug)]
pub enum PlatformType {
    /// The content was viewed on the web.
    Web,
    /// The content was viewed on a mobile client.
    Mobile,
    /// The content was viewed on a desktop client.
    Desktop,
    /// The content was viewed on an unknown platform.
    Unknown,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PlatformType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PlatformType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PlatformType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "web" => Ok(PlatformType::Web),
                    "mobile" => Ok(PlatformType::Mobile),
                    "desktop" => Ok(PlatformType::Desktop),
                    "unknown" => Ok(PlatformType::Unknown),
                    _ => Ok(PlatformType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["web",
                                    "mobile",
                                    "desktop",
                                    "unknown",
                                    "other"];
        deserializer.deserialize_struct("PlatformType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PlatformType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PlatformType::Web => {
                // unit
                let mut s = serializer.serialize_struct("PlatformType", 1)?;
                s.serialize_field(".tag", "web")?;
                s.end()
            }
            PlatformType::Mobile => {
                // unit
                let mut s = serializer.serialize_struct("PlatformType", 1)?;
                s.serialize_field(".tag", "mobile")?;
                s.end()
            }
            PlatformType::Desktop => {
                // unit
                let mut s = serializer.serialize_struct("PlatformType", 1)?;
                s.serialize_field(".tag", "desktop")?;
                s.end()
            }
            PlatformType::Unknown => {
                // unit
                let mut s = serializer.serialize_struct("PlatformType", 1)?;
                s.serialize_field(".tag", "unknown")?;
                s.end()
            }
            PlatformType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

