// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

//! This namespace contains endpoints and data types for user management.

pub type GetAccountBatchResult = Vec<BasicAccount>;

/// Get information about a user's account.
pub fn get_account(
    client: &::client_trait::HttpClient,
    arg: &GetAccountArg,
) -> ::Result<Result<BasicAccount, GetAccountError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "users/get_account",
        arg,
        None)
}

/// Get information about multiple user accounts.  At most 300 accounts may be queried per request.
pub fn get_account_batch(
    client: &::client_trait::HttpClient,
    arg: &GetAccountBatchArg,
) -> ::Result<Result<GetAccountBatchResult, GetAccountBatchError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "users/get_account_batch",
        arg,
        None)
}

/// Get information about the current user's account.
pub fn get_current_account(
    client: &::client_trait::HttpClient,
    arg: &(),
) -> ::Result<Result<FullAccount, ()>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "users/get_current_account",
        arg,
        None)
}

/// Get the space usage information for the current user's account.
pub fn get_space_usage(
    client: &::client_trait::HttpClient,
    arg: &(),
) -> ::Result<Result<SpaceUsage, ()>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "users/get_space_usage",
        arg,
        None)
}

/// The amount of detail revealed about an account depends on the user being queried and the user
/// making the query.
#[derive(Debug)]
pub struct Account {
    /// The user's unique Dropbox ID.
    pub account_id: super::users_common::AccountId,
    /// Details of a user's name.
    pub name: Name,
    /// The user's e-mail address. Do not rely on this without checking the :field:`email_verified`
    /// field. Even then, it's possible that the user has since lost access to their e-mail.
    pub email: String,
    /// Whether the user has verified their e-mail address.
    pub email_verified: bool,
    /// Whether the user has been disabled.
    pub disabled: bool,
    /// URL for the photo representing the user, if one is set.
    pub profile_photo_url: Option<String>,
}

impl Account {
    pub fn new(
        account_id: super::users_common::AccountId,
        name: Name,
        email: String,
        email_verified: bool,
        disabled: bool,
    ) -> Self {
        Account {
            account_id,
            name,
            email,
            email_verified,
            disabled,
            profile_photo_url: None,
        }
    }

    pub fn with_profile_photo_url(mut self, value: Option<String>) -> Self {
        self.profile_photo_url = value;
        self
    }

}

const ACCOUNT_FIELDS: &'static [&'static str] = &["account_id",
                                                  "name",
                                                  "email",
                                                  "email_verified",
                                                  "disabled",
                                                  "profile_photo_url"];
impl Account {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<Account, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_name = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_disabled = None;
        let mut field_profile_photo_url = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "disabled" => {
                    if field_disabled.is_some() {
                        return Err(de::Error::duplicate_field("disabled"));
                    }
                    field_disabled = Some(map.next_value()?);
                }
                "profile_photo_url" => {
                    if field_profile_photo_url.is_some() {
                        return Err(de::Error::duplicate_field("profile_photo_url"));
                    }
                    field_profile_photo_url = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_FIELDS))
            }
        }
        Ok(Account {
            account_id: field_account_id.ok_or_else(|| de::Error::missing_field("account_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            email: field_email.ok_or_else(|| de::Error::missing_field("email"))?,
            email_verified: field_email_verified.ok_or_else(|| de::Error::missing_field("email_verified"))?,
            disabled: field_disabled.ok_or_else(|| de::Error::missing_field("disabled"))?,
            profile_photo_url: field_profile_photo_url,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("email_verified", &self.email_verified)?;
        s.serialize_field("disabled", &self.disabled)?;
        s.serialize_field("profile_photo_url", &self.profile_photo_url)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Account {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Account;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Account struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Account::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Account", ACCOUNT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Account {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Account", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Basic information about any account.
#[derive(Debug)]
pub struct BasicAccount {
    /// The user's unique Dropbox ID.
    pub account_id: super::users_common::AccountId,
    /// Details of a user's name.
    pub name: Name,
    /// The user's e-mail address. Do not rely on this without checking the :field:`email_verified`
    /// field. Even then, it's possible that the user has since lost access to their e-mail.
    pub email: String,
    /// Whether the user has verified their e-mail address.
    pub email_verified: bool,
    /// Whether the user has been disabled.
    pub disabled: bool,
    /// Whether this user is a teammate of the current user. If this account is the current user's
    /// account, then this will be :val:`true`.
    pub is_teammate: bool,
    /// URL for the photo representing the user, if one is set.
    pub profile_photo_url: Option<String>,
    /// The user's unique team member id. This field will only be present if the user is part of a
    /// team and :field:`is_teammate` is :val:`true`.
    pub team_member_id: Option<String>,
}

impl BasicAccount {
    pub fn new(
        account_id: super::users_common::AccountId,
        name: Name,
        email: String,
        email_verified: bool,
        disabled: bool,
        is_teammate: bool,
    ) -> Self {
        BasicAccount {
            account_id,
            name,
            email,
            email_verified,
            disabled,
            is_teammate,
            profile_photo_url: None,
            team_member_id: None,
        }
    }

    pub fn with_profile_photo_url(mut self, value: Option<String>) -> Self {
        self.profile_photo_url = value;
        self
    }

    pub fn with_team_member_id(mut self, value: Option<String>) -> Self {
        self.team_member_id = value;
        self
    }

}

const BASIC_ACCOUNT_FIELDS: &'static [&'static str] = &["account_id",
                                                        "name",
                                                        "email",
                                                        "email_verified",
                                                        "disabled",
                                                        "is_teammate",
                                                        "profile_photo_url",
                                                        "team_member_id"];
impl BasicAccount {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<BasicAccount, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_name = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_disabled = None;
        let mut field_is_teammate = None;
        let mut field_profile_photo_url = None;
        let mut field_team_member_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "disabled" => {
                    if field_disabled.is_some() {
                        return Err(de::Error::duplicate_field("disabled"));
                    }
                    field_disabled = Some(map.next_value()?);
                }
                "is_teammate" => {
                    if field_is_teammate.is_some() {
                        return Err(de::Error::duplicate_field("is_teammate"));
                    }
                    field_is_teammate = Some(map.next_value()?);
                }
                "profile_photo_url" => {
                    if field_profile_photo_url.is_some() {
                        return Err(de::Error::duplicate_field("profile_photo_url"));
                    }
                    field_profile_photo_url = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, BASIC_ACCOUNT_FIELDS))
            }
        }
        Ok(BasicAccount {
            account_id: field_account_id.ok_or_else(|| de::Error::missing_field("account_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            email: field_email.ok_or_else(|| de::Error::missing_field("email"))?,
            email_verified: field_email_verified.ok_or_else(|| de::Error::missing_field("email_verified"))?,
            disabled: field_disabled.ok_or_else(|| de::Error::missing_field("disabled"))?,
            is_teammate: field_is_teammate.ok_or_else(|| de::Error::missing_field("is_teammate"))?,
            profile_photo_url: field_profile_photo_url,
            team_member_id: field_team_member_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("email_verified", &self.email_verified)?;
        s.serialize_field("disabled", &self.disabled)?;
        s.serialize_field("is_teammate", &self.is_teammate)?;
        s.serialize_field("profile_photo_url", &self.profile_photo_url)?;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BasicAccount {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BasicAccount;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a BasicAccount struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BasicAccount::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BasicAccount", BASIC_ACCOUNT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BasicAccount {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BasicAccount", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Detailed information about the current user's account.
#[derive(Debug)]
pub struct FullAccount {
    /// The user's unique Dropbox ID.
    pub account_id: super::users_common::AccountId,
    /// Details of a user's name.
    pub name: Name,
    /// The user's e-mail address. Do not rely on this without checking the :field:`email_verified`
    /// field. Even then, it's possible that the user has since lost access to their e-mail.
    pub email: String,
    /// Whether the user has verified their e-mail address.
    pub email_verified: bool,
    /// Whether the user has been disabled.
    pub disabled: bool,
    /// The language that the user specified. Locale tags will be :link:`IETF language tags
    /// http://en.wikipedia.org/wiki/IETF_language_tag`.
    pub locale: String,
    /// The user's :link:`referral link https://www.dropbox.com/referrals`.
    pub referral_link: String,
    /// Whether the user has a personal and work account. If the current account is personal, then
    /// :field:`team` will always be :val:`null`, but :field:`is_paired` will indicate if a work
    /// account is linked.
    pub is_paired: bool,
    /// What type of account this user has.
    pub account_type: super::users_common::AccountType,
    /// The root info for this account.
    pub root_info: super::common::RootInfo,
    /// URL for the photo representing the user, if one is set.
    pub profile_photo_url: Option<String>,
    /// The user's two-letter country code, if available. Country codes are based on :link:`ISO
    /// 3166-1 http://en.wikipedia.org/wiki/ISO_3166-1`.
    pub country: Option<String>,
    /// If this account is a member of a team, information about that team.
    pub team: Option<FullTeam>,
    /// This account's unique team member id. This field will only be present if :field:`team` is
    /// present.
    pub team_member_id: Option<String>,
}

impl FullAccount {
    pub fn new(
        account_id: super::users_common::AccountId,
        name: Name,
        email: String,
        email_verified: bool,
        disabled: bool,
        locale: String,
        referral_link: String,
        is_paired: bool,
        account_type: super::users_common::AccountType,
        root_info: super::common::RootInfo,
    ) -> Self {
        FullAccount {
            account_id,
            name,
            email,
            email_verified,
            disabled,
            locale,
            referral_link,
            is_paired,
            account_type,
            root_info,
            profile_photo_url: None,
            country: None,
            team: None,
            team_member_id: None,
        }
    }

    pub fn with_profile_photo_url(mut self, value: Option<String>) -> Self {
        self.profile_photo_url = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

    pub fn with_team(mut self, value: Option<FullTeam>) -> Self {
        self.team = value;
        self
    }

    pub fn with_team_member_id(mut self, value: Option<String>) -> Self {
        self.team_member_id = value;
        self
    }

}

const FULL_ACCOUNT_FIELDS: &'static [&'static str] = &["account_id",
                                                       "name",
                                                       "email",
                                                       "email_verified",
                                                       "disabled",
                                                       "locale",
                                                       "referral_link",
                                                       "is_paired",
                                                       "account_type",
                                                       "root_info",
                                                       "profile_photo_url",
                                                       "country",
                                                       "team",
                                                       "team_member_id"];
impl FullAccount {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FullAccount, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_name = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_disabled = None;
        let mut field_locale = None;
        let mut field_referral_link = None;
        let mut field_is_paired = None;
        let mut field_account_type = None;
        let mut field_root_info = None;
        let mut field_profile_photo_url = None;
        let mut field_country = None;
        let mut field_team = None;
        let mut field_team_member_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "disabled" => {
                    if field_disabled.is_some() {
                        return Err(de::Error::duplicate_field("disabled"));
                    }
                    field_disabled = Some(map.next_value()?);
                }
                "locale" => {
                    if field_locale.is_some() {
                        return Err(de::Error::duplicate_field("locale"));
                    }
                    field_locale = Some(map.next_value()?);
                }
                "referral_link" => {
                    if field_referral_link.is_some() {
                        return Err(de::Error::duplicate_field("referral_link"));
                    }
                    field_referral_link = Some(map.next_value()?);
                }
                "is_paired" => {
                    if field_is_paired.is_some() {
                        return Err(de::Error::duplicate_field("is_paired"));
                    }
                    field_is_paired = Some(map.next_value()?);
                }
                "account_type" => {
                    if field_account_type.is_some() {
                        return Err(de::Error::duplicate_field("account_type"));
                    }
                    field_account_type = Some(map.next_value()?);
                }
                "root_info" => {
                    if field_root_info.is_some() {
                        return Err(de::Error::duplicate_field("root_info"));
                    }
                    field_root_info = Some(map.next_value()?);
                }
                "profile_photo_url" => {
                    if field_profile_photo_url.is_some() {
                        return Err(de::Error::duplicate_field("profile_photo_url"));
                    }
                    field_profile_photo_url = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                "team" => {
                    if field_team.is_some() {
                        return Err(de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FULL_ACCOUNT_FIELDS))
            }
        }
        Ok(FullAccount {
            account_id: field_account_id.ok_or_else(|| de::Error::missing_field("account_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            email: field_email.ok_or_else(|| de::Error::missing_field("email"))?,
            email_verified: field_email_verified.ok_or_else(|| de::Error::missing_field("email_verified"))?,
            disabled: field_disabled.ok_or_else(|| de::Error::missing_field("disabled"))?,
            locale: field_locale.ok_or_else(|| de::Error::missing_field("locale"))?,
            referral_link: field_referral_link.ok_or_else(|| de::Error::missing_field("referral_link"))?,
            is_paired: field_is_paired.ok_or_else(|| de::Error::missing_field("is_paired"))?,
            account_type: field_account_type.ok_or_else(|| de::Error::missing_field("account_type"))?,
            root_info: field_root_info.ok_or_else(|| de::Error::missing_field("root_info"))?,
            profile_photo_url: field_profile_photo_url,
            country: field_country,
            team: field_team,
            team_member_id: field_team_member_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("email_verified", &self.email_verified)?;
        s.serialize_field("disabled", &self.disabled)?;
        s.serialize_field("locale", &self.locale)?;
        s.serialize_field("referral_link", &self.referral_link)?;
        s.serialize_field("is_paired", &self.is_paired)?;
        s.serialize_field("account_type", &self.account_type)?;
        s.serialize_field("root_info", &self.root_info)?;
        s.serialize_field("profile_photo_url", &self.profile_photo_url)?;
        s.serialize_field("country", &self.country)?;
        s.serialize_field("team", &self.team)?;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FullAccount {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FullAccount;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FullAccount struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FullAccount::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FullAccount", FULL_ACCOUNT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FullAccount {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FullAccount", 14)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Detailed information about a team.
#[derive(Debug)]
pub struct FullTeam {
    /// The team's unique ID.
    pub id: String,
    /// The name of the team.
    pub name: String,
    /// Team policies governing sharing.
    pub sharing_policies: super::team_policies::TeamSharingPolicies,
    /// Team policy governing the use of the Office Add-In.
    pub office_addin_policy: super::team_policies::OfficeAddInPolicy,
}

impl FullTeam {
    pub fn new(
        id: String,
        name: String,
        sharing_policies: super::team_policies::TeamSharingPolicies,
        office_addin_policy: super::team_policies::OfficeAddInPolicy,
    ) -> Self {
        FullTeam {
            id,
            name,
            sharing_policies,
            office_addin_policy,
        }
    }

}

const FULL_TEAM_FIELDS: &'static [&'static str] = &["id",
                                                    "name",
                                                    "sharing_policies",
                                                    "office_addin_policy"];
impl FullTeam {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FullTeam, V::Error> {
        use serde::de;
        let mut field_id = None;
        let mut field_name = None;
        let mut field_sharing_policies = None;
        let mut field_office_addin_policy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "sharing_policies" => {
                    if field_sharing_policies.is_some() {
                        return Err(de::Error::duplicate_field("sharing_policies"));
                    }
                    field_sharing_policies = Some(map.next_value()?);
                }
                "office_addin_policy" => {
                    if field_office_addin_policy.is_some() {
                        return Err(de::Error::duplicate_field("office_addin_policy"));
                    }
                    field_office_addin_policy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FULL_TEAM_FIELDS))
            }
        }
        Ok(FullTeam {
            id: field_id.ok_or_else(|| de::Error::missing_field("id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            sharing_policies: field_sharing_policies.ok_or_else(|| de::Error::missing_field("sharing_policies"))?,
            office_addin_policy: field_office_addin_policy.ok_or_else(|| de::Error::missing_field("office_addin_policy"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("sharing_policies", &self.sharing_policies)?;
        s.serialize_field("office_addin_policy", &self.office_addin_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FullTeam {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FullTeam;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FullTeam struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FullTeam::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FullTeam", FULL_TEAM_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FullTeam {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FullTeam", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetAccountArg {
    /// A user's account identifier.
    pub account_id: super::users_common::AccountId,
}

impl GetAccountArg {
    pub fn new(account_id: super::users_common::AccountId) -> Self {
        GetAccountArg {
            account_id,
        }
    }

}

const GET_ACCOUNT_ARG_FIELDS: &'static [&'static str] = &["account_id"];
impl GetAccountArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetAccountArg, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_ACCOUNT_ARG_FIELDS))
            }
        }
        Ok(GetAccountArg {
            account_id: field_account_id.ok_or_else(|| de::Error::missing_field("account_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetAccountArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetAccountArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetAccountArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetAccountArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetAccountArg", GET_ACCOUNT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetAccountArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetAccountArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetAccountBatchArg {
    /// List of user account identifiers.  Should not contain any duplicate account IDs.
    pub account_ids: Vec<super::users_common::AccountId>,
}

impl GetAccountBatchArg {
    pub fn new(account_ids: Vec<super::users_common::AccountId>) -> Self {
        GetAccountBatchArg {
            account_ids,
        }
    }

}

const GET_ACCOUNT_BATCH_ARG_FIELDS: &'static [&'static str] = &["account_ids"];
impl GetAccountBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetAccountBatchArg, V::Error> {
        use serde::de;
        let mut field_account_ids = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_ids" => {
                    if field_account_ids.is_some() {
                        return Err(de::Error::duplicate_field("account_ids"));
                    }
                    field_account_ids = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_ACCOUNT_BATCH_ARG_FIELDS))
            }
        }
        Ok(GetAccountBatchArg {
            account_ids: field_account_ids.ok_or_else(|| de::Error::missing_field("account_ids"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_ids", &self.account_ids)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetAccountBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetAccountBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetAccountBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetAccountBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetAccountBatchArg", GET_ACCOUNT_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetAccountBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetAccountBatchArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GetAccountBatchError {
    /// The value is an account ID specified in :field:`GetAccountBatchArg.account_ids` that does
    /// not exist.
    NoAccount(super::users_common::AccountId),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetAccountBatchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetAccountBatchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetAccountBatchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "no_account" => {
                        match map.next_key()? {
                            Some("no_account") => Ok(GetAccountBatchError::NoAccount(map.next_value()?)),
                            None => Err(de::Error::missing_field("no_account")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(GetAccountBatchError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["no_account",
                                                    "other"];
        deserializer.deserialize_struct("GetAccountBatchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetAccountBatchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetAccountBatchError::NoAccount(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "no_account")?;
                s.serialize_field("no_account", x)?;
                s.end()
            }
            GetAccountBatchError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetAccountBatchError {
    fn description(&self) -> &str {
        "GetAccountBatchError"
    }
}

impl ::std::fmt::Display for GetAccountBatchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GetAccountError {
    /// The specified :field:`GetAccountArg.account_id` does not exist.
    NoAccount,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetAccountError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetAccountError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetAccountError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "no_account" => Ok(GetAccountError::NoAccount),
                    _ => Ok(GetAccountError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["no_account",
                                                    "other"];
        deserializer.deserialize_struct("GetAccountError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetAccountError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetAccountError::NoAccount => {
                // unit
                let mut s = serializer.serialize_struct("GetAccountError", 1)?;
                s.serialize_field(".tag", "no_account")?;
                s.end()
            }
            GetAccountError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetAccountError {
    fn description(&self) -> &str {
        "GetAccountError"
    }
}

impl ::std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct IndividualSpaceAllocation {
    /// The total space allocated to the user's account (bytes).
    pub allocated: u64,
}

impl IndividualSpaceAllocation {
    pub fn new(allocated: u64) -> Self {
        IndividualSpaceAllocation {
            allocated,
        }
    }

}

const INDIVIDUAL_SPACE_ALLOCATION_FIELDS: &'static [&'static str] = &["allocated"];
impl IndividualSpaceAllocation {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<IndividualSpaceAllocation, V::Error> {
        use serde::de;
        let mut field_allocated = None;
        while let Some(key) = map.next_key()? {
            match key {
                "allocated" => {
                    if field_allocated.is_some() {
                        return Err(de::Error::duplicate_field("allocated"));
                    }
                    field_allocated = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, INDIVIDUAL_SPACE_ALLOCATION_FIELDS))
            }
        }
        Ok(IndividualSpaceAllocation {
            allocated: field_allocated.ok_or_else(|| de::Error::missing_field("allocated"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("allocated", &self.allocated)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IndividualSpaceAllocation {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IndividualSpaceAllocation;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a IndividualSpaceAllocation struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IndividualSpaceAllocation::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IndividualSpaceAllocation", INDIVIDUAL_SPACE_ALLOCATION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IndividualSpaceAllocation {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IndividualSpaceAllocation", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Representations for a person's name to assist with internationalization.
#[derive(Debug)]
pub struct Name {
    /// Also known as a first name.
    pub given_name: String,
    /// Also known as a last name or family name.
    pub surname: String,
    /// Locale-dependent name. In the US, a person's familiar name is their :field:`given_name`, but
    /// elsewhere, it could be any combination of a person's :field:`given_name` and
    /// :field:`surname`.
    pub familiar_name: String,
    /// A name that can be used directly to represent the name of a user's Dropbox account.
    pub display_name: String,
    /// An abbreviated form of the person's name. Their initials in most locales.
    pub abbreviated_name: String,
}

impl Name {
    pub fn new(
        given_name: String,
        surname: String,
        familiar_name: String,
        display_name: String,
        abbreviated_name: String,
    ) -> Self {
        Name {
            given_name,
            surname,
            familiar_name,
            display_name,
            abbreviated_name,
        }
    }

}

const NAME_FIELDS: &'static [&'static str] = &["given_name",
                                               "surname",
                                               "familiar_name",
                                               "display_name",
                                               "abbreviated_name"];
impl Name {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<Name, V::Error> {
        use serde::de;
        let mut field_given_name = None;
        let mut field_surname = None;
        let mut field_familiar_name = None;
        let mut field_display_name = None;
        let mut field_abbreviated_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "given_name" => {
                    if field_given_name.is_some() {
                        return Err(de::Error::duplicate_field("given_name"));
                    }
                    field_given_name = Some(map.next_value()?);
                }
                "surname" => {
                    if field_surname.is_some() {
                        return Err(de::Error::duplicate_field("surname"));
                    }
                    field_surname = Some(map.next_value()?);
                }
                "familiar_name" => {
                    if field_familiar_name.is_some() {
                        return Err(de::Error::duplicate_field("familiar_name"));
                    }
                    field_familiar_name = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "abbreviated_name" => {
                    if field_abbreviated_name.is_some() {
                        return Err(de::Error::duplicate_field("abbreviated_name"));
                    }
                    field_abbreviated_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NAME_FIELDS))
            }
        }
        Ok(Name {
            given_name: field_given_name.ok_or_else(|| de::Error::missing_field("given_name"))?,
            surname: field_surname.ok_or_else(|| de::Error::missing_field("surname"))?,
            familiar_name: field_familiar_name.ok_or_else(|| de::Error::missing_field("familiar_name"))?,
            display_name: field_display_name.ok_or_else(|| de::Error::missing_field("display_name"))?,
            abbreviated_name: field_abbreviated_name.ok_or_else(|| de::Error::missing_field("abbreviated_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("given_name", &self.given_name)?;
        s.serialize_field("surname", &self.surname)?;
        s.serialize_field("familiar_name", &self.familiar_name)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("abbreviated_name", &self.abbreviated_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Name {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Name;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Name struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Name::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Name", NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Name {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Name", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Space is allocated differently based on the type of account.
#[derive(Debug)]
pub enum SpaceAllocation {
    /// The user's space allocation applies only to their individual account.
    Individual(IndividualSpaceAllocation),
    /// The user shares space with other members of their team.
    Team(TeamSpaceAllocation),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceAllocation {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceAllocation;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceAllocation structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "individual" => Ok(SpaceAllocation::Individual(IndividualSpaceAllocation::internal_deserialize(map)?)),
                    "team" => Ok(SpaceAllocation::Team(TeamSpaceAllocation::internal_deserialize(map)?)),
                    _ => Ok(SpaceAllocation::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["individual",
                                                    "team",
                                                    "other"];
        deserializer.deserialize_struct("SpaceAllocation", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceAllocation {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceAllocation::Individual(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("SpaceAllocation", 2)?;
                s.serialize_field(".tag", "individual")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            SpaceAllocation::Team(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("SpaceAllocation", 3)?;
                s.serialize_field(".tag", "team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            SpaceAllocation::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Information about a user's space usage and quota.
#[derive(Debug)]
pub struct SpaceUsage {
    /// The user's total space usage (bytes).
    pub used: u64,
    /// The user's space allocation.
    pub allocation: SpaceAllocation,
}

impl SpaceUsage {
    pub fn new(used: u64, allocation: SpaceAllocation) -> Self {
        SpaceUsage {
            used,
            allocation,
        }
    }

}

const SPACE_USAGE_FIELDS: &'static [&'static str] = &["used",
                                                      "allocation"];
impl SpaceUsage {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SpaceUsage, V::Error> {
        use serde::de;
        let mut field_used = None;
        let mut field_allocation = None;
        while let Some(key) = map.next_key()? {
            match key {
                "used" => {
                    if field_used.is_some() {
                        return Err(de::Error::duplicate_field("used"));
                    }
                    field_used = Some(map.next_value()?);
                }
                "allocation" => {
                    if field_allocation.is_some() {
                        return Err(de::Error::duplicate_field("allocation"));
                    }
                    field_allocation = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SPACE_USAGE_FIELDS))
            }
        }
        Ok(SpaceUsage {
            used: field_used.ok_or_else(|| de::Error::missing_field("used"))?,
            allocation: field_allocation.ok_or_else(|| de::Error::missing_field("allocation"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("used", &self.used)?;
        s.serialize_field("allocation", &self.allocation)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceUsage {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SpaceUsage;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceUsage struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SpaceUsage::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SpaceUsage", SPACE_USAGE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceUsage {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SpaceUsage", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about a team.
#[derive(Debug)]
pub struct Team {
    /// The team's unique ID.
    pub id: String,
    /// The name of the team.
    pub name: String,
}

impl Team {
    pub fn new(id: String, name: String) -> Self {
        Team {
            id,
            name,
        }
    }

}

const TEAM_FIELDS: &'static [&'static str] = &["id",
                                               "name"];
impl Team {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<Team, V::Error> {
        use serde::de;
        let mut field_id = None;
        let mut field_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FIELDS))
            }
        }
        Ok(Team {
            id: field_id.ok_or_else(|| de::Error::missing_field("id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Team {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Team;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Team struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Team::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Team", TEAM_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Team {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Team", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamSpaceAllocation {
    /// The total space currently used by the user's team (bytes).
    pub used: u64,
    /// The total space allocated to the user's team (bytes).
    pub allocated: u64,
}

impl TeamSpaceAllocation {
    pub fn new(used: u64, allocated: u64) -> Self {
        TeamSpaceAllocation {
            used,
            allocated,
        }
    }

}

const TEAM_SPACE_ALLOCATION_FIELDS: &'static [&'static str] = &["used",
                                                                "allocated"];
impl TeamSpaceAllocation {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamSpaceAllocation, V::Error> {
        use serde::de;
        let mut field_used = None;
        let mut field_allocated = None;
        while let Some(key) = map.next_key()? {
            match key {
                "used" => {
                    if field_used.is_some() {
                        return Err(de::Error::duplicate_field("used"));
                    }
                    field_used = Some(map.next_value()?);
                }
                "allocated" => {
                    if field_allocated.is_some() {
                        return Err(de::Error::duplicate_field("allocated"));
                    }
                    field_allocated = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_SPACE_ALLOCATION_FIELDS))
            }
        }
        Ok(TeamSpaceAllocation {
            used: field_used.ok_or_else(|| de::Error::missing_field("used"))?,
            allocated: field_allocated.ok_or_else(|| de::Error::missing_field("allocated"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("used", &self.used)?;
        s.serialize_field("allocated", &self.allocated)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSpaceAllocation {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSpaceAllocation;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamSpaceAllocation struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSpaceAllocation::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSpaceAllocation", TEAM_SPACE_ALLOCATION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSpaceAllocation {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSpaceAllocation", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

