// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

pub type AppId = String;
pub type IpAddress = String;
pub type RequestId = String;

/// Retrieves team events. Permission : Team Auditing.
pub fn get_events(client: &::client_trait::HttpClient, arg: &GetTeamEventsArg) -> ::Result<Result<GetTeamEventsResult, GetTeamEventsError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "team_log/get_events", arg, None)
}

/// Once a cursor has been retrieved from :route:`get_events`, use this to paginate through all
/// events. Permission : Team Auditing.
pub fn get_events_continue(client: &::client_trait::HttpClient, arg: &GetTeamEventsContinueArg) -> ::Result<Result<GetTeamEventsResult, GetTeamEventsContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "team_log/get_events/continue", arg, None)
}

/// Indicates the method in which the action was performed.
#[derive(Debug)]
pub enum AccessMethodLogInfo {
    /// End user session details.
    EndUser(SessionLogInfo),
    /// Sign in as session details.
    SignInAs(WebSessionLogInfo),
    /// Content manager session details.
    ContentManager(WebSessionLogInfo),
    /// Admin console session details.
    AdminConsole(WebSessionLogInfo),
    /// Api session details.
    Api(ApiSessionLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccessMethodLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccessMethodLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccessMethodLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "end_user" => {
                        match map.next_key()? {
                            Some("end_user") => Ok(AccessMethodLogInfo::EndUser(map.next_value()?)),
                            None => Err(de::Error::missing_field("end_user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "sign_in_as" => Ok(AccessMethodLogInfo::SignInAs(WebSessionLogInfo::internal_deserialize(map)?)),
                    "content_manager" => Ok(AccessMethodLogInfo::ContentManager(WebSessionLogInfo::internal_deserialize(map)?)),
                    "admin_console" => Ok(AccessMethodLogInfo::AdminConsole(WebSessionLogInfo::internal_deserialize(map)?)),
                    "api" => Ok(AccessMethodLogInfo::Api(ApiSessionLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AccessMethodLogInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["end_user",
                                                    "sign_in_as",
                                                    "content_manager",
                                                    "admin_console",
                                                    "api",
                                                    "other"];
        deserializer.deserialize_struct("AccessMethodLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccessMethodLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccessMethodLogInfo::EndUser(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "end_user")?;
                s.serialize_field("end_user", x)?;
                s.end()
            }
            AccessMethodLogInfo::SignInAs(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "sign_in_as")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::ContentManager(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "content_manager")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::AdminConsole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "admin_console")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Api(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "api")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AccountCaptureAvailability {
    Unavailable,
    Available,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureAvailability {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCaptureAvailability;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureAvailability structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unavailable" => Ok(AccountCaptureAvailability::Unavailable),
                    "available" => Ok(AccountCaptureAvailability::Available),
                    _ => Ok(AccountCaptureAvailability::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["unavailable",
                                                    "available",
                                                    "other"];
        deserializer.deserialize_struct("AccountCaptureAvailability", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureAvailability {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCaptureAvailability::Unavailable => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "unavailable")?;
                s.end()
            }
            AccountCaptureAvailability::Available => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "available")?;
                s.end()
            }
            AccountCaptureAvailability::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Granted or revoked the option to enable account capture on domains belonging to the team.
#[derive(Debug)]
pub struct AccountCaptureChangeAvailabilityDetails {
    /// New account capture availabilty value.
    pub new_value: AccountCaptureAvailability,
    /// Previous account capture availabilty value. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCaptureAvailability>,
}

impl AccountCaptureChangeAvailabilityDetails {
    pub fn new(new_value: AccountCaptureAvailability) -> Self {
        AccountCaptureChangeAvailabilityDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCaptureAvailability>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                      "previous_value"];
impl AccountCaptureChangeAvailabilityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AccountCaptureChangeAvailabilityDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureChangeAvailabilityDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangeAvailabilityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangeAvailabilityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangeAvailabilityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangeAvailabilityDetails", ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangeAvailabilityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangeAvailabilityDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the account capture policy on a domain belonging to the team.
#[derive(Debug)]
pub struct AccountCaptureChangePolicyDetails {
    /// New account capture policy.
    pub new_value: AccountCapturePolicy,
    /// Previous account capture policy. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCapturePolicy>,
}

impl AccountCaptureChangePolicyDetails {
    pub fn new(new_value: AccountCapturePolicy) -> Self {
        AccountCaptureChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCapturePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                "previous_value"];
impl AccountCaptureChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AccountCaptureChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangePolicyDetails", ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Account captured user migrated their account to the team.
#[derive(Debug)]
pub struct AccountCaptureMigrateAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureMigrateAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureMigrateAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS: &'static [&'static str] = &["domain_name"];
impl AccountCaptureMigrateAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AccountCaptureMigrateAccountDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureMigrateAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureMigrateAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureMigrateAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureMigrateAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureMigrateAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureMigrateAccountDetails", ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureMigrateAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureMigrateAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AccountCapturePolicy {
    Disabled,
    InvitedUsers,
    AllUsers,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCapturePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCapturePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCapturePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(AccountCapturePolicy::Disabled),
                    "invited_users" => Ok(AccountCapturePolicy::InvitedUsers),
                    "all_users" => Ok(AccountCapturePolicy::AllUsers),
                    _ => Ok(AccountCapturePolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "invited_users",
                                                    "all_users",
                                                    "other"];
        deserializer.deserialize_struct("AccountCapturePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCapturePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCapturePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            AccountCapturePolicy::InvitedUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "invited_users")?;
                s.end()
            }
            AccountCapturePolicy::AllUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "all_users")?;
                s.end()
            }
            AccountCapturePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Account captured user relinquished their account by changing the email address associated with
/// it.
#[derive(Debug)]
pub struct AccountCaptureRelinquishAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureRelinquishAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureRelinquishAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS: &'static [&'static str] = &["domain_name"];
impl AccountCaptureRelinquishAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AccountCaptureRelinquishAccountDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureRelinquishAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureRelinquishAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureRelinquishAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureRelinquishAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureRelinquishAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureRelinquishAccountDetails", ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureRelinquishAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureRelinquishAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The entity who performed the action.
#[derive(Debug)]
pub enum ActorLogInfo {
    /// The user who did the action.
    User(UserLogInfo),
    /// The admin who did the action.
    Admin(UserLogInfo),
    /// The application who did the action.
    App(AppLogInfo),
    /// Action done by reseller.
    Reseller(ResellerLogInfo),
    /// Action done by Dropbox.
    Dropbox,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ActorLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ActorLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ActorLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ActorLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "admin" => {
                        match map.next_key()? {
                            Some("admin") => Ok(ActorLogInfo::Admin(map.next_value()?)),
                            None => Err(de::Error::missing_field("admin")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "app" => {
                        match map.next_key()? {
                            Some("app") => Ok(ActorLogInfo::App(map.next_value()?)),
                            None => Err(de::Error::missing_field("app")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "reseller" => Ok(ActorLogInfo::Reseller(ResellerLogInfo::internal_deserialize(map)?)),
                    "dropbox" => Ok(ActorLogInfo::Dropbox),
                    _ => Ok(ActorLogInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user",
                                                    "admin",
                                                    "app",
                                                    "reseller",
                                                    "dropbox",
                                                    "other"];
        deserializer.deserialize_struct("ActorLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ActorLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ActorLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ActorLogInfo::Admin(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "admin")?;
                s.serialize_field("admin", x)?;
                s.end()
            }
            ActorLogInfo::App(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "app")?;
                s.serialize_field("app", x)?;
                s.end()
            }
            ActorLogInfo::Reseller(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 3)?;
                s.serialize_field(".tag", "reseller")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActorLogInfo::Dropbox => {
                // unit
                let mut s = serializer.serialize_struct("ActorLogInfo", 1)?;
                s.serialize_field(".tag", "dropbox")?;
                s.end()
            }
            ActorLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AdminRole {
    User,
    LimitedAdmin,
    SupportAdmin,
    UserManagementAdmin,
    TeamAdmin,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AdminRole {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AdminRole;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AdminRole structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => Ok(AdminRole::User),
                    "limited_admin" => Ok(AdminRole::LimitedAdmin),
                    "support_admin" => Ok(AdminRole::SupportAdmin),
                    "user_management_admin" => Ok(AdminRole::UserManagementAdmin),
                    "team_admin" => Ok(AdminRole::TeamAdmin),
                    _ => Ok(AdminRole::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user",
                                                    "limited_admin",
                                                    "support_admin",
                                                    "user_management_admin",
                                                    "team_admin",
                                                    "other"];
        deserializer.deserialize_struct("AdminRole", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AdminRole {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AdminRole::User => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "user")?;
                s.end()
            }
            AdminRole::LimitedAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "limited_admin")?;
                s.end()
            }
            AdminRole::SupportAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "support_admin")?;
                s.end()
            }
            AdminRole::UserManagementAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "user_management_admin")?;
                s.end()
            }
            AdminRole::TeamAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "team_admin")?;
                s.end()
            }
            AdminRole::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disabled allow downloads.
#[derive(Debug)]
pub struct AllowDownloadDisabledDetails {
}

impl Default for AllowDownloadDisabledDetails {
    fn default() -> Self {
        AllowDownloadDisabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl AllowDownloadDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AllowDownloadDisabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS));
        }
        Ok(AllowDownloadDisabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadDisabledDetails", ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadDisabledDetails", 0)?.end()
    }
}

/// Enabled allow downloads.
#[derive(Debug)]
pub struct AllowDownloadEnabledDetails {
}

impl Default for AllowDownloadEnabledDetails {
    fn default() -> Self {
        AllowDownloadEnabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl AllowDownloadEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AllowDownloadEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS));
        }
        Ok(AllowDownloadEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadEnabledDetails", ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadEnabledDetails", 0)?.end()
    }
}

/// Api session.
#[derive(Debug)]
pub struct ApiSessionLogInfo {
    /// Api request ID.
    pub request_id: RequestId,
}

impl ApiSessionLogInfo {
    pub fn new(request_id: RequestId) -> Self {
        ApiSessionLogInfo {
            request_id,
        }
    }

}

const API_SESSION_LOG_INFO_FIELDS: &'static [&'static str] = &["request_id"];
impl ApiSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ApiSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_request_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_id" => {
                    if field_request_id.is_some() {
                        return Err(de::Error::duplicate_field("request_id"));
                    }
                    field_request_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, API_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(ApiSessionLogInfo {
            request_id: field_request_id.ok_or_else(|| de::Error::missing_field("request_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_id", &self.request_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ApiSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ApiSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ApiSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ApiSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ApiSessionLogInfo", API_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ApiSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ApiSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked an app for team.
#[derive(Debug)]
pub struct AppLinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkTeamDetails {
            app_info,
        }
    }

}

const APP_LINK_TEAM_DETAILS_FIELDS: &'static [&'static str] = &["app_info"];
impl AppLinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AppLinkTeamDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(AppLinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkTeamDetails", APP_LINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked an app for team member.
#[derive(Debug)]
pub struct AppLinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkUserDetails {
            app_info,
        }
    }

}

const APP_LINK_USER_DETAILS_FIELDS: &'static [&'static str] = &["app_info"];
impl AppLinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AppLinkUserDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_USER_DETAILS_FIELDS))
            }
        }
        Ok(AppLinkUserDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkUserDetails", APP_LINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// App's logged information.
#[derive(Debug)]
pub enum AppLogInfo {
    UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo),
    UserLinkedApp(UserLinkedAppLogInfo),
    TeamLinkedApp(TeamLinkedAppLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for AppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_or_team_linked_app" => Ok(AppLogInfo::UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    "user_linked_app" => Ok(AppLogInfo::UserLinkedApp(UserLinkedAppLogInfo::internal_deserialize(map)?)),
                    "team_linked_app" => Ok(AppLogInfo::TeamLinkedApp(TeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AppLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_linked_app",
                                                    "team_linked_app",
                                                    "team_linked_app"];
        deserializer.deserialize_struct("AppLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            AppLogInfo::UserOrTeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_or_team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::UserLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::TeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Unlinked an app for team.
#[derive(Debug)]
pub struct AppUnlinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkTeamDetails {
            app_info,
        }
    }

}

const APP_UNLINK_TEAM_DETAILS_FIELDS: &'static [&'static str] = &["app_info"];
impl AppUnlinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AppUnlinkTeamDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(AppUnlinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkTeamDetails", APP_UNLINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unlinked an app for team member.
#[derive(Debug)]
pub struct AppUnlinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkUserDetails {
            app_info,
        }
    }

}

const APP_UNLINK_USER_DETAILS_FIELDS: &'static [&'static str] = &["app_info"];
impl AppUnlinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AppUnlinkUserDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_USER_DETAILS_FIELDS))
            }
        }
        Ok(AppUnlinkUserDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkUserDetails", APP_UNLINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Asset details.
#[derive(Debug)]
pub enum AssetLogInfo {
    /// File's details.
    File(FileLogInfo),
    /// Folder's details.
    Folder(FolderLogInfo),
    /// Paper docuement's details.
    PaperDocument(PaperDocumentLogInfo),
    /// Paper folder's details.
    PaperFolder(PaperFolderLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AssetLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file" => Ok(AssetLogInfo::File(FileLogInfo::internal_deserialize(map)?)),
                    "folder" => Ok(AssetLogInfo::Folder(FolderLogInfo::internal_deserialize(map)?)),
                    "paper_document" => Ok(AssetLogInfo::PaperDocument(PaperDocumentLogInfo::internal_deserialize(map)?)),
                    "paper_folder" => Ok(AssetLogInfo::PaperFolder(PaperFolderLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AssetLogInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["file",
                                                    "folder",
                                                    "paper_document",
                                                    "paper_folder",
                                                    "other"];
        deserializer.deserialize_struct("AssetLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetLogInfo::File(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 4)?;
                s.serialize_field(".tag", "file")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Folder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 4)?;
                s.serialize_field(".tag", "folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperDocument(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_document")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Certificate details.
#[derive(Debug)]
pub struct Certificate {
    /// Certificate subject.
    pub subject: String,
    /// Certificate issuer.
    pub issuer: String,
    /// Certificate issue date.
    pub issue_date: String,
    /// Certificate expiration date.
    pub expiration_date: String,
    /// Certificate serial number.
    pub serial_number: String,
    /// Certificate sha1 fingerprint.
    pub sha1_fingerprint: String,
    /// Certificate common name.
    pub common_name: String,
}

impl Certificate {
    pub fn new(subject: String, issuer: String, issue_date: String, expiration_date: String, serial_number: String, sha1_fingerprint: String, common_name: String) -> Self {
        Certificate {
            subject,
            issuer,
            issue_date,
            expiration_date,
            serial_number,
            sha1_fingerprint,
            common_name,
        }
    }

}

const CERTIFICATE_FIELDS: &'static [&'static str] = &["subject",
                                                      "issuer",
                                                      "issue_date",
                                                      "expiration_date",
                                                      "serial_number",
                                                      "sha1_fingerprint",
                                                      "common_name"];
impl Certificate {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<Certificate, V::Error> {
        use serde::de;
        let mut field_subject = None;
        let mut field_issuer = None;
        let mut field_issue_date = None;
        let mut field_expiration_date = None;
        let mut field_serial_number = None;
        let mut field_sha1_fingerprint = None;
        let mut field_common_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "subject" => {
                    if field_subject.is_some() {
                        return Err(de::Error::duplicate_field("subject"));
                    }
                    field_subject = Some(map.next_value()?);
                }
                "issuer" => {
                    if field_issuer.is_some() {
                        return Err(de::Error::duplicate_field("issuer"));
                    }
                    field_issuer = Some(map.next_value()?);
                }
                "issue_date" => {
                    if field_issue_date.is_some() {
                        return Err(de::Error::duplicate_field("issue_date"));
                    }
                    field_issue_date = Some(map.next_value()?);
                }
                "expiration_date" => {
                    if field_expiration_date.is_some() {
                        return Err(de::Error::duplicate_field("expiration_date"));
                    }
                    field_expiration_date = Some(map.next_value()?);
                }
                "serial_number" => {
                    if field_serial_number.is_some() {
                        return Err(de::Error::duplicate_field("serial_number"));
                    }
                    field_serial_number = Some(map.next_value()?);
                }
                "sha1_fingerprint" => {
                    if field_sha1_fingerprint.is_some() {
                        return Err(de::Error::duplicate_field("sha1_fingerprint"));
                    }
                    field_sha1_fingerprint = Some(map.next_value()?);
                }
                "common_name" => {
                    if field_common_name.is_some() {
                        return Err(de::Error::duplicate_field("common_name"));
                    }
                    field_common_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CERTIFICATE_FIELDS))
            }
        }
        Ok(Certificate {
            subject: field_subject.ok_or_else(|| de::Error::missing_field("subject"))?,
            issuer: field_issuer.ok_or_else(|| de::Error::missing_field("issuer"))?,
            issue_date: field_issue_date.ok_or_else(|| de::Error::missing_field("issue_date"))?,
            expiration_date: field_expiration_date.ok_or_else(|| de::Error::missing_field("expiration_date"))?,
            serial_number: field_serial_number.ok_or_else(|| de::Error::missing_field("serial_number"))?,
            sha1_fingerprint: field_sha1_fingerprint.ok_or_else(|| de::Error::missing_field("sha1_fingerprint"))?,
            common_name: field_common_name.ok_or_else(|| de::Error::missing_field("common_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("subject", &self.subject)?;
        s.serialize_field("issuer", &self.issuer)?;
        s.serialize_field("issue_date", &self.issue_date)?;
        s.serialize_field("expiration_date", &self.expiration_date)?;
        s.serialize_field("serial_number", &self.serial_number)?;
        s.serialize_field("sha1_fingerprint", &self.sha1_fingerprint)?;
        s.serialize_field("common_name", &self.common_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Certificate {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Certificate;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Certificate struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Certificate::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Certificate", CERTIFICATE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Certificate {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Certificate", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared an album.
#[derive(Debug)]
pub struct CollectionShareDetails {
    /// Album name.
    pub album_name: String,
}

impl CollectionShareDetails {
    pub fn new(album_name: String) -> Self {
        CollectionShareDetails {
            album_name,
        }
    }

}

const COLLECTION_SHARE_DETAILS_FIELDS: &'static [&'static str] = &["album_name"];
impl CollectionShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<CollectionShareDetails, V::Error> {
        use serde::de;
        let mut field_album_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "album_name" => {
                    if field_album_name.is_some() {
                        return Err(de::Error::duplicate_field("album_name"));
                    }
                    field_album_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, COLLECTION_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(CollectionShareDetails {
            album_name: field_album_name.ok_or_else(|| de::Error::missing_field("album_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("album_name", &self.album_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CollectionShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionShareDetails", COLLECTION_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum Confidentiality {
    Confidential,
    NonConfidential,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for Confidentiality {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = Confidentiality;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Confidentiality structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "confidential" => Ok(Confidentiality::Confidential),
                    "non_confidential" => Ok(Confidentiality::NonConfidential),
                    _ => Ok(Confidentiality::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["confidential",
                                                    "non_confidential",
                                                    "other"];
        deserializer.deserialize_struct("Confidentiality", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for Confidentiality {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            Confidentiality::Confidential => {
                // unit
                let mut s = serializer.serialize_struct("Confidentiality", 1)?;
                s.serialize_field(".tag", "confidential")?;
                s.end()
            }
            Confidentiality::NonConfidential => {
                // unit
                let mut s = serializer.serialize_struct("Confidentiality", 1)?;
                s.serialize_field(".tag", "non_confidential")?;
                s.end()
            }
            Confidentiality::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for pemanent content deletion
#[derive(Debug)]
pub enum ContentPermanentDeletePolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContentPermanentDeletePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContentPermanentDeletePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ContentPermanentDeletePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(ContentPermanentDeletePolicy::Disabled),
                    "enabled" => Ok(ContentPermanentDeletePolicy::Enabled),
                    _ => Ok(ContentPermanentDeletePolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("ContentPermanentDeletePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContentPermanentDeletePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContentPermanentDeletePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The primary entity on which the action was done.
#[derive(Debug)]
pub enum ContextLogInfo {
    /// Action was done on behalf of a team member.
    TeamMember(TeamMemberLogInfo),
    /// Action was done on behalf of a non team member.
    NonTeamMember(NonTeamMemberLogInfo),
    /// Action was done on behalf of the team.
    Team,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContextLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContextLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ContextLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(ContextLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(ContextLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    "team" => Ok(ContextLogInfo::Team),
                    _ => Ok(ContextLogInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_member",
                                                    "non_team_member",
                                                    "team",
                                                    "other"];
        deserializer.deserialize_struct("ContextLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContextLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContextLogInfo::TeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 6)?;
                s.serialize_field(".tag", "team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::NonTeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::Team => {
                // unit
                let mut s = serializer.serialize_struct("ContextLogInfo", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            ContextLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created folders.
#[derive(Debug)]
pub struct CreateFolderDetails {
}

impl Default for CreateFolderDetails {
    fn default() -> Self {
        CreateFolderDetails {
        }
    }
}

const CREATE_FOLDER_DETAILS_FIELDS: &'static [&'static str] = &[];
impl CreateFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<CreateFolderDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, CREATE_FOLDER_DETAILS_FIELDS));
        }
        Ok(CreateFolderDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFolderDetails", CREATE_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("CreateFolderDetails", 0)?.end()
    }
}

/// Set a restriction policy regarding the location of data centers where team data resides.
#[derive(Debug)]
pub struct DataPlacementRestrictionChangePolicyDetails {
    /// Previous placement restriction.
    pub previous_value: PlacementRestriction,
    /// New placement restriction.
    pub new_value: PlacementRestriction,
}

impl DataPlacementRestrictionChangePolicyDetails {
    pub fn new(previous_value: PlacementRestriction, new_value: PlacementRestriction) -> Self {
        DataPlacementRestrictionChangePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                                           "new_value"];
impl DataPlacementRestrictionChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DataPlacementRestrictionChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionChangePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionChangePolicyDetails", DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Satisfied a previously set restriction policy regarding the location of data centers where team
/// data resides (i.e. all data have been migrated according to the restriction placed).
#[derive(Debug)]
pub struct DataPlacementRestrictionSatisfyPolicyDetails {
    /// Placement restriction.
    pub placement_restriction: PlacementRestriction,
}

impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub fn new(placement_restriction: PlacementRestriction) -> Self {
        DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["placement_restriction"];
impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DataPlacementRestrictionSatisfyPolicyDetails, V::Error> {
        use serde::de;
        let mut field_placement_restriction = None;
        while let Some(key) = map.next_key()? {
            match key {
                "placement_restriction" => {
                    if field_placement_restriction.is_some() {
                        return Err(de::Error::duplicate_field("placement_restriction"));
                    }
                    field_placement_restriction = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction: field_placement_restriction.ok_or_else(|| de::Error::missing_field("placement_restriction"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("placement_restriction", &self.placement_restriction)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionSatisfyPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionSatisfyPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionSatisfyPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionSatisfyPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Desktop session.
#[derive(Debug)]
pub struct DesktopSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for DesktopSessionLogInfo {
    fn default() -> Self {
        DesktopSessionLogInfo {
            session_id: None,
        }
    }
}

const DESKTOP_SESSION_LOG_INFO_FIELDS: &'static [&'static str] = &["session_id"];
impl DesktopSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DesktopSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DESKTOP_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(DesktopSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DesktopSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopSessionLogInfo", DESKTOP_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set or removed a limit on the number of computers each team member can link to their work
/// Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeDesktopPolicyDetails {
    /// New desktop device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous desktop device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeDesktopPolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                         "previous_value"];
impl DeviceApprovalsChangeDesktopPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceApprovalsChangeDesktopPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeDesktopPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeDesktopPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeDesktopPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeDesktopPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set or removed a limit on the number of mobiles devices each team member can link to their work
/// Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeMobilePolicyDetails {
    /// New mobile device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous mobile device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeMobilePolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeMobilePolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                        "previous_value"];
impl DeviceApprovalsChangeMobilePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceApprovalsChangeMobilePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeMobilePolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeMobilePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeMobilePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeMobilePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeMobilePolicyDetails", DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeMobilePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeMobilePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the action taken when a team member is already over the limits (e.g when they join the
/// team, an admin lowers limits, etc.).
#[derive(Debug)]
pub struct DeviceApprovalsChangeOverageActionDetails {
    /// New over the limits policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsRolloutPolicy>,
    /// Previous over the limit policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsRolloutPolicy>,
}

impl Default for DeviceApprovalsChangeOverageActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeOverageActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                         "previous_value"];
impl DeviceApprovalsChangeOverageActionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceApprovalsChangeOverageActionDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeOverageActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeOverageActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeOverageActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeOverageActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeOverageActionDetails", DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeOverageActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeOverageActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the action taken with respect to approval limits when a team member unlinks an approved
/// device.
#[derive(Debug)]
pub struct DeviceApprovalsChangeUnlinkActionDetails {
    /// New device unlink policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceUnlinkPolicy>,
    /// Previous device unlink policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceUnlinkPolicy>,
}

impl Default for DeviceApprovalsChangeUnlinkActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeUnlinkActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                        "previous_value"];
impl DeviceApprovalsChangeUnlinkActionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceApprovalsChangeUnlinkActionDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeUnlinkActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeUnlinkActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeUnlinkActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeUnlinkActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeUnlinkActionDetails", DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeUnlinkActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeUnlinkActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceApprovalsPolicy {
    Unlimited,
    Limited,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceApprovalsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unlimited" => Ok(DeviceApprovalsPolicy::Unlimited),
                    "limited" => Ok(DeviceApprovalsPolicy::Limited),
                    _ => Ok(DeviceApprovalsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["unlimited",
                                                    "limited",
                                                    "other"];
        deserializer.deserialize_struct("DeviceApprovalsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceApprovalsPolicy::Unlimited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "unlimited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Limited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "limited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum DeviceApprovalsRolloutPolicy {
    RemoveOldest,
    RemoveAll,
    AddException,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsRolloutPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceApprovalsRolloutPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsRolloutPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove_oldest" => Ok(DeviceApprovalsRolloutPolicy::RemoveOldest),
                    "remove_all" => Ok(DeviceApprovalsRolloutPolicy::RemoveAll),
                    "add_exception" => Ok(DeviceApprovalsRolloutPolicy::AddException),
                    _ => Ok(DeviceApprovalsRolloutPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["remove_oldest",
                                                    "remove_all",
                                                    "add_exception",
                                                    "other"];
        deserializer.deserialize_struct("DeviceApprovalsRolloutPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsRolloutPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceApprovalsRolloutPolicy::RemoveOldest => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsRolloutPolicy", 1)?;
                s.serialize_field(".tag", "remove_oldest")?;
                s.end()
            }
            DeviceApprovalsRolloutPolicy::RemoveAll => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsRolloutPolicy", 1)?;
                s.serialize_field(".tag", "remove_all")?;
                s.end()
            }
            DeviceApprovalsRolloutPolicy::AddException => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsRolloutPolicy", 1)?;
                s.serialize_field(".tag", "add_exception")?;
                s.end()
            }
            DeviceApprovalsRolloutPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// IP address associated with active desktop session changed.
#[derive(Debug)]
pub struct DeviceChangeIpDesktopDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
}

impl DeviceChangeIpDesktopDetails {
    pub fn new(device_info: DeviceLogInfo) -> Self {
        DeviceChangeIpDesktopDetails {
            device_info,
        }
    }

}

const DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS: &'static [&'static str] = &["device_info"];
impl DeviceChangeIpDesktopDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceChangeIpDesktopDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpDesktopDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpDesktopDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpDesktopDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpDesktopDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpDesktopDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpDesktopDetails", DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpDesktopDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpDesktopDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// IP address associated with active mobile session changed.
#[derive(Debug)]
pub struct DeviceChangeIpMobileDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
}

impl DeviceChangeIpMobileDetails {
    pub fn new(device_info: DeviceLogInfo) -> Self {
        DeviceChangeIpMobileDetails {
            device_info,
        }
    }

}

const DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS: &'static [&'static str] = &["device_info"];
impl DeviceChangeIpMobileDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceChangeIpMobileDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpMobileDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpMobileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpMobileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpMobileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpMobileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpMobileDetails", DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpMobileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpMobileDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// IP address associated with active Web session changed.
#[derive(Debug)]
pub struct DeviceChangeIpWebDetails {
    /// Web browser name.
    pub user_agent: String,
    /// Device information. Might be missing due to historical data gap.
    pub device_info: Option<DeviceLogInfo>,
}

impl DeviceChangeIpWebDetails {
    pub fn new(user_agent: String) -> Self {
        DeviceChangeIpWebDetails {
            user_agent,
            device_info: None,
        }
    }

    pub fn with_device_info(mut self, value: Option<DeviceLogInfo>) -> Self {
        self.device_info = value;
        self
    }

}

const DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS: &'static [&'static str] = &["user_agent",
                                                                       "device_info"];
impl DeviceChangeIpWebDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceChangeIpWebDetails, V::Error> {
        use serde::de;
        let mut field_user_agent = None;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpWebDetails {
            user_agent: field_user_agent.ok_or_else(|| de::Error::missing_field("user_agent"))?,
            device_info: field_device_info,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_agent", &self.user_agent)?;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpWebDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpWebDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpWebDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpWebDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpWebDetails", DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpWebDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpWebDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to delete all files from an unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkFailDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
    /// The number of times that remote file deletion failed.
    pub num_failures: i64,
}

impl DeviceDeleteOnUnlinkFailDetails {
    pub fn new(device_info: DeviceLogInfo, num_failures: i64) -> Self {
        DeviceDeleteOnUnlinkFailDetails {
            device_info,
            num_failures,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS: &'static [&'static str] = &["device_info",
                                                                               "num_failures"];
impl DeviceDeleteOnUnlinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceDeleteOnUnlinkFailDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        let mut field_num_failures = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                "num_failures" => {
                    if field_num_failures.is_some() {
                        return Err(de::Error::duplicate_field("num_failures"));
                    }
                    field_num_failures = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkFailDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
            num_failures: field_num_failures.ok_or_else(|| de::Error::missing_field("num_failures"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)?;
        s.serialize_field("num_failures", &self.num_failures)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkFailDetails", DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted all files from an unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkSuccessDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
}

impl DeviceDeleteOnUnlinkSuccessDetails {
    pub fn new(device_info: DeviceLogInfo) -> Self {
        DeviceDeleteOnUnlinkSuccessDetails {
            device_info,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS: &'static [&'static str] = &["device_info"];
impl DeviceDeleteOnUnlinkSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceDeleteOnUnlinkSuccessDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkSuccessDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkSuccessDetails", DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkSuccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to link a device.
#[derive(Debug)]
pub struct DeviceLinkFailDetails {
    /// A description of the device used while user approval blocked.
    pub device_type: DeviceType,
    /// Device information. Might be missing due to historical data gap.
    pub device_info: Option<DeviceLogInfo>,
}

impl DeviceLinkFailDetails {
    pub fn new(device_type: DeviceType) -> Self {
        DeviceLinkFailDetails {
            device_type,
            device_info: None,
        }
    }

    pub fn with_device_info(mut self, value: Option<DeviceLogInfo>) -> Self {
        self.device_info = value;
        self
    }

}

const DEVICE_LINK_FAIL_DETAILS_FIELDS: &'static [&'static str] = &["device_type",
                                                                   "device_info"];
impl DeviceLinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceLinkFailDetails, V::Error> {
        use serde::de;
        let mut field_device_type = None;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DeviceLinkFailDetails {
            device_type: field_device_type.ok_or_else(|| de::Error::missing_field("device_type"))?,
            device_info: field_device_info,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkFailDetails", DEVICE_LINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked a device.
#[derive(Debug)]
pub struct DeviceLinkSuccessDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
}

impl DeviceLinkSuccessDetails {
    pub fn new(device_info: DeviceLogInfo) -> Self {
        DeviceLinkSuccessDetails {
            device_info,
        }
    }

}

const DEVICE_LINK_SUCCESS_DETAILS_FIELDS: &'static [&'static str] = &["device_info"];
impl DeviceLinkSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceLinkSuccessDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DeviceLinkSuccessDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkSuccessDetails", DEVICE_LINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkSuccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Device's logged information.
#[derive(Debug)]
pub struct DeviceLogInfo {
    /// Device unique id. Might be missing due to historical data gap.
    pub device_id: Option<String>,
    /// Device display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// True if this device is emm managed, false otherwise. Might be missing due to historical data
    /// gap.
    pub is_emm_managed: Option<bool>,
    /// Device platform name. Might be missing due to historical data gap.
    pub platform: Option<String>,
    /// Device mac address. Might be missing due to historical data gap.
    pub mac_address: Option<String>,
    /// Device OS version. Might be missing due to historical data gap.
    pub os_version: Option<String>,
    /// Device type. Might be missing due to historical data gap.
    pub device_type: Option<String>,
    /// IP address. Might be missing due to historical data gap.
    pub ip_address: Option<IpAddress>,
    /// Last activity. Might be missing due to historical data gap.
    pub last_activity: Option<String>,
    /// Linking app version. Might be missing due to historical data gap.
    pub app_version: Option<String>,
}

impl Default for DeviceLogInfo {
    fn default() -> Self {
        DeviceLogInfo {
            device_id: None,
            display_name: None,
            is_emm_managed: None,
            platform: None,
            mac_address: None,
            os_version: None,
            device_type: None,
            ip_address: None,
            last_activity: None,
            app_version: None,
        }
    }
}

const DEVICE_LOG_INFO_FIELDS: &'static [&'static str] = &["device_id",
                                                          "display_name",
                                                          "is_emm_managed",
                                                          "platform",
                                                          "mac_address",
                                                          "os_version",
                                                          "device_type",
                                                          "ip_address",
                                                          "last_activity",
                                                          "app_version"];
impl DeviceLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceLogInfo, V::Error> {
        use serde::de;
        let mut field_device_id = None;
        let mut field_display_name = None;
        let mut field_is_emm_managed = None;
        let mut field_platform = None;
        let mut field_mac_address = None;
        let mut field_os_version = None;
        let mut field_device_type = None;
        let mut field_ip_address = None;
        let mut field_last_activity = None;
        let mut field_app_version = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_id" => {
                    if field_device_id.is_some() {
                        return Err(de::Error::duplicate_field("device_id"));
                    }
                    field_device_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "mac_address" => {
                    if field_mac_address.is_some() {
                        return Err(de::Error::duplicate_field("mac_address"));
                    }
                    field_mac_address = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "last_activity" => {
                    if field_last_activity.is_some() {
                        return Err(de::Error::duplicate_field("last_activity"));
                    }
                    field_last_activity = Some(map.next_value()?);
                }
                "app_version" => {
                    if field_app_version.is_some() {
                        return Err(de::Error::duplicate_field("app_version"));
                    }
                    field_app_version = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LOG_INFO_FIELDS))
            }
        }
        Ok(DeviceLogInfo {
            device_id: field_device_id,
            display_name: field_display_name,
            is_emm_managed: field_is_emm_managed,
            platform: field_platform,
            mac_address: field_mac_address,
            os_version: field_os_version,
            device_type: field_device_type,
            ip_address: field_ip_address,
            last_activity: field_last_activity,
            app_version: field_app_version,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_id", &self.device_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("mac_address", &self.mac_address)?;
        s.serialize_field("os_version", &self.os_version)?;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("last_activity", &self.last_activity)?;
        s.serialize_field("app_version", &self.app_version)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLogInfo", DEVICE_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLogInfo", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disable Device Management.
#[derive(Debug)]
pub struct DeviceManagementDisabledDetails {
}

impl Default for DeviceManagementDisabledDetails {
    fn default() -> Self {
        DeviceManagementDisabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DeviceManagementDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceManagementDisabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS));
        }
        Ok(DeviceManagementDisabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementDisabledDetails", DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementDisabledDetails", 0)?.end()
    }
}

/// Enable Device Management.
#[derive(Debug)]
pub struct DeviceManagementEnabledDetails {
}

impl Default for DeviceManagementEnabledDetails {
    fn default() -> Self {
        DeviceManagementEnabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DeviceManagementEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceManagementEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS));
        }
        Ok(DeviceManagementEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementEnabledDetails", DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub enum DeviceType {
    Desktop,
    Mobile,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "desktop" => Ok(DeviceType::Desktop),
                    "mobile" => Ok(DeviceType::Mobile),
                    _ => Ok(DeviceType::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["desktop",
                                                    "mobile",
                                                    "other"];
        deserializer.deserialize_struct("DeviceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceType::Desktop => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "desktop")?;
                s.end()
            }
            DeviceType::Mobile => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "mobile")?;
                s.end()
            }
            DeviceType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disconnected a device.
#[derive(Debug)]
pub struct DeviceUnlinkDetails {
    /// Device information.
    pub device_info: DeviceLogInfo,
    /// True if the user requested to delete data after device unlink, false otherwise.
    pub delete_data: bool,
}

impl DeviceUnlinkDetails {
    pub fn new(device_info: DeviceLogInfo, delete_data: bool) -> Self {
        DeviceUnlinkDetails {
            device_info,
            delete_data,
        }
    }

}

const DEVICE_UNLINK_DETAILS_FIELDS: &'static [&'static str] = &["device_info",
                                                                "delete_data"];
impl DeviceUnlinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DeviceUnlinkDetails, V::Error> {
        use serde::de;
        let mut field_device_info = None;
        let mut field_delete_data = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_info" => {
                    if field_device_info.is_some() {
                        return Err(de::Error::duplicate_field("device_info"));
                    }
                    field_device_info = Some(map.next_value()?);
                }
                "delete_data" => {
                    if field_delete_data.is_some() {
                        return Err(de::Error::duplicate_field("delete_data"));
                    }
                    field_delete_data = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_UNLINK_DETAILS_FIELDS))
            }
        }
        Ok(DeviceUnlinkDetails {
            device_info: field_device_info.ok_or_else(|| de::Error::missing_field("device_info"))?,
            delete_data: field_delete_data.ok_or_else(|| de::Error::missing_field("delete_data"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_info", &self.device_info)?;
        s.serialize_field("delete_data", &self.delete_data)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceUnlinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceUnlinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceUnlinkDetails", DEVICE_UNLINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceUnlinkDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceUnlinkPolicy {
    Remove,
    Keep,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceUnlinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove" => Ok(DeviceUnlinkPolicy::Remove),
                    "keep" => Ok(DeviceUnlinkPolicy::Keep),
                    _ => Ok(DeviceUnlinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["remove",
                                                    "keep",
                                                    "other"];
        deserializer.deserialize_struct("DeviceUnlinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceUnlinkPolicy::Remove => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "remove")?;
                s.end()
            }
            DeviceUnlinkPolicy::Keep => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "keep")?;
                s.end()
            }
            DeviceUnlinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disabled domain invites.
#[derive(Debug)]
pub struct DisabledDomainInvitesDetails {
}

impl Default for DisabledDomainInvitesDetails {
    fn default() -> Self {
        DisabledDomainInvitesDetails {
        }
    }
}

const DISABLED_DOMAIN_INVITES_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DisabledDomainInvitesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DisabledDomainInvitesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DISABLED_DOMAIN_INVITES_DETAILS_FIELDS));
        }
        Ok(DisabledDomainInvitesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DisabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DisabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DisabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DisabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DisabledDomainInvitesDetails", DISABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DisabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DisabledDomainInvitesDetails", 0)?.end()
    }
}

/// Approved a member's request to join the team.
#[derive(Debug)]
pub struct DomainInvitesApproveRequestToJoinTeamDetails {
}

impl Default for DomainInvitesApproveRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesApproveRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DomainInvitesApproveRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesApproveRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesApproveRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesApproveRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesApproveRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesApproveRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesApproveRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", 0)?.end()
    }
}

/// Declined a user's request to join the team.
#[derive(Debug)]
pub struct DomainInvitesDeclineRequestToJoinTeamDetails {
}

impl Default for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesDeclineRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DomainInvitesDeclineRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesDeclineRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesDeclineRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesDeclineRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesDeclineRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", 0)?.end()
    }
}

/// Sent domain invites to existing domain accounts.
#[derive(Debug)]
pub struct DomainInvitesEmailExistingUsersDetails {
    /// Domain names.
    pub domain_name: Vec<String>,
    /// Number of recipients.
    pub num_recipients: u64,
}

impl DomainInvitesEmailExistingUsersDetails {
    pub fn new(domain_name: Vec<String>, num_recipients: u64) -> Self {
        DomainInvitesEmailExistingUsersDetails {
            domain_name,
            num_recipients,
        }
    }

}

const DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS: &'static [&'static str] = &["domain_name",
                                                                                      "num_recipients"];
impl DomainInvitesEmailExistingUsersDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesEmailExistingUsersDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        let mut field_num_recipients = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "num_recipients" => {
                    if field_num_recipients.is_some() {
                        return Err(de::Error::duplicate_field("num_recipients"));
                    }
                    field_num_recipients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS))
            }
        }
        Ok(DomainInvitesEmailExistingUsersDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
            num_recipients: field_num_recipients.ok_or_else(|| de::Error::missing_field("num_recipients"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("num_recipients", &self.num_recipients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesEmailExistingUsersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesEmailExistingUsersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesEmailExistingUsersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesEmailExistingUsersDetails", DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesEmailExistingUsersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesEmailExistingUsersDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Asked to join the team.
#[derive(Debug)]
pub struct DomainInvitesRequestToJoinTeamDetails {
}

impl Default for DomainInvitesRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DomainInvitesRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesRequestToJoinTeamDetails", DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesRequestToJoinTeamDetails", 0)?.end()
    }
}

/// Turned off u201cAutomatically invite new usersu201d.
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToNoDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToNoDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DomainInvitesSetInviteNewUserPrefToNoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesSetInviteNewUserPrefToNoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS));
        }
        Ok(DomainInvitesSetInviteNewUserPrefToNoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToNoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToNoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", 0)?.end()
    }
}

/// Turned on u201cAutomatically invite new usersu201d.
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToYesDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToYesDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS: &'static [&'static str] = &[];
impl DomainInvitesSetInviteNewUserPrefToYesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainInvitesSetInviteNewUserPrefToYesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS));
        }
        Ok(DomainInvitesSetInviteNewUserPrefToYesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToYesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToYesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", 0)?.end()
    }
}

/// Failed to verify a domain belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationAddDomainFailDetails {
    /// Domain name.
    pub domain_name: String,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainFailDetails {
    pub fn new(domain_name: String) -> Self {
        DomainVerificationAddDomainFailDetails {
            domain_name,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS: &'static [&'static str] = &["domain_name",
                                                                                      "verification_method"];
impl DomainVerificationAddDomainFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainVerificationAddDomainFailDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        let mut field_verification_method = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainFailDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
            verification_method: field_verification_method,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainFailDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Verified a domain belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationAddDomainSuccessDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainSuccessDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationAddDomainSuccessDetails {
            domain_names,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS: &'static [&'static str] = &["domain_names",
                                                                                         "verification_method"];
impl DomainVerificationAddDomainSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainVerificationAddDomainSuccessDetails, V::Error> {
        use serde::de;
        let mut field_domain_names = None;
        let mut field_verification_method = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainSuccessDetails {
            domain_names: field_domain_names.ok_or_else(|| de::Error::missing_field("domain_names"))?,
            verification_method: field_verification_method,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainSuccessDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a domain from the list of verified domains belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationRemoveDomainDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationRemoveDomainDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationRemoveDomainDetails {
            domain_names,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS: &'static [&'static str] = &["domain_names",
                                                                                    "verification_method"];
impl DomainVerificationRemoveDomainDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DomainVerificationRemoveDomainDetails, V::Error> {
        use serde::de;
        let mut field_domain_names = None;
        let mut field_verification_method = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationRemoveDomainDetails {
            domain_names: field_domain_names.ok_or_else(|| de::Error::missing_field("domain_names"))?,
            verification_method: field_verification_method,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationRemoveDomainDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationRemoveDomainDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationRemoveDomainDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationRemoveDomainDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationRemoveDomainDetails", DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationRemoveDomainDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationRemoveDomainDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Represents a time duration: unit and amount
#[derive(Debug)]
pub struct DurationLogInfo {
    /// Time unit.
    pub unit: TimeUnit,
    /// Amount of time.
    pub amount: u64,
}

impl DurationLogInfo {
    pub fn new(unit: TimeUnit, amount: u64) -> Self {
        DurationLogInfo {
            unit,
            amount,
        }
    }

}

const DURATION_LOG_INFO_FIELDS: &'static [&'static str] = &["unit",
                                                            "amount"];
impl DurationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<DurationLogInfo, V::Error> {
        use serde::de;
        let mut field_unit = None;
        let mut field_amount = None;
        while let Some(key) = map.next_key()? {
            match key {
                "unit" => {
                    if field_unit.is_some() {
                        return Err(de::Error::duplicate_field("unit"));
                    }
                    field_unit = Some(map.next_value()?);
                }
                "amount" => {
                    if field_amount.is_some() {
                        return Err(de::Error::duplicate_field("amount"));
                    }
                    field_amount = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DURATION_LOG_INFO_FIELDS))
            }
        }
        Ok(DurationLogInfo {
            unit: field_unit.ok_or_else(|| de::Error::missing_field("unit"))?,
            amount: field_amount.ok_or_else(|| de::Error::missing_field("amount"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("unit", &self.unit)?;
        s.serialize_field("amount", &self.amount)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DurationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DurationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DurationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DurationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DurationLogInfo", DURATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DurationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DurationLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an exception for one or more team members to optionally use the regular Dropbox app when
/// EMM is enabled.
#[derive(Debug)]
pub struct EmmAddExceptionDetails {
}

impl Default for EmmAddExceptionDetails {
    fn default() -> Self {
        EmmAddExceptionDetails {
        }
    }
}

const EMM_ADD_EXCEPTION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmAddExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmAddExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_ADD_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(EmmAddExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmAddExceptionDetails", EMM_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmAddExceptionDetails", 0)?.end()
    }
}

/// Enabled or disabled enterprise mobility management for team members.
#[derive(Debug)]
pub struct EmmChangePolicyDetails {
    /// New enterprise mobility management policy.
    pub new_value: EmmPolicy,
    /// Previous enterprise mobility management policy. Might be missing due to historical data gap.
    pub previous_value: Option<EmmPolicy>,
}

impl EmmChangePolicyDetails {
    pub fn new(new_value: EmmPolicy) -> Self {
        EmmChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<EmmPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const EMM_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                    "previous_value"];
impl EmmChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(EmmChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmChangePolicyDetails", EMM_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// EMM excluded users report created.
#[derive(Debug)]
pub struct EmmCreateExceptionsReportDetails {
}

impl Default for EmmCreateExceptionsReportDetails {
    fn default() -> Self {
        EmmCreateExceptionsReportDetails {
        }
    }
}

const EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmCreateExceptionsReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmCreateExceptionsReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS));
        }
        Ok(EmmCreateExceptionsReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateExceptionsReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateExceptionsReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateExceptionsReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateExceptionsReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateExceptionsReportDetails", EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateExceptionsReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateExceptionsReportDetails", 0)?.end()
    }
}

/// EMM mobile app usage report created.
#[derive(Debug)]
pub struct EmmCreateUsageReportDetails {
}

impl Default for EmmCreateUsageReportDetails {
    fn default() -> Self {
        EmmCreateUsageReportDetails {
        }
    }
}

const EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmCreateUsageReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmCreateUsageReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS));
        }
        Ok(EmmCreateUsageReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateUsageReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateUsageReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateUsageReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateUsageReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateUsageReportDetails", EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateUsageReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateUsageReportDetails", 0)?.end()
    }
}

/// Signed in using the Dropbox EMM app.
#[derive(Debug)]
pub struct EmmLoginSuccessDetails {
}

impl Default for EmmLoginSuccessDetails {
    fn default() -> Self {
        EmmLoginSuccessDetails {
        }
    }
}

const EMM_LOGIN_SUCCESS_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmLoginSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmLoginSuccessDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_LOGIN_SUCCESS_DETAILS_FIELDS));
        }
        Ok(EmmLoginSuccessDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmLoginSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmLoginSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmLoginSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmLoginSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmLoginSuccessDetails", EMM_LOGIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmLoginSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmLoginSuccessDetails", 0)?.end()
    }
}

/// Enterprise mobility management policy
#[derive(Debug)]
pub enum EmmPolicy {
    Disabled,
    Optional,
    Required,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EmmPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EmmPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(EmmPolicy::Disabled),
                    "optional" => Ok(EmmPolicy::Optional),
                    "required" => Ok(EmmPolicy::Required),
                    _ => Ok(EmmPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "optional",
                                                    "required",
                                                    "other"];
        deserializer.deserialize_struct("EmmPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EmmPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EmmPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("EmmPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            EmmPolicy::Optional => {
                // unit
                let mut s = serializer.serialize_struct("EmmPolicy", 1)?;
                s.serialize_field(".tag", "optional")?;
                s.end()
            }
            EmmPolicy::Required => {
                // unit
                let mut s = serializer.serialize_struct("EmmPolicy", 1)?;
                s.serialize_field(".tag", "required")?;
                s.end()
            }
            EmmPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Refreshed the auth token used for setting up enterprise mobility management.
#[derive(Debug)]
pub struct EmmRefreshAuthTokenDetails {
}

impl Default for EmmRefreshAuthTokenDetails {
    fn default() -> Self {
        EmmRefreshAuthTokenDetails {
        }
    }
}

const EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmRefreshAuthTokenDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmRefreshAuthTokenDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS));
        }
        Ok(EmmRefreshAuthTokenDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRefreshAuthTokenDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRefreshAuthTokenDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRefreshAuthTokenDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRefreshAuthTokenDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRefreshAuthTokenDetails", EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRefreshAuthTokenDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRefreshAuthTokenDetails", 0)?.end()
    }
}

/// Removed an exception for one or more team members to optionally use the regular Dropbox app when
/// EMM is enabled.
#[derive(Debug)]
pub struct EmmRemoveExceptionDetails {
}

impl Default for EmmRemoveExceptionDetails {
    fn default() -> Self {
        EmmRemoveExceptionDetails {
        }
    }
}

const EMM_REMOVE_EXCEPTION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EmmRemoveExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EmmRemoveExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_REMOVE_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(EmmRemoveExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRemoveExceptionDetails", EMM_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRemoveExceptionDetails", 0)?.end()
    }
}

/// Enabled domain invites.
#[derive(Debug)]
pub struct EnabledDomainInvitesDetails {
}

impl Default for EnabledDomainInvitesDetails {
    fn default() -> Self {
        EnabledDomainInvitesDetails {
        }
    }
}

const ENABLED_DOMAIN_INVITES_DETAILS_FIELDS: &'static [&'static str] = &[];
impl EnabledDomainInvitesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<EnabledDomainInvitesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ENABLED_DOMAIN_INVITES_DETAILS_FIELDS));
        }
        Ok(EnabledDomainInvitesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EnabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnabledDomainInvitesDetails", ENABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EnabledDomainInvitesDetails", 0)?.end()
    }
}

/// Category of events in event audit log.
#[derive(Debug)]
pub enum EventCategory {
    /// Events that have to do with account capture and invite enforcement on team-owned domains.
    AccountCapture,
    /// Events that relate to team and team member account administration or team administration.
    /// Note that these actions are not necessarily performed by team admins. They might also be
    /// performed by Dropbox Support or System or by team members on their own accounts.
    Administration,
    /// Events that apply to management of linked apps.
    Apps,
    /// Events that apply to user authentication in some way.
    Authentication,
    /// Events that have to do with comments on files and Paper documents.
    Comments,
    /// Events that apply to changes how people can access content on Dropbox as well as actions
    /// that represent actually accessing content.
    ContentAccess,
    /// Events that apply to linked devices on mobile, desktop and Web platforms.
    Devices,
    /// Events that concern device approvals and device management.
    DeviceApprovals,
    /// Events that involve domain management feature: domain verification, invite enforcement and
    /// account capture.
    Domains,
    /// Events that involve enterprise mobility management and the Dropbox EMM app.
    Emm,
    /// Events that mark some type of unexpected outcome.
    Errors,
    /// Events that mark a user's interaction with files and folders on Dropbox.
    Files,
    /// Events that have to do with filesystem operations on files and folders: copy, move, delete,
    /// etc.
    FileOperations,
    /// Events that apply to the file requests feature.
    FileRequests,
    /// Events that involve group management.
    Groups,
    /// Events that involve users signing in to or out of Dropbox.
    Logins,
    /// Events that involve team member management.
    Members,
    /// Events that apply to Dropbox Paper.
    Paper,
    /// Events that involve using, changing or resetting passwords.
    Passwords,
    /// Events that concern generation of admin reports, including team activity and device usage.
    Reports,
    /// Events that mark the beginning or end of sessions as well as those that apply to an ongoing
    /// session.
    Sessions,
    /// Events that specifically apply to shared files.
    SharedFiles,
    /// Events that specifically apply to shared folders.
    SharedFolders,
    /// Events that specifically apply to link sharing.
    SharedLinks,
    /// Events that apply to all types of sharing and collaboration.
    Sharing,
    /// Events that concern policies that affect sharing - both at the team level and at the folder
    /// level.
    SharingPolicies,
    /// Events that involve using or configuring single sign-on as well as administrative policies
    /// concerning single sign-on.
    Sso,
    /// Events that involve team folder management.
    TeamFolders,
    /// Events that involve a change in team-wide policies.
    TeamPolicies,
    /// Events that involve a change in the team profile.
    TeamProfile,
    /// Events that involve using or configuring two factor authentication as well as administrative
    /// policies concerning two factor authentication.
    Tfa,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventCategory {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventCategory;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventCategory structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "account_capture" => Ok(EventCategory::AccountCapture),
                    "administration" => Ok(EventCategory::Administration),
                    "apps" => Ok(EventCategory::Apps),
                    "authentication" => Ok(EventCategory::Authentication),
                    "comments" => Ok(EventCategory::Comments),
                    "content_access" => Ok(EventCategory::ContentAccess),
                    "devices" => Ok(EventCategory::Devices),
                    "device_approvals" => Ok(EventCategory::DeviceApprovals),
                    "domains" => Ok(EventCategory::Domains),
                    "emm" => Ok(EventCategory::Emm),
                    "errors" => Ok(EventCategory::Errors),
                    "files" => Ok(EventCategory::Files),
                    "file_operations" => Ok(EventCategory::FileOperations),
                    "file_requests" => Ok(EventCategory::FileRequests),
                    "groups" => Ok(EventCategory::Groups),
                    "logins" => Ok(EventCategory::Logins),
                    "members" => Ok(EventCategory::Members),
                    "paper" => Ok(EventCategory::Paper),
                    "passwords" => Ok(EventCategory::Passwords),
                    "reports" => Ok(EventCategory::Reports),
                    "sessions" => Ok(EventCategory::Sessions),
                    "shared_files" => Ok(EventCategory::SharedFiles),
                    "shared_folders" => Ok(EventCategory::SharedFolders),
                    "shared_links" => Ok(EventCategory::SharedLinks),
                    "sharing" => Ok(EventCategory::Sharing),
                    "sharing_policies" => Ok(EventCategory::SharingPolicies),
                    "sso" => Ok(EventCategory::Sso),
                    "team_folders" => Ok(EventCategory::TeamFolders),
                    "team_policies" => Ok(EventCategory::TeamPolicies),
                    "team_profile" => Ok(EventCategory::TeamProfile),
                    "tfa" => Ok(EventCategory::Tfa),
                    _ => Ok(EventCategory::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["account_capture",
                                                    "administration",
                                                    "apps",
                                                    "authentication",
                                                    "comments",
                                                    "content_access",
                                                    "devices",
                                                    "device_approvals",
                                                    "domains",
                                                    "emm",
                                                    "errors",
                                                    "files",
                                                    "file_operations",
                                                    "file_requests",
                                                    "groups",
                                                    "logins",
                                                    "members",
                                                    "paper",
                                                    "passwords",
                                                    "reports",
                                                    "sessions",
                                                    "shared_files",
                                                    "shared_folders",
                                                    "shared_links",
                                                    "sharing",
                                                    "sharing_policies",
                                                    "sso",
                                                    "team_folders",
                                                    "team_policies",
                                                    "team_profile",
                                                    "tfa",
                                                    "other"];
        deserializer.deserialize_struct("EventCategory", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventCategory {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventCategory::AccountCapture => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "account_capture")?;
                s.end()
            }
            EventCategory::Administration => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "administration")?;
                s.end()
            }
            EventCategory::Apps => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "apps")?;
                s.end()
            }
            EventCategory::Authentication => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "authentication")?;
                s.end()
            }
            EventCategory::Comments => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "comments")?;
                s.end()
            }
            EventCategory::ContentAccess => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "content_access")?;
                s.end()
            }
            EventCategory::Devices => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "devices")?;
                s.end()
            }
            EventCategory::DeviceApprovals => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "device_approvals")?;
                s.end()
            }
            EventCategory::Domains => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "domains")?;
                s.end()
            }
            EventCategory::Emm => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "emm")?;
                s.end()
            }
            EventCategory::Errors => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "errors")?;
                s.end()
            }
            EventCategory::Files => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "files")?;
                s.end()
            }
            EventCategory::FileOperations => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_operations")?;
                s.end()
            }
            EventCategory::FileRequests => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_requests")?;
                s.end()
            }
            EventCategory::Groups => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "groups")?;
                s.end()
            }
            EventCategory::Logins => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "logins")?;
                s.end()
            }
            EventCategory::Members => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            EventCategory::Paper => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "paper")?;
                s.end()
            }
            EventCategory::Passwords => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "passwords")?;
                s.end()
            }
            EventCategory::Reports => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "reports")?;
                s.end()
            }
            EventCategory::Sessions => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sessions")?;
                s.end()
            }
            EventCategory::SharedFiles => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "shared_files")?;
                s.end()
            }
            EventCategory::SharedFolders => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "shared_folders")?;
                s.end()
            }
            EventCategory::SharedLinks => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "shared_links")?;
                s.end()
            }
            EventCategory::Sharing => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sharing")?;
                s.end()
            }
            EventCategory::SharingPolicies => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sharing_policies")?;
                s.end()
            }
            EventCategory::Sso => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sso")?;
                s.end()
            }
            EventCategory::TeamFolders => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_folders")?;
                s.end()
            }
            EventCategory::TeamPolicies => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_policies")?;
                s.end()
            }
            EventCategory::TeamProfile => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_profile")?;
                s.end()
            }
            EventCategory::Tfa => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "tfa")?;
                s.end()
            }
            EventCategory::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional fields depending on the event type.
#[derive(Debug)]
pub enum EventDetails {
    /// Changed the membership type (limited vs full) for team member.
    MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails),
    /// Permanently deleted contents of a removed team member account.
    MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails),
    /// Changed the status with respect to whether the team member is under or over storage quota
    /// specified by policy.
    MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails),
    /// Transferred contents of a removed team member account to another member.
    MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails),
    /// Users added to Paper enabled users list.
    PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails),
    /// Users removed from Paper enabled users list.
    PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails),
    /// Paper external sharing policy changed: anyone.
    PaperExternalViewAllowDetails(PaperExternalViewAllowDetails),
    /// Paper external sharing policy changed: default team.
    PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails),
    /// Paper external sharing policy changed: team-only.
    PaperExternalViewForbidDetails(PaperExternalViewForbidDetails),
    /// Admin settings: team members see a warning before sharing folders outside the team
    /// (DEPRECATED FEATURE).
    SfExternalInviteWarnDetails(SfExternalInviteWarnDetails),
    /// Merged another team into this team.
    TeamMergeFromDetails(TeamMergeFromDetails),
    /// Merged this team into another team.
    TeamMergeToDetails(TeamMergeToDetails),
    /// Linked an app for team.
    AppLinkTeamDetails(AppLinkTeamDetails),
    /// Linked an app for team member.
    AppLinkUserDetails(AppLinkUserDetails),
    /// Unlinked an app for team.
    AppUnlinkTeamDetails(AppUnlinkTeamDetails),
    /// Unlinked an app for team member.
    AppUnlinkUserDetails(AppUnlinkUserDetails),
    /// IP address associated with active desktop session changed.
    DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails),
    /// IP address associated with active mobile session changed.
    DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails),
    /// IP address associated with active Web session changed.
    DeviceChangeIpWebDetails(DeviceChangeIpWebDetails),
    /// Failed to delete all files from an unlinked device.
    DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails),
    /// Deleted all files from an unlinked device.
    DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails),
    /// Failed to link a device.
    DeviceLinkFailDetails(DeviceLinkFailDetails),
    /// Linked a device.
    DeviceLinkSuccessDetails(DeviceLinkSuccessDetails),
    /// Disable Device Management.
    DeviceManagementDisabledDetails(DeviceManagementDisabledDetails),
    /// Enable Device Management.
    DeviceManagementEnabledDetails(DeviceManagementEnabledDetails),
    /// Disconnected a device.
    DeviceUnlinkDetails(DeviceUnlinkDetails),
    /// Refreshed the auth token used for setting up enterprise mobility management.
    EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails),
    /// Granted or revoked the option to enable account capture on domains belonging to the team.
    AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails),
    /// Account captured user migrated their account to the team.
    AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails),
    /// Account captured user relinquished their account by changing the email address associated
    /// with it.
    AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails),
    /// Disabled domain invites.
    DisabledDomainInvitesDetails(DisabledDomainInvitesDetails),
    /// Approved a member's request to join the team.
    DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails),
    /// Declined a user's request to join the team.
    DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails),
    /// Sent domain invites to existing domain accounts.
    DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails),
    /// Asked to join the team.
    DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails),
    /// Turned off u201cAutomatically invite new usersu201d.
    DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails),
    /// Turned on u201cAutomatically invite new usersu201d.
    DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails),
    /// Failed to verify a domain belonging to the team.
    DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails),
    /// Verified a domain belonging to the team.
    DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails),
    /// Removed a domain from the list of verified domains belonging to the team.
    DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails),
    /// Enabled domain invites.
    EnabledDomainInvitesDetails(EnabledDomainInvitesDetails),
    /// Created folders.
    CreateFolderDetails(CreateFolderDetails),
    /// Added files and/or folders.
    FileAddDetails(FileAddDetails),
    /// Copied files and/or folders.
    FileCopyDetails(FileCopyDetails),
    /// Deleted files and/or folders.
    FileDeleteDetails(FileDeleteDetails),
    /// Downloaded files and/or folders.
    FileDownloadDetails(FileDownloadDetails),
    /// Edited files.
    FileEditDetails(FileEditDetails),
    /// Create a copy reference to a file or folder.
    FileGetCopyReferenceDetails(FileGetCopyReferenceDetails),
    /// Moved files and/or folders.
    FileMoveDetails(FileMoveDetails),
    /// Permanently deleted files and/or folders.
    FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails),
    /// Previewed files and/or folders.
    FilePreviewDetails(FilePreviewDetails),
    /// Renamed files and/or folders.
    FileRenameDetails(FileRenameDetails),
    /// Restored deleted files and/or folders.
    FileRestoreDetails(FileRestoreDetails),
    /// Reverted files to a previous version.
    FileRevertDetails(FileRevertDetails),
    /// Rolled back file change location changes.
    FileRollbackChangesDetails(FileRollbackChangesDetails),
    /// Save a file or folder using a copy reference.
    FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails),
    /// Added a deadline to a file request.
    FileRequestAddDeadlineDetails(FileRequestAddDeadlineDetails),
    /// Changed the file request folder.
    FileRequestChangeFolderDetails(FileRequestChangeFolderDetails),
    /// Change the file request title.
    FileRequestChangeTitleDetails(FileRequestChangeTitleDetails),
    /// Closed a file request.
    FileRequestCloseDetails(FileRequestCloseDetails),
    /// Created a file request.
    FileRequestCreateDetails(FileRequestCreateDetails),
    /// Received files for a file request.
    FileRequestReceiveFileDetails(FileRequestReceiveFileDetails),
    /// Removed the file request deadline.
    FileRequestRemoveDeadlineDetails(FileRequestRemoveDeadlineDetails),
    /// Sent file request to users via email.
    FileRequestSendDetails(FileRequestSendDetails),
    /// Added an external ID for group.
    GroupAddExternalIdDetails(GroupAddExternalIdDetails),
    /// Added team members to a group.
    GroupAddMemberDetails(GroupAddMemberDetails),
    /// Changed the external ID for group.
    GroupChangeExternalIdDetails(GroupChangeExternalIdDetails),
    /// Changed group management type.
    GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails),
    /// Changed the manager permissions belonging to a group member.
    GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails),
    /// Created a group.
    GroupCreateDetails(GroupCreateDetails),
    /// Deleted a group.
    GroupDeleteDetails(GroupDeleteDetails),
    /// Updated a group.
    GroupDescriptionUpdatedDetails(GroupDescriptionUpdatedDetails),
    /// Updated a group join policy.
    GroupJoinPolicyUpdatedDetails(GroupJoinPolicyUpdatedDetails),
    /// Moved a group.
    GroupMovedDetails(GroupMovedDetails),
    /// Removed the external ID for group.
    GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails),
    /// Removed team members from a group.
    GroupRemoveMemberDetails(GroupRemoveMemberDetails),
    /// Renamed a group.
    GroupRenameDetails(GroupRenameDetails),
    /// Signed in using the Dropbox EMM app.
    EmmLoginSuccessDetails(EmmLoginSuccessDetails),
    /// Signed out.
    LogoutDetails(LogoutDetails),
    /// Failed to sign in using a password.
    PasswordLoginFailDetails(PasswordLoginFailDetails),
    /// Signed in using a password.
    PasswordLoginSuccessDetails(PasswordLoginSuccessDetails),
    /// Ended reseller support session.
    ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails),
    /// Started reseller support session.
    ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails),
    /// Ended admin sign-in-as session.
    SignInAsSessionEndDetails(SignInAsSessionEndDetails),
    /// Started admin sign-in-as session.
    SignInAsSessionStartDetails(SignInAsSessionStartDetails),
    /// Failed to sign in using SSO.
    SsoLoginFailDetails(SsoLoginFailDetails),
    /// Set team member name when joining team.
    MemberAddNameDetails(MemberAddNameDetails),
    /// Change the admin role belonging to team member.
    MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails),
    /// Changed team member email address.
    MemberChangeEmailDetails(MemberChangeEmailDetails),
    /// Changed team member name.
    MemberChangeNameDetails(MemberChangeNameDetails),
    /// Changed the membership status of a team member.
    MemberChangeStatusDetails(MemberChangeStatusDetails),
    /// Suggested a new team member to be added to the team.
    MemberSuggestDetails(MemberSuggestDetails),
    /// Added users to the membership of a Paper doc or folder.
    PaperContentAddMemberDetails(PaperContentAddMemberDetails),
    /// Added Paper doc or folder to a folder.
    PaperContentAddToFolderDetails(PaperContentAddToFolderDetails),
    /// Archived Paper doc or folder.
    PaperContentArchiveDetails(PaperContentArchiveDetails),
    /// Followed or unfollowed a Paper doc or folder.
    PaperContentChangeSubscriptionDetails(PaperContentChangeSubscriptionDetails),
    /// Created a Paper doc or folder.
    PaperContentCreateDetails(PaperContentCreateDetails),
    /// Permanently deleted a Paper doc or folder.
    PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails),
    /// Removed Paper doc or folder from a folder.
    PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails),
    /// Removed a user from the membership of a Paper doc or folder.
    PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails),
    /// Renamed Paper doc or folder.
    PaperContentRenameDetails(PaperContentRenameDetails),
    /// Restored an archived Paper doc or folder.
    PaperContentRestoreDetails(PaperContentRestoreDetails),
    /// Added a Paper doc comment.
    PaperDocAddCommentDetails(PaperDocAddCommentDetails),
    /// Changed the access type of a Paper doc member.
    PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails),
    /// Changed the sharing policy for Paper doc.
    PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails),
    /// Paper doc archived.
    PaperDocDeletedDetails(PaperDocDeletedDetails),
    /// Deleted a Paper doc comment.
    PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails),
    /// Downloaded a Paper doc in a particular output format.
    PaperDocDownloadDetails(PaperDocDownloadDetails),
    /// Edited a Paper doc.
    PaperDocEditDetails(PaperDocEditDetails),
    /// Edited a Paper doc comment.
    PaperDocEditCommentDetails(PaperDocEditCommentDetails),
    /// Followed a Paper doc.
    PaperDocFollowedDetails(PaperDocFollowedDetails),
    /// Mentioned a member in a Paper doc.
    PaperDocMentionDetails(PaperDocMentionDetails),
    /// Requested to be a member on a Paper doc.
    PaperDocRequestAccessDetails(PaperDocRequestAccessDetails),
    /// Paper doc comment resolved.
    PaperDocResolveCommentDetails(PaperDocResolveCommentDetails),
    /// Restored a Paper doc to previous revision.
    PaperDocRevertDetails(PaperDocRevertDetails),
    /// Paper doc link shared via slack.
    PaperDocSlackShareDetails(PaperDocSlackShareDetails),
    /// Paper doc shared with team member.
    PaperDocTeamInviteDetails(PaperDocTeamInviteDetails),
    /// Unresolved a Paper doc comment.
    PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails),
    /// Viewed Paper doc.
    PaperDocViewDetails(PaperDocViewDetails),
    /// Paper folder archived.
    PaperFolderDeletedDetails(PaperFolderDeletedDetails),
    /// Followed a Paper folder.
    PaperFolderFollowedDetails(PaperFolderFollowedDetails),
    /// Paper folder shared with team member.
    PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails),
    /// Changed password.
    PasswordChangeDetails(PasswordChangeDetails),
    /// Reset password.
    PasswordResetDetails(PasswordResetDetails),
    /// Reset all team member passwords.
    PasswordResetAllDetails(PasswordResetAllDetails),
    /// EMM excluded users report created.
    EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails),
    /// EMM mobile app usage report created.
    EmmCreateUsageReportDetails(EmmCreateUsageReportDetails),
    /// Smart Sync non-admin devices report created.
    SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails),
    /// Created a team activity report.
    TeamActivityCreateReportDetails(TeamActivityCreateReportDetails),
    /// Shared an album.
    CollectionShareDetails(CollectionShareDetails),
    /// Added a file comment.
    FileAddCommentDetails(FileAddCommentDetails),
    /// Liked a file comment.
    FileLikeCommentDetails(FileLikeCommentDetails),
    /// Unliked a file comment.
    FileUnlikeCommentDetails(FileUnlikeCommentDetails),
    /// Changed a Paper document to be invite-only.
    NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails),
    /// Changed a Paper document to be link accessible.
    NoteAclLinkDetails(NoteAclLinkDetails),
    /// Changed a Paper document to be link accessible for the team.
    NoteAclTeamLinkDetails(NoteAclTeamLinkDetails),
    /// Shared a Paper doc.
    NoteSharedDetails(NoteSharedDetails),
    /// Shared Paper document received.
    NoteShareReceiveDetails(NoteShareReceiveDetails),
    /// Opened a shared Paper doc.
    OpenNoteSharedDetails(OpenNoteSharedDetails),
    /// Added the team to a shared folder.
    SfAddGroupDetails(SfAddGroupDetails),
    /// Allowed non collaborators to view links to files in a shared folder.
    SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails),
    /// Invited a group to a shared folder.
    SfInviteGroupDetails(SfInviteGroupDetails),
    /// Changed parent of shared folder.
    SfNestDetails(SfNestDetails),
    /// Declined a team member's invitation to a shared folder.
    SfTeamDeclineDetails(SfTeamDeclineDetails),
    /// Granted access to a shared folder.
    SfTeamGrantAccessDetails(SfTeamGrantAccessDetails),
    /// Invited team members to a shared folder.
    SfTeamInviteDetails(SfTeamInviteDetails),
    /// Changed a team member's role in a shared folder.
    SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails),
    /// Joined a team member's shared folder.
    SfTeamJoinDetails(SfTeamJoinDetails),
    /// Joined a team member's shared folder from a link.
    SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails),
    /// Unshared a folder with a team member.
    SfTeamUninviteDetails(SfTeamUninviteDetails),
    /// Sent an email invitation to the membership of a shared file or folder.
    SharedContentAddInviteesDetails(SharedContentAddInviteesDetails),
    /// Added an expiry to the link for the shared file or folder.
    SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails),
    /// Added a password to the link for the shared file or folder.
    SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails),
    /// Added users and/or groups to the membership of a shared file or folder.
    SharedContentAddMemberDetails(SharedContentAddMemberDetails),
    /// Changed whether members can download the shared file or folder.
    SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails),
    /// Changed the access type of an invitee to a shared file or folder before the invitation was
    /// claimed.
    SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails),
    /// Changed the audience of the link for a shared file or folder.
    SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails),
    /// Changed the expiry of the link for the shared file or folder.
    SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails),
    /// Changed the password on the link for the shared file or folder.
    SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails),
    /// Changed the access type of a shared file or folder member.
    SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails),
    /// Changed whether members can see who viewed the shared file or folder.
    SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails),
    /// Claimed membership to a team member's shared folder.
    SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails),
    /// Copied the shared file or folder to own Dropbox.
    SharedContentCopyDetails(SharedContentCopyDetails),
    /// Downloaded the shared file or folder.
    SharedContentDownloadDetails(SharedContentDownloadDetails),
    /// Left the membership of a shared file or folder.
    SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails),
    /// Removed an invitee from the membership of a shared file or folder before it was claimed.
    SharedContentRemoveInviteeDetails(SharedContentRemoveInviteeDetails),
    /// Removed the expiry of the link for the shared file or folder.
    SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails),
    /// Removed the password on the link for the shared file or folder.
    SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails),
    /// Removed a user or a group from the membership of a shared file or folder.
    SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails),
    /// Requested to be on the membership of a shared file or folder.
    SharedContentRequestAccessDetails(SharedContentRequestAccessDetails),
    /// Unshared a shared file or folder by clearing its membership and turning off its link.
    SharedContentUnshareDetails(SharedContentUnshareDetails),
    /// Previewed the shared file or folder.
    SharedContentViewDetails(SharedContentViewDetails),
    /// Set or unset the confidential flag on a shared folder.
    SharedFolderChangeConfidentialityDetails(SharedFolderChangeConfidentialityDetails),
    /// Changed who can access the shared folder via a link.
    SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails),
    /// Changed who can manage the membership of a shared folder.
    SharedFolderChangeMemberManagementPolicyDetails(SharedFolderChangeMemberManagementPolicyDetails),
    /// Changed who can become a member of the shared folder.
    SharedFolderChangeMemberPolicyDetails(SharedFolderChangeMemberPolicyDetails),
    /// Created a shared folder.
    SharedFolderCreateDetails(SharedFolderCreateDetails),
    /// Added a shared folder to own Dropbox.
    SharedFolderMountDetails(SharedFolderMountDetails),
    /// Transferred the ownership of a shared folder to another member.
    SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails),
    /// Deleted a shared folder from Dropbox.
    SharedFolderUnmountDetails(SharedFolderUnmountDetails),
    /// Shared Paper document was opened.
    SharedNoteOpenedDetails(SharedNoteOpenedDetails),
    /// Created a link to a file using an app.
    ShmodelAppCreateDetails(ShmodelAppCreateDetails),
    /// Created a new link.
    ShmodelCreateDetails(ShmodelCreateDetails),
    /// Removed a link.
    ShmodelDisableDetails(ShmodelDisableDetails),
    /// Shared a link with Facebook users.
    ShmodelFbShareDetails(ShmodelFbShareDetails),
    /// Shared a link with a group.
    ShmodelGroupShareDetails(ShmodelGroupShareDetails),
    /// Removed the expiration date from a link.
    ShmodelRemoveExpirationDetails(ShmodelRemoveExpirationDetails),
    /// Added an expiration date to a link.
    ShmodelSetExpirationDetails(ShmodelSetExpirationDetails),
    /// Added a team member's file/folder to their Dropbox from a link.
    ShmodelTeamCopyDetails(ShmodelTeamCopyDetails),
    /// Downloaded a team member's file/folder from a link.
    ShmodelTeamDownloadDetails(ShmodelTeamDownloadDetails),
    /// Shared a link with team members.
    ShmodelTeamShareDetails(ShmodelTeamShareDetails),
    /// Opened a team member's link.
    ShmodelTeamViewDetails(ShmodelTeamViewDetails),
    /// Password-protected a link.
    ShmodelVisibilityPasswordDetails(ShmodelVisibilityPasswordDetails),
    /// Made a file/folder visible to anyone with the link.
    ShmodelVisibilityPublicDetails(ShmodelVisibilityPublicDetails),
    /// Made a file/folder visible only to team members with the link.
    ShmodelVisibilityTeamOnlyDetails(ShmodelVisibilityTeamOnlyDetails),
    /// Removed single sign-on logout URL.
    RemoveLogoutUrlDetails(RemoveLogoutUrlDetails),
    /// Changed the sign-out URL for SSO.
    RemoveSsoUrlDetails(RemoveSsoUrlDetails),
    /// Changed the X.509 certificate for SSO.
    SsoChangeCertDetails(SsoChangeCertDetails),
    /// Changed the sign-in URL for SSO.
    SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails),
    /// Changed the sign-out URL for SSO.
    SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails),
    /// Changed the SAML identity mode for SSO.
    SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails),
    /// Changed the archival status of a team folder.
    TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails),
    /// Created a new team folder in active status.
    TeamFolderCreateDetails(TeamFolderCreateDetails),
    /// Downgraded a team folder to a regular shared folder.
    TeamFolderDowngradeDetails(TeamFolderDowngradeDetails),
    /// Permanently deleted an archived team folder.
    TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails),
    /// Renamed an active or archived team folder.
    TeamFolderRenameDetails(TeamFolderRenameDetails),
    /// Changed the account capture policy on a domain belonging to the team.
    AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails),
    /// Disabled allow downloads.
    AllowDownloadDisabledDetails(AllowDownloadDisabledDetails),
    /// Enabled allow downloads.
    AllowDownloadEnabledDetails(AllowDownloadEnabledDetails),
    /// Set a restriction policy regarding the location of data centers where team data resides.
    DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails),
    /// Satisfied a previously set restriction policy regarding the location of data centers where
    /// team data resides (i.e. all data have been migrated according to the restriction placed).
    DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails),
    /// Set or removed a limit on the number of computers each team member can link to their work
    /// Dropbox account.
    DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails),
    /// Set or removed a limit on the number of mobiles devices each team member can link to their
    /// work Dropbox account.
    DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails),
    /// Changed the action taken when a team member is already over the limits (e.g when they join
    /// the team, an admin lowers limits, etc.).
    DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails),
    /// Changed the action taken with respect to approval limits when a team member unlinks an
    /// approved device.
    DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails),
    /// Added an exception for one or more team members to optionally use the regular Dropbox app
    /// when EMM is enabled.
    EmmAddExceptionDetails(EmmAddExceptionDetails),
    /// Enabled or disabled enterprise mobility management for team members.
    EmmChangePolicyDetails(EmmChangePolicyDetails),
    /// Removed an exception for one or more team members to optionally use the regular Dropbox app
    /// when EMM is enabled.
    EmmRemoveExceptionDetails(EmmRemoveExceptionDetails),
    /// Accepted or opted out of extended version history.
    ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails),
    /// Enabled or disabled commenting on team files.
    FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails),
    /// Enabled or disabled file requests.
    FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails),
    /// Enabled file request emails for everyone.
    FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails),
    /// Allowed file request emails for the team.
    FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails),
    /// Enabled or disabled Google single sign-on for the team.
    GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails),
    /// Changed who can create groups.
    GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails),
    /// Changed whether users can find the team when not invited.
    MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails),
    /// Added an exception for one or more team members to bypass space limits imposed by policy.
    MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails),
    /// Changed the storage limits applied to team members by policy.
    MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails),
    /// Removed an exception for one or more team members to bypass space limits imposed by policy.
    MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails),
    /// Enabled or disabled the option for team members to suggest new members to add to the team.
    MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails),
    /// Enabled or disabled the Microsoft Office add-in, which lets team members save files to
    /// Dropbox directly from Microsoft Office.
    MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails),
    /// Enabled or disabled network control.
    NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails),
    /// Changed whether Dropbox Paper, when enabled, is deployed to all teams or to specific members
    /// of the team.
    PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails),
    /// Changed whether team members can share Paper documents externally (i.e. outside the team),
    /// and if so, whether they should be accessible only by team members or anyone by default.
    PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails),
    /// Enabled or disabled Dropbox Paper for the team.
    PaperChangePolicyDetails(PaperChangePolicyDetails),
    /// Enabled or disabled the ability of team members to permanently delete content.
    PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails),
    /// Changed whether team members can join shared folders owned externally (i.e. outside the
    /// team).
    SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails),
    /// Changed whether team members can share links externally (i.e. outside the team), and if so,
    /// whether links should be accessible only by team members or anyone by default.
    SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails),
    /// Changed whether team members can share files and folders externally (i.e. outside the team).
    SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails),
    /// Changed the default Smart Sync policy for team members.
    SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails),
    /// Opted team into Smart Sync.
    SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails),
    /// Opted team out of Smart Sync.
    SmartSyncOptOutDetails(SmartSyncOptOutDetails),
    /// Change the single sign-on policy for the team.
    SsoChangePolicyDetails(SsoChangePolicyDetails),
    /// Change two-step verification policy for the team.
    TfaChangePolicyDetails(TfaChangePolicyDetails),
    /// Enabled or disabled the option for team members to link a personal Dropbox account in
    /// addition to their work account to the same computer.
    TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails),
    /// Changed how long team members can stay signed in to Dropbox on the web.
    WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails),
    /// Changed how long team members can be idle while signed in to Dropbox on the web.
    WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails),
    /// Added a team logo to be displayed on shared link headers.
    TeamProfileAddLogoDetails(TeamProfileAddLogoDetails),
    /// Changed the team logo to be displayed on shared link headers.
    TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails),
    /// Changed the team name.
    TeamProfileChangeNameDetails(TeamProfileChangeNameDetails),
    /// Removed the team logo to be displayed on shared link headers.
    TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails),
    /// Added a backup phone for two-step verification.
    TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails),
    /// Added a security key for two-step verification.
    TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails),
    /// Changed the backup phone for two-step verification.
    TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails),
    /// Enabled, disabled or changed the configuration for two-step verification.
    TfaChangeStatusDetails(TfaChangeStatusDetails),
    /// Removed the backup phone for two-step verification.
    TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails),
    /// Removed a security key for two-step verification.
    TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails),
    /// Reset two-step verification for team member.
    TfaResetDetails(TfaResetDetails),
    /// Hints that this event was returned with missing details due to an internal error.
    MissingDetails(MissingDetails),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "member_change_membership_type_details" => Ok(EventDetails::MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails::internal_deserialize(map)?)),
                    "member_permanently_delete_account_contents_details" => Ok(EventDetails::MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_status_details" => Ok(EventDetails::MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)?)),
                    "member_transfer_account_contents_details" => Ok(EventDetails::MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_addition_details" => Ok(EventDetails::PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_removal_details" => Ok(EventDetails::PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)?)),
                    "paper_external_view_allow_details" => Ok(EventDetails::PaperExternalViewAllowDetails(PaperExternalViewAllowDetails::internal_deserialize(map)?)),
                    "paper_external_view_default_team_details" => Ok(EventDetails::PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails::internal_deserialize(map)?)),
                    "paper_external_view_forbid_details" => Ok(EventDetails::PaperExternalViewForbidDetails(PaperExternalViewForbidDetails::internal_deserialize(map)?)),
                    "sf_external_invite_warn_details" => Ok(EventDetails::SfExternalInviteWarnDetails(SfExternalInviteWarnDetails::internal_deserialize(map)?)),
                    "team_merge_from_details" => Ok(EventDetails::TeamMergeFromDetails(TeamMergeFromDetails::internal_deserialize(map)?)),
                    "team_merge_to_details" => Ok(EventDetails::TeamMergeToDetails(TeamMergeToDetails::internal_deserialize(map)?)),
                    "app_link_team_details" => Ok(EventDetails::AppLinkTeamDetails(AppLinkTeamDetails::internal_deserialize(map)?)),
                    "app_link_user_details" => Ok(EventDetails::AppLinkUserDetails(AppLinkUserDetails::internal_deserialize(map)?)),
                    "app_unlink_team_details" => Ok(EventDetails::AppUnlinkTeamDetails(AppUnlinkTeamDetails::internal_deserialize(map)?)),
                    "app_unlink_user_details" => Ok(EventDetails::AppUnlinkUserDetails(AppUnlinkUserDetails::internal_deserialize(map)?)),
                    "device_change_ip_desktop_details" => Ok(EventDetails::DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails::internal_deserialize(map)?)),
                    "device_change_ip_mobile_details" => Ok(EventDetails::DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails::internal_deserialize(map)?)),
                    "device_change_ip_web_details" => Ok(EventDetails::DeviceChangeIpWebDetails(DeviceChangeIpWebDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_fail_details" => Ok(EventDetails::DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_success_details" => Ok(EventDetails::DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)?)),
                    "device_link_fail_details" => Ok(EventDetails::DeviceLinkFailDetails(DeviceLinkFailDetails::internal_deserialize(map)?)),
                    "device_link_success_details" => Ok(EventDetails::DeviceLinkSuccessDetails(DeviceLinkSuccessDetails::internal_deserialize(map)?)),
                    "device_management_disabled_details" => Ok(EventDetails::DeviceManagementDisabledDetails(DeviceManagementDisabledDetails::internal_deserialize(map)?)),
                    "device_management_enabled_details" => Ok(EventDetails::DeviceManagementEnabledDetails(DeviceManagementEnabledDetails::internal_deserialize(map)?)),
                    "device_unlink_details" => Ok(EventDetails::DeviceUnlinkDetails(DeviceUnlinkDetails::internal_deserialize(map)?)),
                    "emm_refresh_auth_token_details" => Ok(EventDetails::EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails::internal_deserialize(map)?)),
                    "account_capture_change_availability_details" => Ok(EventDetails::AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)?)),
                    "account_capture_migrate_account_details" => Ok(EventDetails::AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails::internal_deserialize(map)?)),
                    "account_capture_relinquish_account_details" => Ok(EventDetails::AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails::internal_deserialize(map)?)),
                    "disabled_domain_invites_details" => Ok(EventDetails::DisabledDomainInvitesDetails(DisabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "domain_invites_approve_request_to_join_team_details" => Ok(EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_decline_request_to_join_team_details" => Ok(EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_email_existing_users_details" => Ok(EventDetails::DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)?)),
                    "domain_invites_request_to_join_team_details" => Ok(EventDetails::DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_no_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_yes_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_fail_details" => Ok(EventDetails::DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_success_details" => Ok(EventDetails::DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)?)),
                    "domain_verification_remove_domain_details" => Ok(EventDetails::DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails::internal_deserialize(map)?)),
                    "enabled_domain_invites_details" => Ok(EventDetails::EnabledDomainInvitesDetails(EnabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "create_folder_details" => Ok(EventDetails::CreateFolderDetails(CreateFolderDetails::internal_deserialize(map)?)),
                    "file_add_details" => Ok(EventDetails::FileAddDetails(FileAddDetails::internal_deserialize(map)?)),
                    "file_copy_details" => Ok(EventDetails::FileCopyDetails(FileCopyDetails::internal_deserialize(map)?)),
                    "file_delete_details" => Ok(EventDetails::FileDeleteDetails(FileDeleteDetails::internal_deserialize(map)?)),
                    "file_download_details" => Ok(EventDetails::FileDownloadDetails(FileDownloadDetails::internal_deserialize(map)?)),
                    "file_edit_details" => Ok(EventDetails::FileEditDetails(FileEditDetails::internal_deserialize(map)?)),
                    "file_get_copy_reference_details" => Ok(EventDetails::FileGetCopyReferenceDetails(FileGetCopyReferenceDetails::internal_deserialize(map)?)),
                    "file_move_details" => Ok(EventDetails::FileMoveDetails(FileMoveDetails::internal_deserialize(map)?)),
                    "file_permanently_delete_details" => Ok(EventDetails::FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "file_preview_details" => Ok(EventDetails::FilePreviewDetails(FilePreviewDetails::internal_deserialize(map)?)),
                    "file_rename_details" => Ok(EventDetails::FileRenameDetails(FileRenameDetails::internal_deserialize(map)?)),
                    "file_restore_details" => Ok(EventDetails::FileRestoreDetails(FileRestoreDetails::internal_deserialize(map)?)),
                    "file_revert_details" => Ok(EventDetails::FileRevertDetails(FileRevertDetails::internal_deserialize(map)?)),
                    "file_rollback_changes_details" => Ok(EventDetails::FileRollbackChangesDetails(FileRollbackChangesDetails::internal_deserialize(map)?)),
                    "file_save_copy_reference_details" => Ok(EventDetails::FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails::internal_deserialize(map)?)),
                    "file_request_add_deadline_details" => Ok(EventDetails::FileRequestAddDeadlineDetails(FileRequestAddDeadlineDetails::internal_deserialize(map)?)),
                    "file_request_change_folder_details" => Ok(EventDetails::FileRequestChangeFolderDetails(FileRequestChangeFolderDetails::internal_deserialize(map)?)),
                    "file_request_change_title_details" => Ok(EventDetails::FileRequestChangeTitleDetails(FileRequestChangeTitleDetails::internal_deserialize(map)?)),
                    "file_request_close_details" => Ok(EventDetails::FileRequestCloseDetails(FileRequestCloseDetails::internal_deserialize(map)?)),
                    "file_request_create_details" => Ok(EventDetails::FileRequestCreateDetails(FileRequestCreateDetails::internal_deserialize(map)?)),
                    "file_request_receive_file_details" => Ok(EventDetails::FileRequestReceiveFileDetails(FileRequestReceiveFileDetails::internal_deserialize(map)?)),
                    "file_request_remove_deadline_details" => Ok(EventDetails::FileRequestRemoveDeadlineDetails(FileRequestRemoveDeadlineDetails::internal_deserialize(map)?)),
                    "file_request_send_details" => Ok(EventDetails::FileRequestSendDetails(FileRequestSendDetails::internal_deserialize(map)?)),
                    "group_add_external_id_details" => Ok(EventDetails::GroupAddExternalIdDetails(GroupAddExternalIdDetails::internal_deserialize(map)?)),
                    "group_add_member_details" => Ok(EventDetails::GroupAddMemberDetails(GroupAddMemberDetails::internal_deserialize(map)?)),
                    "group_change_external_id_details" => Ok(EventDetails::GroupChangeExternalIdDetails(GroupChangeExternalIdDetails::internal_deserialize(map)?)),
                    "group_change_management_type_details" => Ok(EventDetails::GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails::internal_deserialize(map)?)),
                    "group_change_member_role_details" => Ok(EventDetails::GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "group_create_details" => Ok(EventDetails::GroupCreateDetails(GroupCreateDetails::internal_deserialize(map)?)),
                    "group_delete_details" => Ok(EventDetails::GroupDeleteDetails(GroupDeleteDetails::internal_deserialize(map)?)),
                    "group_description_updated_details" => Ok(EventDetails::GroupDescriptionUpdatedDetails(GroupDescriptionUpdatedDetails::internal_deserialize(map)?)),
                    "group_join_policy_updated_details" => Ok(EventDetails::GroupJoinPolicyUpdatedDetails(GroupJoinPolicyUpdatedDetails::internal_deserialize(map)?)),
                    "group_moved_details" => Ok(EventDetails::GroupMovedDetails(GroupMovedDetails::internal_deserialize(map)?)),
                    "group_remove_external_id_details" => Ok(EventDetails::GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails::internal_deserialize(map)?)),
                    "group_remove_member_details" => Ok(EventDetails::GroupRemoveMemberDetails(GroupRemoveMemberDetails::internal_deserialize(map)?)),
                    "group_rename_details" => Ok(EventDetails::GroupRenameDetails(GroupRenameDetails::internal_deserialize(map)?)),
                    "emm_login_success_details" => Ok(EventDetails::EmmLoginSuccessDetails(EmmLoginSuccessDetails::internal_deserialize(map)?)),
                    "logout_details" => Ok(EventDetails::LogoutDetails(LogoutDetails::internal_deserialize(map)?)),
                    "password_login_fail_details" => Ok(EventDetails::PasswordLoginFailDetails(PasswordLoginFailDetails::internal_deserialize(map)?)),
                    "password_login_success_details" => Ok(EventDetails::PasswordLoginSuccessDetails(PasswordLoginSuccessDetails::internal_deserialize(map)?)),
                    "reseller_support_session_end_details" => Ok(EventDetails::ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails::internal_deserialize(map)?)),
                    "reseller_support_session_start_details" => Ok(EventDetails::ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_end_details" => Ok(EventDetails::SignInAsSessionEndDetails(SignInAsSessionEndDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_start_details" => Ok(EventDetails::SignInAsSessionStartDetails(SignInAsSessionStartDetails::internal_deserialize(map)?)),
                    "sso_login_fail_details" => Ok(EventDetails::SsoLoginFailDetails(SsoLoginFailDetails::internal_deserialize(map)?)),
                    "member_add_name_details" => Ok(EventDetails::MemberAddNameDetails(MemberAddNameDetails::internal_deserialize(map)?)),
                    "member_change_admin_role_details" => Ok(EventDetails::MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails::internal_deserialize(map)?)),
                    "member_change_email_details" => Ok(EventDetails::MemberChangeEmailDetails(MemberChangeEmailDetails::internal_deserialize(map)?)),
                    "member_change_name_details" => Ok(EventDetails::MemberChangeNameDetails(MemberChangeNameDetails::internal_deserialize(map)?)),
                    "member_change_status_details" => Ok(EventDetails::MemberChangeStatusDetails(MemberChangeStatusDetails::internal_deserialize(map)?)),
                    "member_suggest_details" => Ok(EventDetails::MemberSuggestDetails(MemberSuggestDetails::internal_deserialize(map)?)),
                    "paper_content_add_member_details" => Ok(EventDetails::PaperContentAddMemberDetails(PaperContentAddMemberDetails::internal_deserialize(map)?)),
                    "paper_content_add_to_folder_details" => Ok(EventDetails::PaperContentAddToFolderDetails(PaperContentAddToFolderDetails::internal_deserialize(map)?)),
                    "paper_content_archive_details" => Ok(EventDetails::PaperContentArchiveDetails(PaperContentArchiveDetails::internal_deserialize(map)?)),
                    "paper_content_change_subscription_details" => Ok(EventDetails::PaperContentChangeSubscriptionDetails(PaperContentChangeSubscriptionDetails::internal_deserialize(map)?)),
                    "paper_content_create_details" => Ok(EventDetails::PaperContentCreateDetails(PaperContentCreateDetails::internal_deserialize(map)?)),
                    "paper_content_permanently_delete_details" => Ok(EventDetails::PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "paper_content_remove_from_folder_details" => Ok(EventDetails::PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails::internal_deserialize(map)?)),
                    "paper_content_remove_member_details" => Ok(EventDetails::PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "paper_content_rename_details" => Ok(EventDetails::PaperContentRenameDetails(PaperContentRenameDetails::internal_deserialize(map)?)),
                    "paper_content_restore_details" => Ok(EventDetails::PaperContentRestoreDetails(PaperContentRestoreDetails::internal_deserialize(map)?)),
                    "paper_doc_add_comment_details" => Ok(EventDetails::PaperDocAddCommentDetails(PaperDocAddCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_change_member_role_details" => Ok(EventDetails::PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "paper_doc_change_sharing_policy_details" => Ok(EventDetails::PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails::internal_deserialize(map)?)),
                    "paper_doc_deleted_details" => Ok(EventDetails::PaperDocDeletedDetails(PaperDocDeletedDetails::internal_deserialize(map)?)),
                    "paper_doc_delete_comment_details" => Ok(EventDetails::PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_download_details" => Ok(EventDetails::PaperDocDownloadDetails(PaperDocDownloadDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_details" => Ok(EventDetails::PaperDocEditDetails(PaperDocEditDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_comment_details" => Ok(EventDetails::PaperDocEditCommentDetails(PaperDocEditCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_followed_details" => Ok(EventDetails::PaperDocFollowedDetails(PaperDocFollowedDetails::internal_deserialize(map)?)),
                    "paper_doc_mention_details" => Ok(EventDetails::PaperDocMentionDetails(PaperDocMentionDetails::internal_deserialize(map)?)),
                    "paper_doc_request_access_details" => Ok(EventDetails::PaperDocRequestAccessDetails(PaperDocRequestAccessDetails::internal_deserialize(map)?)),
                    "paper_doc_resolve_comment_details" => Ok(EventDetails::PaperDocResolveCommentDetails(PaperDocResolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_revert_details" => Ok(EventDetails::PaperDocRevertDetails(PaperDocRevertDetails::internal_deserialize(map)?)),
                    "paper_doc_slack_share_details" => Ok(EventDetails::PaperDocSlackShareDetails(PaperDocSlackShareDetails::internal_deserialize(map)?)),
                    "paper_doc_team_invite_details" => Ok(EventDetails::PaperDocTeamInviteDetails(PaperDocTeamInviteDetails::internal_deserialize(map)?)),
                    "paper_doc_unresolve_comment_details" => Ok(EventDetails::PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_view_details" => Ok(EventDetails::PaperDocViewDetails(PaperDocViewDetails::internal_deserialize(map)?)),
                    "paper_folder_deleted_details" => Ok(EventDetails::PaperFolderDeletedDetails(PaperFolderDeletedDetails::internal_deserialize(map)?)),
                    "paper_folder_followed_details" => Ok(EventDetails::PaperFolderFollowedDetails(PaperFolderFollowedDetails::internal_deserialize(map)?)),
                    "paper_folder_team_invite_details" => Ok(EventDetails::PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails::internal_deserialize(map)?)),
                    "password_change_details" => Ok(EventDetails::PasswordChangeDetails(PasswordChangeDetails::internal_deserialize(map)?)),
                    "password_reset_details" => Ok(EventDetails::PasswordResetDetails(PasswordResetDetails::internal_deserialize(map)?)),
                    "password_reset_all_details" => Ok(EventDetails::PasswordResetAllDetails(PasswordResetAllDetails::internal_deserialize(map)?)),
                    "emm_create_exceptions_report_details" => Ok(EventDetails::EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails::internal_deserialize(map)?)),
                    "emm_create_usage_report_details" => Ok(EventDetails::EmmCreateUsageReportDetails(EmmCreateUsageReportDetails::internal_deserialize(map)?)),
                    "smart_sync_create_admin_privilege_report_details" => Ok(EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)?)),
                    "team_activity_create_report_details" => Ok(EventDetails::TeamActivityCreateReportDetails(TeamActivityCreateReportDetails::internal_deserialize(map)?)),
                    "collection_share_details" => Ok(EventDetails::CollectionShareDetails(CollectionShareDetails::internal_deserialize(map)?)),
                    "file_add_comment_details" => Ok(EventDetails::FileAddCommentDetails(FileAddCommentDetails::internal_deserialize(map)?)),
                    "file_like_comment_details" => Ok(EventDetails::FileLikeCommentDetails(FileLikeCommentDetails::internal_deserialize(map)?)),
                    "file_unlike_comment_details" => Ok(EventDetails::FileUnlikeCommentDetails(FileUnlikeCommentDetails::internal_deserialize(map)?)),
                    "note_acl_invite_only_details" => Ok(EventDetails::NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails::internal_deserialize(map)?)),
                    "note_acl_link_details" => Ok(EventDetails::NoteAclLinkDetails(NoteAclLinkDetails::internal_deserialize(map)?)),
                    "note_acl_team_link_details" => Ok(EventDetails::NoteAclTeamLinkDetails(NoteAclTeamLinkDetails::internal_deserialize(map)?)),
                    "note_shared_details" => Ok(EventDetails::NoteSharedDetails(NoteSharedDetails::internal_deserialize(map)?)),
                    "note_share_receive_details" => Ok(EventDetails::NoteShareReceiveDetails(NoteShareReceiveDetails::internal_deserialize(map)?)),
                    "open_note_shared_details" => Ok(EventDetails::OpenNoteSharedDetails(OpenNoteSharedDetails::internal_deserialize(map)?)),
                    "sf_add_group_details" => Ok(EventDetails::SfAddGroupDetails(SfAddGroupDetails::internal_deserialize(map)?)),
                    "sf_allow_non_members_to_view_shared_links_details" => Ok(EventDetails::SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)?)),
                    "sf_invite_group_details" => Ok(EventDetails::SfInviteGroupDetails(SfInviteGroupDetails::internal_deserialize(map)?)),
                    "sf_nest_details" => Ok(EventDetails::SfNestDetails(SfNestDetails::internal_deserialize(map)?)),
                    "sf_team_decline_details" => Ok(EventDetails::SfTeamDeclineDetails(SfTeamDeclineDetails::internal_deserialize(map)?)),
                    "sf_team_grant_access_details" => Ok(EventDetails::SfTeamGrantAccessDetails(SfTeamGrantAccessDetails::internal_deserialize(map)?)),
                    "sf_team_invite_details" => Ok(EventDetails::SfTeamInviteDetails(SfTeamInviteDetails::internal_deserialize(map)?)),
                    "sf_team_invite_change_role_details" => Ok(EventDetails::SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails::internal_deserialize(map)?)),
                    "sf_team_join_details" => Ok(EventDetails::SfTeamJoinDetails(SfTeamJoinDetails::internal_deserialize(map)?)),
                    "sf_team_join_from_oob_link_details" => Ok(EventDetails::SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails::internal_deserialize(map)?)),
                    "sf_team_uninvite_details" => Ok(EventDetails::SfTeamUninviteDetails(SfTeamUninviteDetails::internal_deserialize(map)?)),
                    "shared_content_add_invitees_details" => Ok(EventDetails::SharedContentAddInviteesDetails(SharedContentAddInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_expiry_details" => Ok(EventDetails::SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_password_details" => Ok(EventDetails::SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_add_member_details" => Ok(EventDetails::SharedContentAddMemberDetails(SharedContentAddMemberDetails::internal_deserialize(map)?)),
                    "shared_content_change_downloads_policy_details" => Ok(EventDetails::SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_change_invitee_role_details" => Ok(EventDetails::SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_audience_details" => Ok(EventDetails::SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_expiry_details" => Ok(EventDetails::SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_password_details" => Ok(EventDetails::SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_change_member_role_details" => Ok(EventDetails::SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_viewer_info_policy_details" => Ok(EventDetails::SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_claim_invitation_details" => Ok(EventDetails::SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails::internal_deserialize(map)?)),
                    "shared_content_copy_details" => Ok(EventDetails::SharedContentCopyDetails(SharedContentCopyDetails::internal_deserialize(map)?)),
                    "shared_content_download_details" => Ok(EventDetails::SharedContentDownloadDetails(SharedContentDownloadDetails::internal_deserialize(map)?)),
                    "shared_content_relinquish_membership_details" => Ok(EventDetails::SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails::internal_deserialize(map)?)),
                    "shared_content_remove_invitee_details" => Ok(EventDetails::SharedContentRemoveInviteeDetails(SharedContentRemoveInviteeDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_expiry_details" => Ok(EventDetails::SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_password_details" => Ok(EventDetails::SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_remove_member_details" => Ok(EventDetails::SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "shared_content_request_access_details" => Ok(EventDetails::SharedContentRequestAccessDetails(SharedContentRequestAccessDetails::internal_deserialize(map)?)),
                    "shared_content_unshare_details" => Ok(EventDetails::SharedContentUnshareDetails(SharedContentUnshareDetails::internal_deserialize(map)?)),
                    "shared_content_view_details" => Ok(EventDetails::SharedContentViewDetails(SharedContentViewDetails::internal_deserialize(map)?)),
                    "shared_folder_change_confidentiality_details" => Ok(EventDetails::SharedFolderChangeConfidentialityDetails(SharedFolderChangeConfidentialityDetails::internal_deserialize(map)?)),
                    "shared_folder_change_link_policy_details" => Ok(EventDetails::SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_member_management_policy_details" => Ok(EventDetails::SharedFolderChangeMemberManagementPolicyDetails(SharedFolderChangeMemberManagementPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_member_policy_details" => Ok(EventDetails::SharedFolderChangeMemberPolicyDetails(SharedFolderChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_create_details" => Ok(EventDetails::SharedFolderCreateDetails(SharedFolderCreateDetails::internal_deserialize(map)?)),
                    "shared_folder_mount_details" => Ok(EventDetails::SharedFolderMountDetails(SharedFolderMountDetails::internal_deserialize(map)?)),
                    "shared_folder_transfer_ownership_details" => Ok(EventDetails::SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails::internal_deserialize(map)?)),
                    "shared_folder_unmount_details" => Ok(EventDetails::SharedFolderUnmountDetails(SharedFolderUnmountDetails::internal_deserialize(map)?)),
                    "shared_note_opened_details" => Ok(EventDetails::SharedNoteOpenedDetails(SharedNoteOpenedDetails::internal_deserialize(map)?)),
                    "shmodel_app_create_details" => Ok(EventDetails::ShmodelAppCreateDetails(ShmodelAppCreateDetails::internal_deserialize(map)?)),
                    "shmodel_create_details" => Ok(EventDetails::ShmodelCreateDetails(ShmodelCreateDetails::internal_deserialize(map)?)),
                    "shmodel_disable_details" => Ok(EventDetails::ShmodelDisableDetails(ShmodelDisableDetails::internal_deserialize(map)?)),
                    "shmodel_fb_share_details" => Ok(EventDetails::ShmodelFbShareDetails(ShmodelFbShareDetails::internal_deserialize(map)?)),
                    "shmodel_group_share_details" => Ok(EventDetails::ShmodelGroupShareDetails(ShmodelGroupShareDetails::internal_deserialize(map)?)),
                    "shmodel_remove_expiration_details" => Ok(EventDetails::ShmodelRemoveExpirationDetails(ShmodelRemoveExpirationDetails::internal_deserialize(map)?)),
                    "shmodel_set_expiration_details" => Ok(EventDetails::ShmodelSetExpirationDetails(ShmodelSetExpirationDetails::internal_deserialize(map)?)),
                    "shmodel_team_copy_details" => Ok(EventDetails::ShmodelTeamCopyDetails(ShmodelTeamCopyDetails::internal_deserialize(map)?)),
                    "shmodel_team_download_details" => Ok(EventDetails::ShmodelTeamDownloadDetails(ShmodelTeamDownloadDetails::internal_deserialize(map)?)),
                    "shmodel_team_share_details" => Ok(EventDetails::ShmodelTeamShareDetails(ShmodelTeamShareDetails::internal_deserialize(map)?)),
                    "shmodel_team_view_details" => Ok(EventDetails::ShmodelTeamViewDetails(ShmodelTeamViewDetails::internal_deserialize(map)?)),
                    "shmodel_visibility_password_details" => Ok(EventDetails::ShmodelVisibilityPasswordDetails(ShmodelVisibilityPasswordDetails::internal_deserialize(map)?)),
                    "shmodel_visibility_public_details" => Ok(EventDetails::ShmodelVisibilityPublicDetails(ShmodelVisibilityPublicDetails::internal_deserialize(map)?)),
                    "shmodel_visibility_team_only_details" => Ok(EventDetails::ShmodelVisibilityTeamOnlyDetails(ShmodelVisibilityTeamOnlyDetails::internal_deserialize(map)?)),
                    "remove_logout_url_details" => Ok(EventDetails::RemoveLogoutUrlDetails(RemoveLogoutUrlDetails::internal_deserialize(map)?)),
                    "remove_sso_url_details" => Ok(EventDetails::RemoveSsoUrlDetails(RemoveSsoUrlDetails::internal_deserialize(map)?)),
                    "sso_change_cert_details" => Ok(EventDetails::SsoChangeCertDetails(SsoChangeCertDetails::internal_deserialize(map)?)),
                    "sso_change_login_url_details" => Ok(EventDetails::SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_change_logout_url_details" => Ok(EventDetails::SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails::internal_deserialize(map)?)),
                    "sso_change_saml_identity_mode_details" => Ok(EventDetails::SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails::internal_deserialize(map)?)),
                    "team_folder_change_status_details" => Ok(EventDetails::TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails::internal_deserialize(map)?)),
                    "team_folder_create_details" => Ok(EventDetails::TeamFolderCreateDetails(TeamFolderCreateDetails::internal_deserialize(map)?)),
                    "team_folder_downgrade_details" => Ok(EventDetails::TeamFolderDowngradeDetails(TeamFolderDowngradeDetails::internal_deserialize(map)?)),
                    "team_folder_permanently_delete_details" => Ok(EventDetails::TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "team_folder_rename_details" => Ok(EventDetails::TeamFolderRenameDetails(TeamFolderRenameDetails::internal_deserialize(map)?)),
                    "account_capture_change_policy_details" => Ok(EventDetails::AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails::internal_deserialize(map)?)),
                    "allow_download_disabled_details" => Ok(EventDetails::AllowDownloadDisabledDetails(AllowDownloadDisabledDetails::internal_deserialize(map)?)),
                    "allow_download_enabled_details" => Ok(EventDetails::AllowDownloadEnabledDetails(AllowDownloadEnabledDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_change_policy_details" => Ok(EventDetails::DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_satisfy_policy_details" => Ok(EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_desktop_policy_details" => Ok(EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_mobile_policy_details" => Ok(EventDetails::DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_overage_action_details" => Ok(EventDetails::DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)?)),
                    "device_approvals_change_unlink_action_details" => Ok(EventDetails::DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)?)),
                    "emm_add_exception_details" => Ok(EventDetails::EmmAddExceptionDetails(EmmAddExceptionDetails::internal_deserialize(map)?)),
                    "emm_change_policy_details" => Ok(EventDetails::EmmChangePolicyDetails(EmmChangePolicyDetails::internal_deserialize(map)?)),
                    "emm_remove_exception_details" => Ok(EventDetails::EmmRemoveExceptionDetails(EmmRemoveExceptionDetails::internal_deserialize(map)?)),
                    "extended_version_history_change_policy_details" => Ok(EventDetails::ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)?)),
                    "file_comments_change_policy_details" => Ok(EventDetails::FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_requests_change_policy_details" => Ok(EventDetails::FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_requests_emails_enabled_details" => Ok(EventDetails::FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails::internal_deserialize(map)?)),
                    "file_requests_emails_restricted_to_team_only_details" => Ok(EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)?)),
                    "google_sso_change_policy_details" => Ok(EventDetails::GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails::internal_deserialize(map)?)),
                    "group_user_management_change_policy_details" => Ok(EventDetails::GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails::internal_deserialize(map)?)),
                    "member_requests_change_policy_details" => Ok(EventDetails::MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_add_exception_details" => Ok(EventDetails::MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_policy_details" => Ok(EventDetails::MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_remove_exception_details" => Ok(EventDetails::MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)?)),
                    "member_suggestions_change_policy_details" => Ok(EventDetails::MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails::internal_deserialize(map)?)),
                    "microsoft_office_addin_change_policy_details" => Ok(EventDetails::MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)?)),
                    "network_control_change_policy_details" => Ok(EventDetails::NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails::internal_deserialize(map)?)),
                    "paper_change_deployment_policy_details" => Ok(EventDetails::PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_member_policy_details" => Ok(EventDetails::PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_policy_details" => Ok(EventDetails::PaperChangePolicyDetails(PaperChangePolicyDetails::internal_deserialize(map)?)),
                    "permanent_delete_change_policy_details" => Ok(EventDetails::PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_folder_join_policy_details" => Ok(EventDetails::SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_link_policy_details" => Ok(EventDetails::SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_member_policy_details" => Ok(EventDetails::SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "smart_sync_change_policy_details" => Ok(EventDetails::SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails::internal_deserialize(map)?)),
                    "smart_sync_not_opt_out_details" => Ok(EventDetails::SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails::internal_deserialize(map)?)),
                    "smart_sync_opt_out_details" => Ok(EventDetails::SmartSyncOptOutDetails(SmartSyncOptOutDetails::internal_deserialize(map)?)),
                    "sso_change_policy_details" => Ok(EventDetails::SsoChangePolicyDetails(SsoChangePolicyDetails::internal_deserialize(map)?)),
                    "tfa_change_policy_details" => Ok(EventDetails::TfaChangePolicyDetails(TfaChangePolicyDetails::internal_deserialize(map)?)),
                    "two_account_change_policy_details" => Ok(EventDetails::TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails::internal_deserialize(map)?)),
                    "web_sessions_change_fixed_length_policy_details" => Ok(EventDetails::WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)?)),
                    "web_sessions_change_idle_length_policy_details" => Ok(EventDetails::WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)?)),
                    "team_profile_add_logo_details" => Ok(EventDetails::TeamProfileAddLogoDetails(TeamProfileAddLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_logo_details" => Ok(EventDetails::TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_name_details" => Ok(EventDetails::TeamProfileChangeNameDetails(TeamProfileChangeNameDetails::internal_deserialize(map)?)),
                    "team_profile_remove_logo_details" => Ok(EventDetails::TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails::internal_deserialize(map)?)),
                    "tfa_add_backup_phone_details" => Ok(EventDetails::TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_add_security_key_details" => Ok(EventDetails::TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_change_backup_phone_details" => Ok(EventDetails::TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_change_status_details" => Ok(EventDetails::TfaChangeStatusDetails(TfaChangeStatusDetails::internal_deserialize(map)?)),
                    "tfa_remove_backup_phone_details" => Ok(EventDetails::TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_remove_security_key_details" => Ok(EventDetails::TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_reset_details" => Ok(EventDetails::TfaResetDetails(TfaResetDetails::internal_deserialize(map)?)),
                    "missing_details" => Ok(EventDetails::MissingDetails(MissingDetails::internal_deserialize(map)?)),
                    _ => Ok(EventDetails::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["member_change_membership_type_details",
                                                    "member_permanently_delete_account_contents_details",
                                                    "member_space_limits_change_status_details",
                                                    "member_transfer_account_contents_details",
                                                    "paper_enabled_users_group_addition_details",
                                                    "paper_enabled_users_group_removal_details",
                                                    "paper_external_view_allow_details",
                                                    "paper_external_view_default_team_details",
                                                    "paper_external_view_forbid_details",
                                                    "sf_external_invite_warn_details",
                                                    "team_merge_from_details",
                                                    "team_merge_to_details",
                                                    "app_link_team_details",
                                                    "app_link_user_details",
                                                    "app_unlink_team_details",
                                                    "app_unlink_user_details",
                                                    "device_change_ip_desktop_details",
                                                    "device_change_ip_mobile_details",
                                                    "device_change_ip_web_details",
                                                    "device_delete_on_unlink_fail_details",
                                                    "device_delete_on_unlink_success_details",
                                                    "device_link_fail_details",
                                                    "device_link_success_details",
                                                    "device_management_disabled_details",
                                                    "device_management_enabled_details",
                                                    "device_unlink_details",
                                                    "emm_refresh_auth_token_details",
                                                    "account_capture_change_availability_details",
                                                    "account_capture_migrate_account_details",
                                                    "account_capture_relinquish_account_details",
                                                    "disabled_domain_invites_details",
                                                    "domain_invites_approve_request_to_join_team_details",
                                                    "domain_invites_decline_request_to_join_team_details",
                                                    "domain_invites_email_existing_users_details",
                                                    "domain_invites_request_to_join_team_details",
                                                    "domain_invites_set_invite_new_user_pref_to_no_details",
                                                    "domain_invites_set_invite_new_user_pref_to_yes_details",
                                                    "domain_verification_add_domain_fail_details",
                                                    "domain_verification_add_domain_success_details",
                                                    "domain_verification_remove_domain_details",
                                                    "enabled_domain_invites_details",
                                                    "create_folder_details",
                                                    "file_add_details",
                                                    "file_copy_details",
                                                    "file_delete_details",
                                                    "file_download_details",
                                                    "file_edit_details",
                                                    "file_get_copy_reference_details",
                                                    "file_move_details",
                                                    "file_permanently_delete_details",
                                                    "file_preview_details",
                                                    "file_rename_details",
                                                    "file_restore_details",
                                                    "file_revert_details",
                                                    "file_rollback_changes_details",
                                                    "file_save_copy_reference_details",
                                                    "file_request_add_deadline_details",
                                                    "file_request_change_folder_details",
                                                    "file_request_change_title_details",
                                                    "file_request_close_details",
                                                    "file_request_create_details",
                                                    "file_request_receive_file_details",
                                                    "file_request_remove_deadline_details",
                                                    "file_request_send_details",
                                                    "group_add_external_id_details",
                                                    "group_add_member_details",
                                                    "group_change_external_id_details",
                                                    "group_change_management_type_details",
                                                    "group_change_member_role_details",
                                                    "group_create_details",
                                                    "group_delete_details",
                                                    "group_description_updated_details",
                                                    "group_join_policy_updated_details",
                                                    "group_moved_details",
                                                    "group_remove_external_id_details",
                                                    "group_remove_member_details",
                                                    "group_rename_details",
                                                    "emm_login_success_details",
                                                    "logout_details",
                                                    "password_login_fail_details",
                                                    "password_login_success_details",
                                                    "reseller_support_session_end_details",
                                                    "reseller_support_session_start_details",
                                                    "sign_in_as_session_end_details",
                                                    "sign_in_as_session_start_details",
                                                    "sso_login_fail_details",
                                                    "member_add_name_details",
                                                    "member_change_admin_role_details",
                                                    "member_change_email_details",
                                                    "member_change_name_details",
                                                    "member_change_status_details",
                                                    "member_suggest_details",
                                                    "paper_content_add_member_details",
                                                    "paper_content_add_to_folder_details",
                                                    "paper_content_archive_details",
                                                    "paper_content_change_subscription_details",
                                                    "paper_content_create_details",
                                                    "paper_content_permanently_delete_details",
                                                    "paper_content_remove_from_folder_details",
                                                    "paper_content_remove_member_details",
                                                    "paper_content_rename_details",
                                                    "paper_content_restore_details",
                                                    "paper_doc_add_comment_details",
                                                    "paper_doc_change_member_role_details",
                                                    "paper_doc_change_sharing_policy_details",
                                                    "paper_doc_deleted_details",
                                                    "paper_doc_delete_comment_details",
                                                    "paper_doc_download_details",
                                                    "paper_doc_edit_details",
                                                    "paper_doc_edit_comment_details",
                                                    "paper_doc_followed_details",
                                                    "paper_doc_mention_details",
                                                    "paper_doc_request_access_details",
                                                    "paper_doc_resolve_comment_details",
                                                    "paper_doc_revert_details",
                                                    "paper_doc_slack_share_details",
                                                    "paper_doc_team_invite_details",
                                                    "paper_doc_unresolve_comment_details",
                                                    "paper_doc_view_details",
                                                    "paper_folder_deleted_details",
                                                    "paper_folder_followed_details",
                                                    "paper_folder_team_invite_details",
                                                    "password_change_details",
                                                    "password_reset_details",
                                                    "password_reset_all_details",
                                                    "emm_create_exceptions_report_details",
                                                    "emm_create_usage_report_details",
                                                    "smart_sync_create_admin_privilege_report_details",
                                                    "team_activity_create_report_details",
                                                    "collection_share_details",
                                                    "file_add_comment_details",
                                                    "file_like_comment_details",
                                                    "file_unlike_comment_details",
                                                    "note_acl_invite_only_details",
                                                    "note_acl_link_details",
                                                    "note_acl_team_link_details",
                                                    "note_shared_details",
                                                    "note_share_receive_details",
                                                    "open_note_shared_details",
                                                    "sf_add_group_details",
                                                    "sf_allow_non_members_to_view_shared_links_details",
                                                    "sf_invite_group_details",
                                                    "sf_nest_details",
                                                    "sf_team_decline_details",
                                                    "sf_team_grant_access_details",
                                                    "sf_team_invite_details",
                                                    "sf_team_invite_change_role_details",
                                                    "sf_team_join_details",
                                                    "sf_team_join_from_oob_link_details",
                                                    "sf_team_uninvite_details",
                                                    "shared_content_add_invitees_details",
                                                    "shared_content_add_link_expiry_details",
                                                    "shared_content_add_link_password_details",
                                                    "shared_content_add_member_details",
                                                    "shared_content_change_downloads_policy_details",
                                                    "shared_content_change_invitee_role_details",
                                                    "shared_content_change_link_audience_details",
                                                    "shared_content_change_link_expiry_details",
                                                    "shared_content_change_link_password_details",
                                                    "shared_content_change_member_role_details",
                                                    "shared_content_change_viewer_info_policy_details",
                                                    "shared_content_claim_invitation_details",
                                                    "shared_content_copy_details",
                                                    "shared_content_download_details",
                                                    "shared_content_relinquish_membership_details",
                                                    "shared_content_remove_invitee_details",
                                                    "shared_content_remove_link_expiry_details",
                                                    "shared_content_remove_link_password_details",
                                                    "shared_content_remove_member_details",
                                                    "shared_content_request_access_details",
                                                    "shared_content_unshare_details",
                                                    "shared_content_view_details",
                                                    "shared_folder_change_confidentiality_details",
                                                    "shared_folder_change_link_policy_details",
                                                    "shared_folder_change_member_management_policy_details",
                                                    "shared_folder_change_member_policy_details",
                                                    "shared_folder_create_details",
                                                    "shared_folder_mount_details",
                                                    "shared_folder_transfer_ownership_details",
                                                    "shared_folder_unmount_details",
                                                    "shared_note_opened_details",
                                                    "shmodel_app_create_details",
                                                    "shmodel_create_details",
                                                    "shmodel_disable_details",
                                                    "shmodel_fb_share_details",
                                                    "shmodel_group_share_details",
                                                    "shmodel_remove_expiration_details",
                                                    "shmodel_set_expiration_details",
                                                    "shmodel_team_copy_details",
                                                    "shmodel_team_download_details",
                                                    "shmodel_team_share_details",
                                                    "shmodel_team_view_details",
                                                    "shmodel_visibility_password_details",
                                                    "shmodel_visibility_public_details",
                                                    "shmodel_visibility_team_only_details",
                                                    "remove_logout_url_details",
                                                    "remove_sso_url_details",
                                                    "sso_change_cert_details",
                                                    "sso_change_login_url_details",
                                                    "sso_change_logout_url_details",
                                                    "sso_change_saml_identity_mode_details",
                                                    "team_folder_change_status_details",
                                                    "team_folder_create_details",
                                                    "team_folder_downgrade_details",
                                                    "team_folder_permanently_delete_details",
                                                    "team_folder_rename_details",
                                                    "account_capture_change_policy_details",
                                                    "allow_download_disabled_details",
                                                    "allow_download_enabled_details",
                                                    "data_placement_restriction_change_policy_details",
                                                    "data_placement_restriction_satisfy_policy_details",
                                                    "device_approvals_change_desktop_policy_details",
                                                    "device_approvals_change_mobile_policy_details",
                                                    "device_approvals_change_overage_action_details",
                                                    "device_approvals_change_unlink_action_details",
                                                    "emm_add_exception_details",
                                                    "emm_change_policy_details",
                                                    "emm_remove_exception_details",
                                                    "extended_version_history_change_policy_details",
                                                    "file_comments_change_policy_details",
                                                    "file_requests_change_policy_details",
                                                    "file_requests_emails_enabled_details",
                                                    "file_requests_emails_restricted_to_team_only_details",
                                                    "google_sso_change_policy_details",
                                                    "group_user_management_change_policy_details",
                                                    "member_requests_change_policy_details",
                                                    "member_space_limits_add_exception_details",
                                                    "member_space_limits_change_policy_details",
                                                    "member_space_limits_remove_exception_details",
                                                    "member_suggestions_change_policy_details",
                                                    "microsoft_office_addin_change_policy_details",
                                                    "network_control_change_policy_details",
                                                    "paper_change_deployment_policy_details",
                                                    "paper_change_member_policy_details",
                                                    "paper_change_policy_details",
                                                    "permanent_delete_change_policy_details",
                                                    "sharing_change_folder_join_policy_details",
                                                    "sharing_change_link_policy_details",
                                                    "sharing_change_member_policy_details",
                                                    "smart_sync_change_policy_details",
                                                    "smart_sync_not_opt_out_details",
                                                    "smart_sync_opt_out_details",
                                                    "sso_change_policy_details",
                                                    "tfa_change_policy_details",
                                                    "two_account_change_policy_details",
                                                    "web_sessions_change_fixed_length_policy_details",
                                                    "web_sessions_change_idle_length_policy_details",
                                                    "team_profile_add_logo_details",
                                                    "team_profile_change_logo_details",
                                                    "team_profile_change_name_details",
                                                    "team_profile_remove_logo_details",
                                                    "tfa_add_backup_phone_details",
                                                    "tfa_add_security_key_details",
                                                    "tfa_change_backup_phone_details",
                                                    "tfa_change_status_details",
                                                    "tfa_remove_backup_phone_details",
                                                    "tfa_remove_security_key_details",
                                                    "tfa_reset_details",
                                                    "missing_details",
                                                    "other"];
        deserializer.deserialize_struct("EventDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventDetails::MemberChangeMembershipTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_membership_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberPermanentlyDeleteAccountContentsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberTransferAccountContentsDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_transfer_account_contents_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupAdditionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition_details")?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupRemovalDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal_details")?;
                s.end()
            }
            EventDetails::PaperExternalViewAllowDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_external_view_allow_details")?;
                s.end()
            }
            EventDetails::PaperExternalViewDefaultTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_external_view_default_team_details")?;
                s.end()
            }
            EventDetails::PaperExternalViewForbidDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_external_view_forbid_details")?;
                s.end()
            }
            EventDetails::SfExternalInviteWarnDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sf_external_invite_warn_details")?;
                s.end()
            }
            EventDetails::TeamMergeFromDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_from_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeToDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_to_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppLinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppLinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpDesktopDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_desktop_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpMobileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_mobile_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpWebDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_change_ip_web_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_link_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_link_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceManagementDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_disabled_details")?;
                s.end()
            }
            EventDetails::DeviceManagementEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_enabled_details")?;
                s.end()
            }
            EventDetails::DeviceUnlinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_unlink_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRefreshAuthTokenDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_refresh_auth_token_details")?;
                s.end()
            }
            EventDetails::AccountCaptureChangeAvailabilityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_availability_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureMigrateAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_migrate_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureRelinquishAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_relinquish_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DisabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "disabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesEmailExistingUsersDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainInvitesRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes_details")?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationRemoveDomainDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_remove_domain_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EnabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "enabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::CreateFolderDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "create_folder_details")?;
                s.end()
            }
            EventDetails::FileAddDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_add_details")?;
                s.end()
            }
            EventDetails::FileCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_delete_details")?;
                s.end()
            }
            EventDetails::FileDownloadDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_download_details")?;
                s.end()
            }
            EventDetails::FileEditDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_edit_details")?;
                s.end()
            }
            EventDetails::FileGetCopyReferenceDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_get_copy_reference_details")?;
                s.end()
            }
            EventDetails::FileMoveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_move_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FilePermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_permanently_delete_details")?;
                s.end()
            }
            EventDetails::FilePreviewDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_preview_details")?;
                s.end()
            }
            EventDetails::FileRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRestoreDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_restore_details")?;
                s.end()
            }
            EventDetails::FileRevertDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_revert_details")?;
                s.end()
            }
            EventDetails::FileRollbackChangesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_rollback_changes_details")?;
                s.end()
            }
            EventDetails::FileSaveCopyReferenceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_save_copy_reference_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestAddDeadlineDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_add_deadline_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestChangeFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_change_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestChangeTitleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_change_title_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCloseDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_close_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestReceiveFileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_receive_file_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestRemoveDeadlineDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_remove_deadline_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestSendDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_request_send_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeManagementTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_management_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupDescriptionUpdatedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_description_updated_details")?;
                s.end()
            }
            EventDetails::GroupJoinPolicyUpdatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_join_policy_updated_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupMovedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_moved_details")?;
                s.end()
            }
            EventDetails::GroupRemoveExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_remove_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupRemoveMemberDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_remove_member_details")?;
                s.end()
            }
            EventDetails::GroupRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmLoginSuccessDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_login_success_details")?;
                s.end()
            }
            EventDetails::LogoutDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "logout_details")?;
                s.end()
            }
            EventDetails::PasswordLoginFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "password_login_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PasswordLoginSuccessDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_login_success_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_end_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_start_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_end_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_start_details")?;
                s.end()
            }
            EventDetails::SsoLoginFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_login_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberAddNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_add_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeAdminRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_admin_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeEmailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_email_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "member_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSuggestDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_suggest_details")?;
                s.end()
            }
            EventDetails::PaperContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentAddToFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_content_add_to_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentArchiveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_archive_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentChangeSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_content_change_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentPermanentlyDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_permanently_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveFromFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRestoreDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_restore_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeSharingPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_edit_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_edit_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocMentionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_mention_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRevertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_revert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocSlackShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_slack_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PasswordChangeDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_change_details")?;
                s.end()
            }
            EventDetails::PasswordResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_details")?;
                s.end()
            }
            EventDetails::PasswordResetAllDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_all_details")?;
                s.end()
            }
            EventDetails::EmmCreateExceptionsReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_exceptions_report_details")?;
                s.end()
            }
            EventDetails::EmmCreateUsageReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_usage_report_details")?;
                s.end()
            }
            EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report_details")?;
                s.end()
            }
            EventDetails::TeamActivityCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_activity_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::CollectionShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "collection_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileLikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_like_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileUnlikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_unlike_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoteAclInviteOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_invite_only_details")?;
                s.end()
            }
            EventDetails::NoteAclLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_link_details")?;
                s.end()
            }
            EventDetails::NoteAclTeamLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_team_link_details")?;
                s.end()
            }
            EventDetails::NoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_shared_details")?;
                s.end()
            }
            EventDetails::NoteShareReceiveDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_share_receive_details")?;
                s.end()
            }
            EventDetails::OpenNoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "open_note_shared_details")?;
                s.end()
            }
            EventDetails::SfAddGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_add_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfAllowNonMembersToViewSharedLinksDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfInviteGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sf_invite_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfNestDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_nest_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamDeclineDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_decline_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamGrantAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_grant_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteChangeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_invite_change_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_join_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinFromOobLinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamUninviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_uninvite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_add_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkPasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_add_link_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeDownloadsPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeInviteeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkAudienceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_change_link_audience_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkPasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_change_link_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeViewerInfoPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentClaimInvitationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_claim_invitation_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRelinquishMembershipDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveInviteeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_remove_invitee_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkPasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_remove_link_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentUnshareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_unshare_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeConfidentialityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_folder_change_confidentiality_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMemberManagementPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_folder_change_member_management_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "shared_folder_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderMountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_mount_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderTransferOwnershipDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderUnmountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_unmount_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedNoteOpenedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_note_opened_details")?;
                s.end()
            }
            EventDetails::ShmodelAppCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shmodel_app_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShmodelCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shmodel_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShmodelDisableDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shmodel_disable_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShmodelFbShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shmodel_fb_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShmodelGroupShareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_group_share_details")?;
                s.end()
            }
            EventDetails::ShmodelRemoveExpirationDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_remove_expiration_details")?;
                s.end()
            }
            EventDetails::ShmodelSetExpirationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shmodel_set_expiration_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShmodelTeamCopyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_team_copy_details")?;
                s.end()
            }
            EventDetails::ShmodelTeamDownloadDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_team_download_details")?;
                s.end()
            }
            EventDetails::ShmodelTeamShareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_team_share_details")?;
                s.end()
            }
            EventDetails::ShmodelTeamViewDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_team_view_details")?;
                s.end()
            }
            EventDetails::ShmodelVisibilityPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_password_details")?;
                s.end()
            }
            EventDetails::ShmodelVisibilityPublicDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_public_details")?;
                s.end()
            }
            EventDetails::ShmodelVisibilityTeamOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_team_only_details")?;
                s.end()
            }
            EventDetails::RemoveLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "remove_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::RemoveSsoUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "remove_sso_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeCertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_change_cert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeSamlIdentityModeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_folder_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderCreateDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_create_details")?;
                s.end()
            }
            EventDetails::TeamFolderDowngradeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_folder_downgrade_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderPermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_permanently_delete_details")?;
                s.end()
            }
            EventDetails::TeamFolderRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_folder_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AllowDownloadDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_disabled_details")?;
                s.end()
            }
            EventDetails::AllowDownloadEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_enabled_details")?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeMobilePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeOverageActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeUnlinkActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_add_exception_details")?;
                s.end()
            }
            EventDetails::EmmChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "emm_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_remove_exception_details")?;
                s.end()
            }
            EventDetails::ExtendedVersionHistoryChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "extended_version_history_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileCommentsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_comments_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsEmailsEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_enabled_details")?;
                s.end()
            }
            EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only_details")?;
                s.end()
            }
            EventDetails::GoogleSsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "google_sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupUserManagementChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_user_management_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_add_exception_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception_details")?;
                s.end()
            }
            EventDetails::MemberSuggestionsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_suggestions_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MicrosoftOfficeAddinChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NetworkControlChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "network_control_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeDeploymentPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_deployment_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PermanentDeleteChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "permanent_delete_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeFolderJoinPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncNotOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "tfa_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TwoAccountChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "two_account_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeFixedLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeIdleLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileAddLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_add_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_change_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_profile_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileRemoveLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_remove_logo_details")?;
                s.end()
            }
            EventDetails::TfaAddBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaAddSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_security_key_details")?;
                s.end()
            }
            EventDetails::TfaChangeBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_change_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "tfa_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaRemoveBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaRemoveSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_security_key_details")?;
                s.end()
            }
            EventDetails::TfaResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_reset_details")?;
                s.end()
            }
            EventDetails::MissingDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "missing_details")?;
                s.end()
            }
            EventDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The type of the event.
#[derive(Debug)]
pub enum EventType {
    /// Changed the membership type (limited vs full) for team member.
    MemberChangeMembershipType,
    /// Permanently deleted contents of a removed team member account.
    MemberPermanentlyDeleteAccountContents,
    /// Changed the status with respect to whether the team member is under or over storage quota
    /// specified by policy.
    MemberSpaceLimitsChangeStatus,
    /// Transferred contents of a removed team member account to another member.
    MemberTransferAccountContents,
    /// Users added to Paper enabled users list.
    PaperEnabledUsersGroupAddition,
    /// Users removed from Paper enabled users list.
    PaperEnabledUsersGroupRemoval,
    /// Paper external sharing policy changed: anyone. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    PaperExternalViewAllow,
    /// Paper external sharing policy changed: default team. This event is deprecated and will not
    /// be logged going forward as the associated product functionality no longer exists.
    PaperExternalViewDefaultTeam,
    /// Paper external sharing policy changed: team-only. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    PaperExternalViewForbid,
    /// Admin settings: team members see a warning before sharing folders outside the team
    /// (DEPRECATED FEATURE). This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    SfExternalInviteWarn,
    /// Merged another team into this team.
    TeamMergeFrom,
    /// Merged this team into another team.
    TeamMergeTo,
    /// Linked an app for team.
    AppLinkTeam,
    /// Linked an app for team member.
    AppLinkUser,
    /// Unlinked an app for team.
    AppUnlinkTeam,
    /// Unlinked an app for team member.
    AppUnlinkUser,
    /// IP address associated with active desktop session changed.
    DeviceChangeIpDesktop,
    /// IP address associated with active mobile session changed.
    DeviceChangeIpMobile,
    /// IP address associated with active Web session changed.
    DeviceChangeIpWeb,
    /// Failed to delete all files from an unlinked device.
    DeviceDeleteOnUnlinkFail,
    /// Deleted all files from an unlinked device.
    DeviceDeleteOnUnlinkSuccess,
    /// Failed to link a device.
    DeviceLinkFail,
    /// Linked a device.
    DeviceLinkSuccess,
    /// Disable Device Management. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    DeviceManagementDisabled,
    /// Enable Device Management. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    DeviceManagementEnabled,
    /// Disconnected a device.
    DeviceUnlink,
    /// Refreshed the auth token used for setting up enterprise mobility management.
    EmmRefreshAuthToken,
    /// Granted or revoked the option to enable account capture on domains belonging to the team.
    AccountCaptureChangeAvailability,
    /// Account captured user migrated their account to the team.
    AccountCaptureMigrateAccount,
    /// Account captured user relinquished their account by changing the email address associated
    /// with it.
    AccountCaptureRelinquishAccount,
    /// Disabled domain invites. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    DisabledDomainInvites,
    /// Approved a member's request to join the team.
    DomainInvitesApproveRequestToJoinTeam,
    /// Declined a user's request to join the team.
    DomainInvitesDeclineRequestToJoinTeam,
    /// Sent domain invites to existing domain accounts.
    DomainInvitesEmailExistingUsers,
    /// Asked to join the team.
    DomainInvitesRequestToJoinTeam,
    /// Turned off u201cAutomatically invite new usersu201d. This event is deprecated and will not
    /// be logged going forward as the associated product functionality no longer exists.
    DomainInvitesSetInviteNewUserPrefToNo,
    /// Turned on u201cAutomatically invite new usersu201d. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    DomainInvitesSetInviteNewUserPrefToYes,
    /// Failed to verify a domain belonging to the team.
    DomainVerificationAddDomainFail,
    /// Verified a domain belonging to the team.
    DomainVerificationAddDomainSuccess,
    /// Removed a domain from the list of verified domains belonging to the team.
    DomainVerificationRemoveDomain,
    /// Enabled domain invites. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    EnabledDomainInvites,
    /// Created folders. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    CreateFolder,
    /// Added files and/or folders.
    FileAdd,
    /// Copied files and/or folders.
    FileCopy,
    /// Deleted files and/or folders.
    FileDelete,
    /// Downloaded files and/or folders.
    FileDownload,
    /// Edited files.
    FileEdit,
    /// Create a copy reference to a file or folder.
    FileGetCopyReference,
    /// Moved files and/or folders.
    FileMove,
    /// Permanently deleted files and/or folders.
    FilePermanentlyDelete,
    /// Previewed files and/or folders.
    FilePreview,
    /// Renamed files and/or folders.
    FileRename,
    /// Restored deleted files and/or folders.
    FileRestore,
    /// Reverted files to a previous version.
    FileRevert,
    /// Rolled back file change location changes.
    FileRollbackChanges,
    /// Save a file or folder using a copy reference.
    FileSaveCopyReference,
    /// Added a deadline to a file request.
    FileRequestAddDeadline,
    /// Changed the file request folder.
    FileRequestChangeFolder,
    /// Change the file request title.
    FileRequestChangeTitle,
    /// Closed a file request.
    FileRequestClose,
    /// Created a file request.
    FileRequestCreate,
    /// Received files for a file request.
    FileRequestReceiveFile,
    /// Removed the file request deadline.
    FileRequestRemoveDeadline,
    /// Sent file request to users via email.
    FileRequestSend,
    /// Added an external ID for group.
    GroupAddExternalId,
    /// Added team members to a group.
    GroupAddMember,
    /// Changed the external ID for group.
    GroupChangeExternalId,
    /// Changed group management type.
    GroupChangeManagementType,
    /// Changed the manager permissions belonging to a group member.
    GroupChangeMemberRole,
    /// Created a group.
    GroupCreate,
    /// Deleted a group.
    GroupDelete,
    /// Updated a group.
    GroupDescriptionUpdated,
    /// Updated a group join policy.
    GroupJoinPolicyUpdated,
    /// Moved a group. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    GroupMoved,
    /// Removed the external ID for group.
    GroupRemoveExternalId,
    /// Removed team members from a group.
    GroupRemoveMember,
    /// Renamed a group.
    GroupRename,
    /// Signed in using the Dropbox EMM app.
    EmmLoginSuccess,
    /// Signed out.
    Logout,
    /// Failed to sign in using a password.
    PasswordLoginFail,
    /// Signed in using a password.
    PasswordLoginSuccess,
    /// Ended reseller support session.
    ResellerSupportSessionEnd,
    /// Started reseller support session.
    ResellerSupportSessionStart,
    /// Ended admin sign-in-as session.
    SignInAsSessionEnd,
    /// Started admin sign-in-as session.
    SignInAsSessionStart,
    /// Failed to sign in using SSO.
    SsoLoginFail,
    /// Set team member name when joining team.
    MemberAddName,
    /// Change the admin role belonging to team member.
    MemberChangeAdminRole,
    /// Changed team member email address.
    MemberChangeEmail,
    /// Changed team member name.
    MemberChangeName,
    /// Changed the membership status of a team member.
    MemberChangeStatus,
    /// Suggested a new team member to be added to the team.
    MemberSuggest,
    /// Added users to the membership of a Paper doc or folder.
    PaperContentAddMember,
    /// Added Paper doc or folder to a folder.
    PaperContentAddToFolder,
    /// Archived Paper doc or folder.
    PaperContentArchive,
    /// Followed or unfollowed a Paper doc or folder.
    PaperContentChangeSubscription,
    /// Created a Paper doc or folder.
    PaperContentCreate,
    /// Permanently deleted a Paper doc or folder.
    PaperContentPermanentlyDelete,
    /// Removed Paper doc or folder from a folder.
    PaperContentRemoveFromFolder,
    /// Removed a user from the membership of a Paper doc or folder.
    PaperContentRemoveMember,
    /// Renamed Paper doc or folder.
    PaperContentRename,
    /// Restored an archived Paper doc or folder.
    PaperContentRestore,
    /// Added a Paper doc comment.
    PaperDocAddComment,
    /// Changed the access type of a Paper doc member.
    PaperDocChangeMemberRole,
    /// Changed the sharing policy for Paper doc.
    PaperDocChangeSharingPolicy,
    /// Paper doc archived. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    PaperDocDeleted,
    /// Deleted a Paper doc comment.
    PaperDocDeleteComment,
    /// Downloaded a Paper doc in a particular output format.
    PaperDocDownload,
    /// Edited a Paper doc.
    PaperDocEdit,
    /// Edited a Paper doc comment.
    PaperDocEditComment,
    /// Followed a Paper doc. This event is replaced by paper_content_change_subscription and will
    /// not be logged going forward.
    PaperDocFollowed,
    /// Mentioned a member in a Paper doc.
    PaperDocMention,
    /// Requested to be a member on a Paper doc.
    PaperDocRequestAccess,
    /// Paper doc comment resolved.
    PaperDocResolveComment,
    /// Restored a Paper doc to previous revision.
    PaperDocRevert,
    /// Paper doc link shared via slack.
    PaperDocSlackShare,
    /// Paper doc shared with team member. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    PaperDocTeamInvite,
    /// Unresolved a Paper doc comment.
    PaperDocUnresolveComment,
    /// Viewed Paper doc.
    PaperDocView,
    /// Paper folder archived. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    PaperFolderDeleted,
    /// Followed a Paper folder. This event is replaced by paper_content_change_subscription and
    /// will not be logged going forward.
    PaperFolderFollowed,
    /// Paper folder shared with team member. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    PaperFolderTeamInvite,
    /// Changed password.
    PasswordChange,
    /// Reset password.
    PasswordReset,
    /// Reset all team member passwords.
    PasswordResetAll,
    /// EMM excluded users report created.
    EmmCreateExceptionsReport,
    /// EMM mobile app usage report created.
    EmmCreateUsageReport,
    /// Smart Sync non-admin devices report created.
    SmartSyncCreateAdminPrivilegeReport,
    /// Created a team activity report.
    TeamActivityCreateReport,
    /// Shared an album.
    CollectionShare,
    /// Added a file comment.
    FileAddComment,
    /// Liked a file comment. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    FileLikeComment,
    /// Unliked a file comment. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    FileUnlikeComment,
    /// Changed a Paper document to be invite-only. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    NoteAclInviteOnly,
    /// Changed a Paper document to be link accessible. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    NoteAclLink,
    /// Changed a Paper document to be link accessible for the team. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    NoteAclTeamLink,
    /// Shared a Paper doc. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    NoteShared,
    /// Shared Paper document received. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    NoteShareReceive,
    /// Opened a shared Paper doc. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    OpenNoteShared,
    /// Added the team to a shared folder.
    SfAddGroup,
    /// Allowed non collaborators to view links to files in a shared folder. This event is
    /// deprecated and will not be logged going forward as the associated product functionality no
    /// longer exists.
    SfAllowNonMembersToViewSharedLinks,
    /// Invited a group to a shared folder. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    SfInviteGroup,
    /// Changed parent of shared folder.
    SfNest,
    /// Declined a team member's invitation to a shared folder.
    SfTeamDecline,
    /// Granted access to a shared folder. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    SfTeamGrantAccess,
    /// Invited team members to a shared folder. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    SfTeamInvite,
    /// Changed a team member's role in a shared folder. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    SfTeamInviteChangeRole,
    /// Joined a team member's shared folder. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    SfTeamJoin,
    /// Joined a team member's shared folder from a link. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    SfTeamJoinFromOobLink,
    /// Unshared a folder with a team member. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    SfTeamUninvite,
    /// Sent an email invitation to the membership of a shared file or folder.
    SharedContentAddInvitees,
    /// Added an expiry to the link for the shared file or folder.
    SharedContentAddLinkExpiry,
    /// Added a password to the link for the shared file or folder.
    SharedContentAddLinkPassword,
    /// Added users and/or groups to the membership of a shared file or folder.
    SharedContentAddMember,
    /// Changed whether members can download the shared file or folder.
    SharedContentChangeDownloadsPolicy,
    /// Changed the access type of an invitee to a shared file or folder before the invitation was
    /// claimed.
    SharedContentChangeInviteeRole,
    /// Changed the audience of the link for a shared file or folder.
    SharedContentChangeLinkAudience,
    /// Changed the expiry of the link for the shared file or folder.
    SharedContentChangeLinkExpiry,
    /// Changed the password on the link for the shared file or folder.
    SharedContentChangeLinkPassword,
    /// Changed the access type of a shared file or folder member.
    SharedContentChangeMemberRole,
    /// Changed whether members can see who viewed the shared file or folder.
    SharedContentChangeViewerInfoPolicy,
    /// Claimed membership to a team member's shared folder.
    SharedContentClaimInvitation,
    /// Copied the shared file or folder to own Dropbox.
    SharedContentCopy,
    /// Downloaded the shared file or folder.
    SharedContentDownload,
    /// Left the membership of a shared file or folder.
    SharedContentRelinquishMembership,
    /// Removed an invitee from the membership of a shared file or folder before it was claimed.
    SharedContentRemoveInvitee,
    /// Removed the expiry of the link for the shared file or folder.
    SharedContentRemoveLinkExpiry,
    /// Removed the password on the link for the shared file or folder.
    SharedContentRemoveLinkPassword,
    /// Removed a user or a group from the membership of a shared file or folder.
    SharedContentRemoveMember,
    /// Requested to be on the membership of a shared file or folder.
    SharedContentRequestAccess,
    /// Unshared a shared file or folder by clearing its membership and turning off its link.
    SharedContentUnshare,
    /// Previewed the shared file or folder.
    SharedContentView,
    /// Set or unset the confidential flag on a shared folder.
    SharedFolderChangeConfidentiality,
    /// Changed who can access the shared folder via a link.
    SharedFolderChangeLinkPolicy,
    /// Changed who can manage the membership of a shared folder.
    SharedFolderChangeMemberManagementPolicy,
    /// Changed who can become a member of the shared folder.
    SharedFolderChangeMemberPolicy,
    /// Created a shared folder.
    SharedFolderCreate,
    /// Added a shared folder to own Dropbox.
    SharedFolderMount,
    /// Transferred the ownership of a shared folder to another member.
    SharedFolderTransferOwnership,
    /// Deleted a shared folder from Dropbox.
    SharedFolderUnmount,
    /// Shared Paper document was opened. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    SharedNoteOpened,
    /// Created a link to a file using an app.
    ShmodelAppCreate,
    /// Created a new link.
    ShmodelCreate,
    /// Removed a link.
    ShmodelDisable,
    /// Shared a link with Facebook users.
    ShmodelFbShare,
    /// Shared a link with a group. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    ShmodelGroupShare,
    /// Removed the expiration date from a link.
    ShmodelRemoveExpiration,
    /// Added an expiration date to a link.
    ShmodelSetExpiration,
    /// Added a team member's file/folder to their Dropbox from a link.
    ShmodelTeamCopy,
    /// Downloaded a team member's file/folder from a link.
    ShmodelTeamDownload,
    /// Shared a link with team members.
    ShmodelTeamShare,
    /// Opened a team member's link.
    ShmodelTeamView,
    /// Password-protected a link.
    ShmodelVisibilityPassword,
    /// Made a file/folder visible to anyone with the link.
    ShmodelVisibilityPublic,
    /// Made a file/folder visible only to team members with the link.
    ShmodelVisibilityTeamOnly,
    /// Removed single sign-on logout URL. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    RemoveLogoutUrl,
    /// Changed the sign-out URL for SSO. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    RemoveSsoUrl,
    /// Changed the X.509 certificate for SSO.
    SsoChangeCert,
    /// Changed the sign-in URL for SSO.
    SsoChangeLoginUrl,
    /// Changed the sign-out URL for SSO.
    SsoChangeLogoutUrl,
    /// Changed the SAML identity mode for SSO.
    SsoChangeSamlIdentityMode,
    /// Changed the archival status of a team folder.
    TeamFolderChangeStatus,
    /// Created a new team folder in active status.
    TeamFolderCreate,
    /// Downgraded a team folder to a regular shared folder.
    TeamFolderDowngrade,
    /// Permanently deleted an archived team folder.
    TeamFolderPermanentlyDelete,
    /// Renamed an active or archived team folder.
    TeamFolderRename,
    /// Changed the account capture policy on a domain belonging to the team.
    AccountCaptureChangePolicy,
    /// Disabled allow downloads. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    AllowDownloadDisabled,
    /// Enabled allow downloads. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    AllowDownloadEnabled,
    /// Set a restriction policy regarding the location of data centers where team data resides.
    DataPlacementRestrictionChangePolicy,
    /// Satisfied a previously set restriction policy regarding the location of data centers where
    /// team data resides (i.e. all data have been migrated according to the restriction placed).
    DataPlacementRestrictionSatisfyPolicy,
    /// Set or removed a limit on the number of computers each team member can link to their work
    /// Dropbox account.
    DeviceApprovalsChangeDesktopPolicy,
    /// Set or removed a limit on the number of mobiles devices each team member can link to their
    /// work Dropbox account.
    DeviceApprovalsChangeMobilePolicy,
    /// Changed the action taken when a team member is already over the limits (e.g when they join
    /// the team, an admin lowers limits, etc.).
    DeviceApprovalsChangeOverageAction,
    /// Changed the action taken with respect to approval limits when a team member unlinks an
    /// approved device.
    DeviceApprovalsChangeUnlinkAction,
    /// Added an exception for one or more team members to optionally use the regular Dropbox app
    /// when EMM is enabled.
    EmmAddException,
    /// Enabled or disabled enterprise mobility management for team members.
    EmmChangePolicy,
    /// Removed an exception for one or more team members to optionally use the regular Dropbox app
    /// when EMM is enabled.
    EmmRemoveException,
    /// Accepted or opted out of extended version history.
    ExtendedVersionHistoryChangePolicy,
    /// Enabled or disabled commenting on team files.
    FileCommentsChangePolicy,
    /// Enabled or disabled file requests.
    FileRequestsChangePolicy,
    /// Enabled file request emails for everyone. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    FileRequestsEmailsEnabled,
    /// Allowed file request emails for the team. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    FileRequestsEmailsRestrictedToTeamOnly,
    /// Enabled or disabled Google single sign-on for the team.
    GoogleSsoChangePolicy,
    /// Changed who can create groups.
    GroupUserManagementChangePolicy,
    /// Changed whether users can find the team when not invited.
    MemberRequestsChangePolicy,
    /// Added an exception for one or more team members to bypass space limits imposed by policy.
    MemberSpaceLimitsAddException,
    /// Changed the storage limits applied to team members by policy.
    MemberSpaceLimitsChangePolicy,
    /// Removed an exception for one or more team members to bypass space limits imposed by policy.
    MemberSpaceLimitsRemoveException,
    /// Enabled or disabled the option for team members to suggest new members to add to the team.
    MemberSuggestionsChangePolicy,
    /// Enabled or disabled the Microsoft Office add-in, which lets team members save files to
    /// Dropbox directly from Microsoft Office.
    MicrosoftOfficeAddinChangePolicy,
    /// Enabled or disabled network control.
    NetworkControlChangePolicy,
    /// Changed whether Dropbox Paper, when enabled, is deployed to all teams or to specific members
    /// of the team.
    PaperChangeDeploymentPolicy,
    /// Changed whether team members can share Paper documents externally (i.e. outside the team),
    /// and if so, whether they should be accessible only by team members or anyone by default.
    PaperChangeMemberPolicy,
    /// Enabled or disabled Dropbox Paper for the team.
    PaperChangePolicy,
    /// Enabled or disabled the ability of team members to permanently delete content.
    PermanentDeleteChangePolicy,
    /// Changed whether team members can join shared folders owned externally (i.e. outside the
    /// team).
    SharingChangeFolderJoinPolicy,
    /// Changed whether team members can share links externally (i.e. outside the team), and if so,
    /// whether links should be accessible only by team members or anyone by default.
    SharingChangeLinkPolicy,
    /// Changed whether team members can share files and folders externally (i.e. outside the team).
    SharingChangeMemberPolicy,
    /// Changed the default Smart Sync policy for team members.
    SmartSyncChangePolicy,
    /// Opted team into Smart Sync.
    SmartSyncNotOptOut,
    /// Opted team out of Smart Sync.
    SmartSyncOptOut,
    /// Change the single sign-on policy for the team.
    SsoChangePolicy,
    /// Change two-step verification policy for the team.
    TfaChangePolicy,
    /// Enabled or disabled the option for team members to link a personal Dropbox account in
    /// addition to their work account to the same computer.
    TwoAccountChangePolicy,
    /// Changed how long team members can stay signed in to Dropbox on the web.
    WebSessionsChangeFixedLengthPolicy,
    /// Changed how long team members can be idle while signed in to Dropbox on the web.
    WebSessionsChangeIdleLengthPolicy,
    /// Added a team logo to be displayed on shared link headers.
    TeamProfileAddLogo,
    /// Changed the team logo to be displayed on shared link headers.
    TeamProfileChangeLogo,
    /// Changed the team name.
    TeamProfileChangeName,
    /// Removed the team logo to be displayed on shared link headers.
    TeamProfileRemoveLogo,
    /// Added a backup phone for two-step verification.
    TfaAddBackupPhone,
    /// Added a security key for two-step verification.
    TfaAddSecurityKey,
    /// Changed the backup phone for two-step verification.
    TfaChangeBackupPhone,
    /// Enabled, disabled or changed the configuration for two-step verification.
    TfaChangeStatus,
    /// Removed the backup phone for two-step verification.
    TfaRemoveBackupPhone,
    /// Removed a security key for two-step verification.
    TfaRemoveSecurityKey,
    /// Reset two-step verification for team member.
    TfaReset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "member_change_membership_type" => Ok(EventType::MemberChangeMembershipType),
                    "member_permanently_delete_account_contents" => Ok(EventType::MemberPermanentlyDeleteAccountContents),
                    "member_space_limits_change_status" => Ok(EventType::MemberSpaceLimitsChangeStatus),
                    "member_transfer_account_contents" => Ok(EventType::MemberTransferAccountContents),
                    "paper_enabled_users_group_addition" => Ok(EventType::PaperEnabledUsersGroupAddition),
                    "paper_enabled_users_group_removal" => Ok(EventType::PaperEnabledUsersGroupRemoval),
                    "paper_external_view_allow" => Ok(EventType::PaperExternalViewAllow),
                    "paper_external_view_default_team" => Ok(EventType::PaperExternalViewDefaultTeam),
                    "paper_external_view_forbid" => Ok(EventType::PaperExternalViewForbid),
                    "sf_external_invite_warn" => Ok(EventType::SfExternalInviteWarn),
                    "team_merge_from" => Ok(EventType::TeamMergeFrom),
                    "team_merge_to" => Ok(EventType::TeamMergeTo),
                    "app_link_team" => Ok(EventType::AppLinkTeam),
                    "app_link_user" => Ok(EventType::AppLinkUser),
                    "app_unlink_team" => Ok(EventType::AppUnlinkTeam),
                    "app_unlink_user" => Ok(EventType::AppUnlinkUser),
                    "device_change_ip_desktop" => Ok(EventType::DeviceChangeIpDesktop),
                    "device_change_ip_mobile" => Ok(EventType::DeviceChangeIpMobile),
                    "device_change_ip_web" => Ok(EventType::DeviceChangeIpWeb),
                    "device_delete_on_unlink_fail" => Ok(EventType::DeviceDeleteOnUnlinkFail),
                    "device_delete_on_unlink_success" => Ok(EventType::DeviceDeleteOnUnlinkSuccess),
                    "device_link_fail" => Ok(EventType::DeviceLinkFail),
                    "device_link_success" => Ok(EventType::DeviceLinkSuccess),
                    "device_management_disabled" => Ok(EventType::DeviceManagementDisabled),
                    "device_management_enabled" => Ok(EventType::DeviceManagementEnabled),
                    "device_unlink" => Ok(EventType::DeviceUnlink),
                    "emm_refresh_auth_token" => Ok(EventType::EmmRefreshAuthToken),
                    "account_capture_change_availability" => Ok(EventType::AccountCaptureChangeAvailability),
                    "account_capture_migrate_account" => Ok(EventType::AccountCaptureMigrateAccount),
                    "account_capture_relinquish_account" => Ok(EventType::AccountCaptureRelinquishAccount),
                    "disabled_domain_invites" => Ok(EventType::DisabledDomainInvites),
                    "domain_invites_approve_request_to_join_team" => Ok(EventType::DomainInvitesApproveRequestToJoinTeam),
                    "domain_invites_decline_request_to_join_team" => Ok(EventType::DomainInvitesDeclineRequestToJoinTeam),
                    "domain_invites_email_existing_users" => Ok(EventType::DomainInvitesEmailExistingUsers),
                    "domain_invites_request_to_join_team" => Ok(EventType::DomainInvitesRequestToJoinTeam),
                    "domain_invites_set_invite_new_user_pref_to_no" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToNo),
                    "domain_invites_set_invite_new_user_pref_to_yes" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToYes),
                    "domain_verification_add_domain_fail" => Ok(EventType::DomainVerificationAddDomainFail),
                    "domain_verification_add_domain_success" => Ok(EventType::DomainVerificationAddDomainSuccess),
                    "domain_verification_remove_domain" => Ok(EventType::DomainVerificationRemoveDomain),
                    "enabled_domain_invites" => Ok(EventType::EnabledDomainInvites),
                    "create_folder" => Ok(EventType::CreateFolder),
                    "file_add" => Ok(EventType::FileAdd),
                    "file_copy" => Ok(EventType::FileCopy),
                    "file_delete" => Ok(EventType::FileDelete),
                    "file_download" => Ok(EventType::FileDownload),
                    "file_edit" => Ok(EventType::FileEdit),
                    "file_get_copy_reference" => Ok(EventType::FileGetCopyReference),
                    "file_move" => Ok(EventType::FileMove),
                    "file_permanently_delete" => Ok(EventType::FilePermanentlyDelete),
                    "file_preview" => Ok(EventType::FilePreview),
                    "file_rename" => Ok(EventType::FileRename),
                    "file_restore" => Ok(EventType::FileRestore),
                    "file_revert" => Ok(EventType::FileRevert),
                    "file_rollback_changes" => Ok(EventType::FileRollbackChanges),
                    "file_save_copy_reference" => Ok(EventType::FileSaveCopyReference),
                    "file_request_add_deadline" => Ok(EventType::FileRequestAddDeadline),
                    "file_request_change_folder" => Ok(EventType::FileRequestChangeFolder),
                    "file_request_change_title" => Ok(EventType::FileRequestChangeTitle),
                    "file_request_close" => Ok(EventType::FileRequestClose),
                    "file_request_create" => Ok(EventType::FileRequestCreate),
                    "file_request_receive_file" => Ok(EventType::FileRequestReceiveFile),
                    "file_request_remove_deadline" => Ok(EventType::FileRequestRemoveDeadline),
                    "file_request_send" => Ok(EventType::FileRequestSend),
                    "group_add_external_id" => Ok(EventType::GroupAddExternalId),
                    "group_add_member" => Ok(EventType::GroupAddMember),
                    "group_change_external_id" => Ok(EventType::GroupChangeExternalId),
                    "group_change_management_type" => Ok(EventType::GroupChangeManagementType),
                    "group_change_member_role" => Ok(EventType::GroupChangeMemberRole),
                    "group_create" => Ok(EventType::GroupCreate),
                    "group_delete" => Ok(EventType::GroupDelete),
                    "group_description_updated" => Ok(EventType::GroupDescriptionUpdated),
                    "group_join_policy_updated" => Ok(EventType::GroupJoinPolicyUpdated),
                    "group_moved" => Ok(EventType::GroupMoved),
                    "group_remove_external_id" => Ok(EventType::GroupRemoveExternalId),
                    "group_remove_member" => Ok(EventType::GroupRemoveMember),
                    "group_rename" => Ok(EventType::GroupRename),
                    "emm_login_success" => Ok(EventType::EmmLoginSuccess),
                    "logout" => Ok(EventType::Logout),
                    "password_login_fail" => Ok(EventType::PasswordLoginFail),
                    "password_login_success" => Ok(EventType::PasswordLoginSuccess),
                    "reseller_support_session_end" => Ok(EventType::ResellerSupportSessionEnd),
                    "reseller_support_session_start" => Ok(EventType::ResellerSupportSessionStart),
                    "sign_in_as_session_end" => Ok(EventType::SignInAsSessionEnd),
                    "sign_in_as_session_start" => Ok(EventType::SignInAsSessionStart),
                    "sso_login_fail" => Ok(EventType::SsoLoginFail),
                    "member_add_name" => Ok(EventType::MemberAddName),
                    "member_change_admin_role" => Ok(EventType::MemberChangeAdminRole),
                    "member_change_email" => Ok(EventType::MemberChangeEmail),
                    "member_change_name" => Ok(EventType::MemberChangeName),
                    "member_change_status" => Ok(EventType::MemberChangeStatus),
                    "member_suggest" => Ok(EventType::MemberSuggest),
                    "paper_content_add_member" => Ok(EventType::PaperContentAddMember),
                    "paper_content_add_to_folder" => Ok(EventType::PaperContentAddToFolder),
                    "paper_content_archive" => Ok(EventType::PaperContentArchive),
                    "paper_content_change_subscription" => Ok(EventType::PaperContentChangeSubscription),
                    "paper_content_create" => Ok(EventType::PaperContentCreate),
                    "paper_content_permanently_delete" => Ok(EventType::PaperContentPermanentlyDelete),
                    "paper_content_remove_from_folder" => Ok(EventType::PaperContentRemoveFromFolder),
                    "paper_content_remove_member" => Ok(EventType::PaperContentRemoveMember),
                    "paper_content_rename" => Ok(EventType::PaperContentRename),
                    "paper_content_restore" => Ok(EventType::PaperContentRestore),
                    "paper_doc_add_comment" => Ok(EventType::PaperDocAddComment),
                    "paper_doc_change_member_role" => Ok(EventType::PaperDocChangeMemberRole),
                    "paper_doc_change_sharing_policy" => Ok(EventType::PaperDocChangeSharingPolicy),
                    "paper_doc_deleted" => Ok(EventType::PaperDocDeleted),
                    "paper_doc_delete_comment" => Ok(EventType::PaperDocDeleteComment),
                    "paper_doc_download" => Ok(EventType::PaperDocDownload),
                    "paper_doc_edit" => Ok(EventType::PaperDocEdit),
                    "paper_doc_edit_comment" => Ok(EventType::PaperDocEditComment),
                    "paper_doc_followed" => Ok(EventType::PaperDocFollowed),
                    "paper_doc_mention" => Ok(EventType::PaperDocMention),
                    "paper_doc_request_access" => Ok(EventType::PaperDocRequestAccess),
                    "paper_doc_resolve_comment" => Ok(EventType::PaperDocResolveComment),
                    "paper_doc_revert" => Ok(EventType::PaperDocRevert),
                    "paper_doc_slack_share" => Ok(EventType::PaperDocSlackShare),
                    "paper_doc_team_invite" => Ok(EventType::PaperDocTeamInvite),
                    "paper_doc_unresolve_comment" => Ok(EventType::PaperDocUnresolveComment),
                    "paper_doc_view" => Ok(EventType::PaperDocView),
                    "paper_folder_deleted" => Ok(EventType::PaperFolderDeleted),
                    "paper_folder_followed" => Ok(EventType::PaperFolderFollowed),
                    "paper_folder_team_invite" => Ok(EventType::PaperFolderTeamInvite),
                    "password_change" => Ok(EventType::PasswordChange),
                    "password_reset" => Ok(EventType::PasswordReset),
                    "password_reset_all" => Ok(EventType::PasswordResetAll),
                    "emm_create_exceptions_report" => Ok(EventType::EmmCreateExceptionsReport),
                    "emm_create_usage_report" => Ok(EventType::EmmCreateUsageReport),
                    "smart_sync_create_admin_privilege_report" => Ok(EventType::SmartSyncCreateAdminPrivilegeReport),
                    "team_activity_create_report" => Ok(EventType::TeamActivityCreateReport),
                    "collection_share" => Ok(EventType::CollectionShare),
                    "file_add_comment" => Ok(EventType::FileAddComment),
                    "file_like_comment" => Ok(EventType::FileLikeComment),
                    "file_unlike_comment" => Ok(EventType::FileUnlikeComment),
                    "note_acl_invite_only" => Ok(EventType::NoteAclInviteOnly),
                    "note_acl_link" => Ok(EventType::NoteAclLink),
                    "note_acl_team_link" => Ok(EventType::NoteAclTeamLink),
                    "note_shared" => Ok(EventType::NoteShared),
                    "note_share_receive" => Ok(EventType::NoteShareReceive),
                    "open_note_shared" => Ok(EventType::OpenNoteShared),
                    "sf_add_group" => Ok(EventType::SfAddGroup),
                    "sf_allow_non_members_to_view_shared_links" => Ok(EventType::SfAllowNonMembersToViewSharedLinks),
                    "sf_invite_group" => Ok(EventType::SfInviteGroup),
                    "sf_nest" => Ok(EventType::SfNest),
                    "sf_team_decline" => Ok(EventType::SfTeamDecline),
                    "sf_team_grant_access" => Ok(EventType::SfTeamGrantAccess),
                    "sf_team_invite" => Ok(EventType::SfTeamInvite),
                    "sf_team_invite_change_role" => Ok(EventType::SfTeamInviteChangeRole),
                    "sf_team_join" => Ok(EventType::SfTeamJoin),
                    "sf_team_join_from_oob_link" => Ok(EventType::SfTeamJoinFromOobLink),
                    "sf_team_uninvite" => Ok(EventType::SfTeamUninvite),
                    "shared_content_add_invitees" => Ok(EventType::SharedContentAddInvitees),
                    "shared_content_add_link_expiry" => Ok(EventType::SharedContentAddLinkExpiry),
                    "shared_content_add_link_password" => Ok(EventType::SharedContentAddLinkPassword),
                    "shared_content_add_member" => Ok(EventType::SharedContentAddMember),
                    "shared_content_change_downloads_policy" => Ok(EventType::SharedContentChangeDownloadsPolicy),
                    "shared_content_change_invitee_role" => Ok(EventType::SharedContentChangeInviteeRole),
                    "shared_content_change_link_audience" => Ok(EventType::SharedContentChangeLinkAudience),
                    "shared_content_change_link_expiry" => Ok(EventType::SharedContentChangeLinkExpiry),
                    "shared_content_change_link_password" => Ok(EventType::SharedContentChangeLinkPassword),
                    "shared_content_change_member_role" => Ok(EventType::SharedContentChangeMemberRole),
                    "shared_content_change_viewer_info_policy" => Ok(EventType::SharedContentChangeViewerInfoPolicy),
                    "shared_content_claim_invitation" => Ok(EventType::SharedContentClaimInvitation),
                    "shared_content_copy" => Ok(EventType::SharedContentCopy),
                    "shared_content_download" => Ok(EventType::SharedContentDownload),
                    "shared_content_relinquish_membership" => Ok(EventType::SharedContentRelinquishMembership),
                    "shared_content_remove_invitee" => Ok(EventType::SharedContentRemoveInvitee),
                    "shared_content_remove_link_expiry" => Ok(EventType::SharedContentRemoveLinkExpiry),
                    "shared_content_remove_link_password" => Ok(EventType::SharedContentRemoveLinkPassword),
                    "shared_content_remove_member" => Ok(EventType::SharedContentRemoveMember),
                    "shared_content_request_access" => Ok(EventType::SharedContentRequestAccess),
                    "shared_content_unshare" => Ok(EventType::SharedContentUnshare),
                    "shared_content_view" => Ok(EventType::SharedContentView),
                    "shared_folder_change_confidentiality" => Ok(EventType::SharedFolderChangeConfidentiality),
                    "shared_folder_change_link_policy" => Ok(EventType::SharedFolderChangeLinkPolicy),
                    "shared_folder_change_member_management_policy" => Ok(EventType::SharedFolderChangeMemberManagementPolicy),
                    "shared_folder_change_member_policy" => Ok(EventType::SharedFolderChangeMemberPolicy),
                    "shared_folder_create" => Ok(EventType::SharedFolderCreate),
                    "shared_folder_mount" => Ok(EventType::SharedFolderMount),
                    "shared_folder_transfer_ownership" => Ok(EventType::SharedFolderTransferOwnership),
                    "shared_folder_unmount" => Ok(EventType::SharedFolderUnmount),
                    "shared_note_opened" => Ok(EventType::SharedNoteOpened),
                    "shmodel_app_create" => Ok(EventType::ShmodelAppCreate),
                    "shmodel_create" => Ok(EventType::ShmodelCreate),
                    "shmodel_disable" => Ok(EventType::ShmodelDisable),
                    "shmodel_fb_share" => Ok(EventType::ShmodelFbShare),
                    "shmodel_group_share" => Ok(EventType::ShmodelGroupShare),
                    "shmodel_remove_expiration" => Ok(EventType::ShmodelRemoveExpiration),
                    "shmodel_set_expiration" => Ok(EventType::ShmodelSetExpiration),
                    "shmodel_team_copy" => Ok(EventType::ShmodelTeamCopy),
                    "shmodel_team_download" => Ok(EventType::ShmodelTeamDownload),
                    "shmodel_team_share" => Ok(EventType::ShmodelTeamShare),
                    "shmodel_team_view" => Ok(EventType::ShmodelTeamView),
                    "shmodel_visibility_password" => Ok(EventType::ShmodelVisibilityPassword),
                    "shmodel_visibility_public" => Ok(EventType::ShmodelVisibilityPublic),
                    "shmodel_visibility_team_only" => Ok(EventType::ShmodelVisibilityTeamOnly),
                    "remove_logout_url" => Ok(EventType::RemoveLogoutUrl),
                    "remove_sso_url" => Ok(EventType::RemoveSsoUrl),
                    "sso_change_cert" => Ok(EventType::SsoChangeCert),
                    "sso_change_login_url" => Ok(EventType::SsoChangeLoginUrl),
                    "sso_change_logout_url" => Ok(EventType::SsoChangeLogoutUrl),
                    "sso_change_saml_identity_mode" => Ok(EventType::SsoChangeSamlIdentityMode),
                    "team_folder_change_status" => Ok(EventType::TeamFolderChangeStatus),
                    "team_folder_create" => Ok(EventType::TeamFolderCreate),
                    "team_folder_downgrade" => Ok(EventType::TeamFolderDowngrade),
                    "team_folder_permanently_delete" => Ok(EventType::TeamFolderPermanentlyDelete),
                    "team_folder_rename" => Ok(EventType::TeamFolderRename),
                    "account_capture_change_policy" => Ok(EventType::AccountCaptureChangePolicy),
                    "allow_download_disabled" => Ok(EventType::AllowDownloadDisabled),
                    "allow_download_enabled" => Ok(EventType::AllowDownloadEnabled),
                    "data_placement_restriction_change_policy" => Ok(EventType::DataPlacementRestrictionChangePolicy),
                    "data_placement_restriction_satisfy_policy" => Ok(EventType::DataPlacementRestrictionSatisfyPolicy),
                    "device_approvals_change_desktop_policy" => Ok(EventType::DeviceApprovalsChangeDesktopPolicy),
                    "device_approvals_change_mobile_policy" => Ok(EventType::DeviceApprovalsChangeMobilePolicy),
                    "device_approvals_change_overage_action" => Ok(EventType::DeviceApprovalsChangeOverageAction),
                    "device_approvals_change_unlink_action" => Ok(EventType::DeviceApprovalsChangeUnlinkAction),
                    "emm_add_exception" => Ok(EventType::EmmAddException),
                    "emm_change_policy" => Ok(EventType::EmmChangePolicy),
                    "emm_remove_exception" => Ok(EventType::EmmRemoveException),
                    "extended_version_history_change_policy" => Ok(EventType::ExtendedVersionHistoryChangePolicy),
                    "file_comments_change_policy" => Ok(EventType::FileCommentsChangePolicy),
                    "file_requests_change_policy" => Ok(EventType::FileRequestsChangePolicy),
                    "file_requests_emails_enabled" => Ok(EventType::FileRequestsEmailsEnabled),
                    "file_requests_emails_restricted_to_team_only" => Ok(EventType::FileRequestsEmailsRestrictedToTeamOnly),
                    "google_sso_change_policy" => Ok(EventType::GoogleSsoChangePolicy),
                    "group_user_management_change_policy" => Ok(EventType::GroupUserManagementChangePolicy),
                    "member_requests_change_policy" => Ok(EventType::MemberRequestsChangePolicy),
                    "member_space_limits_add_exception" => Ok(EventType::MemberSpaceLimitsAddException),
                    "member_space_limits_change_policy" => Ok(EventType::MemberSpaceLimitsChangePolicy),
                    "member_space_limits_remove_exception" => Ok(EventType::MemberSpaceLimitsRemoveException),
                    "member_suggestions_change_policy" => Ok(EventType::MemberSuggestionsChangePolicy),
                    "microsoft_office_addin_change_policy" => Ok(EventType::MicrosoftOfficeAddinChangePolicy),
                    "network_control_change_policy" => Ok(EventType::NetworkControlChangePolicy),
                    "paper_change_deployment_policy" => Ok(EventType::PaperChangeDeploymentPolicy),
                    "paper_change_member_policy" => Ok(EventType::PaperChangeMemberPolicy),
                    "paper_change_policy" => Ok(EventType::PaperChangePolicy),
                    "permanent_delete_change_policy" => Ok(EventType::PermanentDeleteChangePolicy),
                    "sharing_change_folder_join_policy" => Ok(EventType::SharingChangeFolderJoinPolicy),
                    "sharing_change_link_policy" => Ok(EventType::SharingChangeLinkPolicy),
                    "sharing_change_member_policy" => Ok(EventType::SharingChangeMemberPolicy),
                    "smart_sync_change_policy" => Ok(EventType::SmartSyncChangePolicy),
                    "smart_sync_not_opt_out" => Ok(EventType::SmartSyncNotOptOut),
                    "smart_sync_opt_out" => Ok(EventType::SmartSyncOptOut),
                    "sso_change_policy" => Ok(EventType::SsoChangePolicy),
                    "tfa_change_policy" => Ok(EventType::TfaChangePolicy),
                    "two_account_change_policy" => Ok(EventType::TwoAccountChangePolicy),
                    "web_sessions_change_fixed_length_policy" => Ok(EventType::WebSessionsChangeFixedLengthPolicy),
                    "web_sessions_change_idle_length_policy" => Ok(EventType::WebSessionsChangeIdleLengthPolicy),
                    "team_profile_add_logo" => Ok(EventType::TeamProfileAddLogo),
                    "team_profile_change_logo" => Ok(EventType::TeamProfileChangeLogo),
                    "team_profile_change_name" => Ok(EventType::TeamProfileChangeName),
                    "team_profile_remove_logo" => Ok(EventType::TeamProfileRemoveLogo),
                    "tfa_add_backup_phone" => Ok(EventType::TfaAddBackupPhone),
                    "tfa_add_security_key" => Ok(EventType::TfaAddSecurityKey),
                    "tfa_change_backup_phone" => Ok(EventType::TfaChangeBackupPhone),
                    "tfa_change_status" => Ok(EventType::TfaChangeStatus),
                    "tfa_remove_backup_phone" => Ok(EventType::TfaRemoveBackupPhone),
                    "tfa_remove_security_key" => Ok(EventType::TfaRemoveSecurityKey),
                    "tfa_reset" => Ok(EventType::TfaReset),
                    _ => Ok(EventType::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["member_change_membership_type",
                                                    "member_permanently_delete_account_contents",
                                                    "member_space_limits_change_status",
                                                    "member_transfer_account_contents",
                                                    "paper_enabled_users_group_addition",
                                                    "paper_enabled_users_group_removal",
                                                    "paper_external_view_allow",
                                                    "paper_external_view_default_team",
                                                    "paper_external_view_forbid",
                                                    "sf_external_invite_warn",
                                                    "team_merge_from",
                                                    "team_merge_to",
                                                    "app_link_team",
                                                    "app_link_user",
                                                    "app_unlink_team",
                                                    "app_unlink_user",
                                                    "device_change_ip_desktop",
                                                    "device_change_ip_mobile",
                                                    "device_change_ip_web",
                                                    "device_delete_on_unlink_fail",
                                                    "device_delete_on_unlink_success",
                                                    "device_link_fail",
                                                    "device_link_success",
                                                    "device_management_disabled",
                                                    "device_management_enabled",
                                                    "device_unlink",
                                                    "emm_refresh_auth_token",
                                                    "account_capture_change_availability",
                                                    "account_capture_migrate_account",
                                                    "account_capture_relinquish_account",
                                                    "disabled_domain_invites",
                                                    "domain_invites_approve_request_to_join_team",
                                                    "domain_invites_decline_request_to_join_team",
                                                    "domain_invites_email_existing_users",
                                                    "domain_invites_request_to_join_team",
                                                    "domain_invites_set_invite_new_user_pref_to_no",
                                                    "domain_invites_set_invite_new_user_pref_to_yes",
                                                    "domain_verification_add_domain_fail",
                                                    "domain_verification_add_domain_success",
                                                    "domain_verification_remove_domain",
                                                    "enabled_domain_invites",
                                                    "create_folder",
                                                    "file_add",
                                                    "file_copy",
                                                    "file_delete",
                                                    "file_download",
                                                    "file_edit",
                                                    "file_get_copy_reference",
                                                    "file_move",
                                                    "file_permanently_delete",
                                                    "file_preview",
                                                    "file_rename",
                                                    "file_restore",
                                                    "file_revert",
                                                    "file_rollback_changes",
                                                    "file_save_copy_reference",
                                                    "file_request_add_deadline",
                                                    "file_request_change_folder",
                                                    "file_request_change_title",
                                                    "file_request_close",
                                                    "file_request_create",
                                                    "file_request_receive_file",
                                                    "file_request_remove_deadline",
                                                    "file_request_send",
                                                    "group_add_external_id",
                                                    "group_add_member",
                                                    "group_change_external_id",
                                                    "group_change_management_type",
                                                    "group_change_member_role",
                                                    "group_create",
                                                    "group_delete",
                                                    "group_description_updated",
                                                    "group_join_policy_updated",
                                                    "group_moved",
                                                    "group_remove_external_id",
                                                    "group_remove_member",
                                                    "group_rename",
                                                    "emm_login_success",
                                                    "logout",
                                                    "password_login_fail",
                                                    "password_login_success",
                                                    "reseller_support_session_end",
                                                    "reseller_support_session_start",
                                                    "sign_in_as_session_end",
                                                    "sign_in_as_session_start",
                                                    "sso_login_fail",
                                                    "member_add_name",
                                                    "member_change_admin_role",
                                                    "member_change_email",
                                                    "member_change_name",
                                                    "member_change_status",
                                                    "member_suggest",
                                                    "paper_content_add_member",
                                                    "paper_content_add_to_folder",
                                                    "paper_content_archive",
                                                    "paper_content_change_subscription",
                                                    "paper_content_create",
                                                    "paper_content_permanently_delete",
                                                    "paper_content_remove_from_folder",
                                                    "paper_content_remove_member",
                                                    "paper_content_rename",
                                                    "paper_content_restore",
                                                    "paper_doc_add_comment",
                                                    "paper_doc_change_member_role",
                                                    "paper_doc_change_sharing_policy",
                                                    "paper_doc_deleted",
                                                    "paper_doc_delete_comment",
                                                    "paper_doc_download",
                                                    "paper_doc_edit",
                                                    "paper_doc_edit_comment",
                                                    "paper_doc_followed",
                                                    "paper_doc_mention",
                                                    "paper_doc_request_access",
                                                    "paper_doc_resolve_comment",
                                                    "paper_doc_revert",
                                                    "paper_doc_slack_share",
                                                    "paper_doc_team_invite",
                                                    "paper_doc_unresolve_comment",
                                                    "paper_doc_view",
                                                    "paper_folder_deleted",
                                                    "paper_folder_followed",
                                                    "paper_folder_team_invite",
                                                    "password_change",
                                                    "password_reset",
                                                    "password_reset_all",
                                                    "emm_create_exceptions_report",
                                                    "emm_create_usage_report",
                                                    "smart_sync_create_admin_privilege_report",
                                                    "team_activity_create_report",
                                                    "collection_share",
                                                    "file_add_comment",
                                                    "file_like_comment",
                                                    "file_unlike_comment",
                                                    "note_acl_invite_only",
                                                    "note_acl_link",
                                                    "note_acl_team_link",
                                                    "note_shared",
                                                    "note_share_receive",
                                                    "open_note_shared",
                                                    "sf_add_group",
                                                    "sf_allow_non_members_to_view_shared_links",
                                                    "sf_invite_group",
                                                    "sf_nest",
                                                    "sf_team_decline",
                                                    "sf_team_grant_access",
                                                    "sf_team_invite",
                                                    "sf_team_invite_change_role",
                                                    "sf_team_join",
                                                    "sf_team_join_from_oob_link",
                                                    "sf_team_uninvite",
                                                    "shared_content_add_invitees",
                                                    "shared_content_add_link_expiry",
                                                    "shared_content_add_link_password",
                                                    "shared_content_add_member",
                                                    "shared_content_change_downloads_policy",
                                                    "shared_content_change_invitee_role",
                                                    "shared_content_change_link_audience",
                                                    "shared_content_change_link_expiry",
                                                    "shared_content_change_link_password",
                                                    "shared_content_change_member_role",
                                                    "shared_content_change_viewer_info_policy",
                                                    "shared_content_claim_invitation",
                                                    "shared_content_copy",
                                                    "shared_content_download",
                                                    "shared_content_relinquish_membership",
                                                    "shared_content_remove_invitee",
                                                    "shared_content_remove_link_expiry",
                                                    "shared_content_remove_link_password",
                                                    "shared_content_remove_member",
                                                    "shared_content_request_access",
                                                    "shared_content_unshare",
                                                    "shared_content_view",
                                                    "shared_folder_change_confidentiality",
                                                    "shared_folder_change_link_policy",
                                                    "shared_folder_change_member_management_policy",
                                                    "shared_folder_change_member_policy",
                                                    "shared_folder_create",
                                                    "shared_folder_mount",
                                                    "shared_folder_transfer_ownership",
                                                    "shared_folder_unmount",
                                                    "shared_note_opened",
                                                    "shmodel_app_create",
                                                    "shmodel_create",
                                                    "shmodel_disable",
                                                    "shmodel_fb_share",
                                                    "shmodel_group_share",
                                                    "shmodel_remove_expiration",
                                                    "shmodel_set_expiration",
                                                    "shmodel_team_copy",
                                                    "shmodel_team_download",
                                                    "shmodel_team_share",
                                                    "shmodel_team_view",
                                                    "shmodel_visibility_password",
                                                    "shmodel_visibility_public",
                                                    "shmodel_visibility_team_only",
                                                    "remove_logout_url",
                                                    "remove_sso_url",
                                                    "sso_change_cert",
                                                    "sso_change_login_url",
                                                    "sso_change_logout_url",
                                                    "sso_change_saml_identity_mode",
                                                    "team_folder_change_status",
                                                    "team_folder_create",
                                                    "team_folder_downgrade",
                                                    "team_folder_permanently_delete",
                                                    "team_folder_rename",
                                                    "account_capture_change_policy",
                                                    "allow_download_disabled",
                                                    "allow_download_enabled",
                                                    "data_placement_restriction_change_policy",
                                                    "data_placement_restriction_satisfy_policy",
                                                    "device_approvals_change_desktop_policy",
                                                    "device_approvals_change_mobile_policy",
                                                    "device_approvals_change_overage_action",
                                                    "device_approvals_change_unlink_action",
                                                    "emm_add_exception",
                                                    "emm_change_policy",
                                                    "emm_remove_exception",
                                                    "extended_version_history_change_policy",
                                                    "file_comments_change_policy",
                                                    "file_requests_change_policy",
                                                    "file_requests_emails_enabled",
                                                    "file_requests_emails_restricted_to_team_only",
                                                    "google_sso_change_policy",
                                                    "group_user_management_change_policy",
                                                    "member_requests_change_policy",
                                                    "member_space_limits_add_exception",
                                                    "member_space_limits_change_policy",
                                                    "member_space_limits_remove_exception",
                                                    "member_suggestions_change_policy",
                                                    "microsoft_office_addin_change_policy",
                                                    "network_control_change_policy",
                                                    "paper_change_deployment_policy",
                                                    "paper_change_member_policy",
                                                    "paper_change_policy",
                                                    "permanent_delete_change_policy",
                                                    "sharing_change_folder_join_policy",
                                                    "sharing_change_link_policy",
                                                    "sharing_change_member_policy",
                                                    "smart_sync_change_policy",
                                                    "smart_sync_not_opt_out",
                                                    "smart_sync_opt_out",
                                                    "sso_change_policy",
                                                    "tfa_change_policy",
                                                    "two_account_change_policy",
                                                    "web_sessions_change_fixed_length_policy",
                                                    "web_sessions_change_idle_length_policy",
                                                    "team_profile_add_logo",
                                                    "team_profile_change_logo",
                                                    "team_profile_change_name",
                                                    "team_profile_remove_logo",
                                                    "tfa_add_backup_phone",
                                                    "tfa_add_security_key",
                                                    "tfa_change_backup_phone",
                                                    "tfa_change_status",
                                                    "tfa_remove_backup_phone",
                                                    "tfa_remove_security_key",
                                                    "tfa_reset",
                                                    "other"];
        deserializer.deserialize_struct("EventType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventType::MemberChangeMembershipType => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_change_membership_type")?;
                s.end()
            }
            EventType::MemberPermanentlyDeleteAccountContents => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents")?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeStatus => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_space_limits_change_status")?;
                s.end()
            }
            EventType::MemberTransferAccountContents => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_transfer_account_contents")?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupAddition => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition")?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupRemoval => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal")?;
                s.end()
            }
            EventType::PaperExternalViewAllow => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_external_view_allow")?;
                s.end()
            }
            EventType::PaperExternalViewDefaultTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_external_view_default_team")?;
                s.end()
            }
            EventType::PaperExternalViewForbid => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_external_view_forbid")?;
                s.end()
            }
            EventType::SfExternalInviteWarn => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_external_invite_warn")?;
                s.end()
            }
            EventType::TeamMergeFrom => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_merge_from")?;
                s.end()
            }
            EventType::TeamMergeTo => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_merge_to")?;
                s.end()
            }
            EventType::AppLinkTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "app_link_team")?;
                s.end()
            }
            EventType::AppLinkUser => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "app_link_user")?;
                s.end()
            }
            EventType::AppUnlinkTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "app_unlink_team")?;
                s.end()
            }
            EventType::AppUnlinkUser => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "app_unlink_user")?;
                s.end()
            }
            EventType::DeviceChangeIpDesktop => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_change_ip_desktop")?;
                s.end()
            }
            EventType::DeviceChangeIpMobile => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_change_ip_mobile")?;
                s.end()
            }
            EventType::DeviceChangeIpWeb => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_change_ip_web")?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkFail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail")?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkSuccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success")?;
                s.end()
            }
            EventType::DeviceLinkFail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_link_fail")?;
                s.end()
            }
            EventType::DeviceLinkSuccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_link_success")?;
                s.end()
            }
            EventType::DeviceManagementDisabled => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_management_disabled")?;
                s.end()
            }
            EventType::DeviceManagementEnabled => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_management_enabled")?;
                s.end()
            }
            EventType::DeviceUnlink => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_unlink")?;
                s.end()
            }
            EventType::EmmRefreshAuthToken => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_refresh_auth_token")?;
                s.end()
            }
            EventType::AccountCaptureChangeAvailability => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "account_capture_change_availability")?;
                s.end()
            }
            EventType::AccountCaptureMigrateAccount => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "account_capture_migrate_account")?;
                s.end()
            }
            EventType::AccountCaptureRelinquishAccount => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "account_capture_relinquish_account")?;
                s.end()
            }
            EventType::DisabledDomainInvites => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "disabled_domain_invites")?;
                s.end()
            }
            EventType::DomainInvitesApproveRequestToJoinTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team")?;
                s.end()
            }
            EventType::DomainInvitesDeclineRequestToJoinTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team")?;
                s.end()
            }
            EventType::DomainInvitesEmailExistingUsers => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users")?;
                s.end()
            }
            EventType::DomainInvitesRequestToJoinTeam => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team")?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToNo => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no")?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToYes => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes")?;
                s.end()
            }
            EventType::DomainVerificationAddDomainFail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail")?;
                s.end()
            }
            EventType::DomainVerificationAddDomainSuccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success")?;
                s.end()
            }
            EventType::DomainVerificationRemoveDomain => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "domain_verification_remove_domain")?;
                s.end()
            }
            EventType::EnabledDomainInvites => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "enabled_domain_invites")?;
                s.end()
            }
            EventType::CreateFolder => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "create_folder")?;
                s.end()
            }
            EventType::FileAdd => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_add")?;
                s.end()
            }
            EventType::FileCopy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_copy")?;
                s.end()
            }
            EventType::FileDelete => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_delete")?;
                s.end()
            }
            EventType::FileDownload => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_download")?;
                s.end()
            }
            EventType::FileEdit => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_edit")?;
                s.end()
            }
            EventType::FileGetCopyReference => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_get_copy_reference")?;
                s.end()
            }
            EventType::FileMove => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_move")?;
                s.end()
            }
            EventType::FilePermanentlyDelete => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_permanently_delete")?;
                s.end()
            }
            EventType::FilePreview => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_preview")?;
                s.end()
            }
            EventType::FileRename => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_rename")?;
                s.end()
            }
            EventType::FileRestore => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_restore")?;
                s.end()
            }
            EventType::FileRevert => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_revert")?;
                s.end()
            }
            EventType::FileRollbackChanges => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_rollback_changes")?;
                s.end()
            }
            EventType::FileSaveCopyReference => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_save_copy_reference")?;
                s.end()
            }
            EventType::FileRequestAddDeadline => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_add_deadline")?;
                s.end()
            }
            EventType::FileRequestChangeFolder => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_change_folder")?;
                s.end()
            }
            EventType::FileRequestChangeTitle => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_change_title")?;
                s.end()
            }
            EventType::FileRequestClose => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_close")?;
                s.end()
            }
            EventType::FileRequestCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_create")?;
                s.end()
            }
            EventType::FileRequestReceiveFile => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_receive_file")?;
                s.end()
            }
            EventType::FileRequestRemoveDeadline => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_remove_deadline")?;
                s.end()
            }
            EventType::FileRequestSend => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_request_send")?;
                s.end()
            }
            EventType::GroupAddExternalId => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_add_external_id")?;
                s.end()
            }
            EventType::GroupAddMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_add_member")?;
                s.end()
            }
            EventType::GroupChangeExternalId => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_change_external_id")?;
                s.end()
            }
            EventType::GroupChangeManagementType => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_change_management_type")?;
                s.end()
            }
            EventType::GroupChangeMemberRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_change_member_role")?;
                s.end()
            }
            EventType::GroupCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_create")?;
                s.end()
            }
            EventType::GroupDelete => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_delete")?;
                s.end()
            }
            EventType::GroupDescriptionUpdated => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_description_updated")?;
                s.end()
            }
            EventType::GroupJoinPolicyUpdated => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_join_policy_updated")?;
                s.end()
            }
            EventType::GroupMoved => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_moved")?;
                s.end()
            }
            EventType::GroupRemoveExternalId => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_remove_external_id")?;
                s.end()
            }
            EventType::GroupRemoveMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_remove_member")?;
                s.end()
            }
            EventType::GroupRename => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_rename")?;
                s.end()
            }
            EventType::EmmLoginSuccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_login_success")?;
                s.end()
            }
            EventType::Logout => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "logout")?;
                s.end()
            }
            EventType::PasswordLoginFail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "password_login_fail")?;
                s.end()
            }
            EventType::PasswordLoginSuccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "password_login_success")?;
                s.end()
            }
            EventType::ResellerSupportSessionEnd => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "reseller_support_session_end")?;
                s.end()
            }
            EventType::ResellerSupportSessionStart => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "reseller_support_session_start")?;
                s.end()
            }
            EventType::SignInAsSessionEnd => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_end")?;
                s.end()
            }
            EventType::SignInAsSessionStart => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_start")?;
                s.end()
            }
            EventType::SsoLoginFail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_login_fail")?;
                s.end()
            }
            EventType::MemberAddName => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_add_name")?;
                s.end()
            }
            EventType::MemberChangeAdminRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_change_admin_role")?;
                s.end()
            }
            EventType::MemberChangeEmail => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_change_email")?;
                s.end()
            }
            EventType::MemberChangeName => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_change_name")?;
                s.end()
            }
            EventType::MemberChangeStatus => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_change_status")?;
                s.end()
            }
            EventType::MemberSuggest => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_suggest")?;
                s.end()
            }
            EventType::PaperContentAddMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_add_member")?;
                s.end()
            }
            EventType::PaperContentAddToFolder => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_add_to_folder")?;
                s.end()
            }
            EventType::PaperContentArchive => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_archive")?;
                s.end()
            }
            EventType::PaperContentChangeSubscription => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_change_subscription")?;
                s.end()
            }
            EventType::PaperContentCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_create")?;
                s.end()
            }
            EventType::PaperContentPermanentlyDelete => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_permanently_delete")?;
                s.end()
            }
            EventType::PaperContentRemoveFromFolder => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder")?;
                s.end()
            }
            EventType::PaperContentRemoveMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_remove_member")?;
                s.end()
            }
            EventType::PaperContentRename => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_rename")?;
                s.end()
            }
            EventType::PaperContentRestore => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_content_restore")?;
                s.end()
            }
            EventType::PaperDocAddComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_add_comment")?;
                s.end()
            }
            EventType::PaperDocChangeMemberRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_change_member_role")?;
                s.end()
            }
            EventType::PaperDocChangeSharingPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy")?;
                s.end()
            }
            EventType::PaperDocDeleted => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_deleted")?;
                s.end()
            }
            EventType::PaperDocDeleteComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_delete_comment")?;
                s.end()
            }
            EventType::PaperDocDownload => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_download")?;
                s.end()
            }
            EventType::PaperDocEdit => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_edit")?;
                s.end()
            }
            EventType::PaperDocEditComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_edit_comment")?;
                s.end()
            }
            EventType::PaperDocFollowed => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_followed")?;
                s.end()
            }
            EventType::PaperDocMention => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_mention")?;
                s.end()
            }
            EventType::PaperDocRequestAccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_request_access")?;
                s.end()
            }
            EventType::PaperDocResolveComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment")?;
                s.end()
            }
            EventType::PaperDocRevert => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_revert")?;
                s.end()
            }
            EventType::PaperDocSlackShare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_slack_share")?;
                s.end()
            }
            EventType::PaperDocTeamInvite => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_team_invite")?;
                s.end()
            }
            EventType::PaperDocUnresolveComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment")?;
                s.end()
            }
            EventType::PaperDocView => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_doc_view")?;
                s.end()
            }
            EventType::PaperFolderDeleted => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_folder_deleted")?;
                s.end()
            }
            EventType::PaperFolderFollowed => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_folder_followed")?;
                s.end()
            }
            EventType::PaperFolderTeamInvite => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_folder_team_invite")?;
                s.end()
            }
            EventType::PasswordChange => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "password_change")?;
                s.end()
            }
            EventType::PasswordReset => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "password_reset")?;
                s.end()
            }
            EventType::PasswordResetAll => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "password_reset_all")?;
                s.end()
            }
            EventType::EmmCreateExceptionsReport => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_create_exceptions_report")?;
                s.end()
            }
            EventType::EmmCreateUsageReport => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_create_usage_report")?;
                s.end()
            }
            EventType::SmartSyncCreateAdminPrivilegeReport => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report")?;
                s.end()
            }
            EventType::TeamActivityCreateReport => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_activity_create_report")?;
                s.end()
            }
            EventType::CollectionShare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "collection_share")?;
                s.end()
            }
            EventType::FileAddComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_add_comment")?;
                s.end()
            }
            EventType::FileLikeComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_like_comment")?;
                s.end()
            }
            EventType::FileUnlikeComment => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_unlike_comment")?;
                s.end()
            }
            EventType::NoteAclInviteOnly => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "note_acl_invite_only")?;
                s.end()
            }
            EventType::NoteAclLink => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "note_acl_link")?;
                s.end()
            }
            EventType::NoteAclTeamLink => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "note_acl_team_link")?;
                s.end()
            }
            EventType::NoteShared => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "note_shared")?;
                s.end()
            }
            EventType::NoteShareReceive => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "note_share_receive")?;
                s.end()
            }
            EventType::OpenNoteShared => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "open_note_shared")?;
                s.end()
            }
            EventType::SfAddGroup => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_add_group")?;
                s.end()
            }
            EventType::SfAllowNonMembersToViewSharedLinks => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links")?;
                s.end()
            }
            EventType::SfInviteGroup => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_invite_group")?;
                s.end()
            }
            EventType::SfNest => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_nest")?;
                s.end()
            }
            EventType::SfTeamDecline => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_decline")?;
                s.end()
            }
            EventType::SfTeamGrantAccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_grant_access")?;
                s.end()
            }
            EventType::SfTeamInvite => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_invite")?;
                s.end()
            }
            EventType::SfTeamInviteChangeRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_invite_change_role")?;
                s.end()
            }
            EventType::SfTeamJoin => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_join")?;
                s.end()
            }
            EventType::SfTeamJoinFromOobLink => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link")?;
                s.end()
            }
            EventType::SfTeamUninvite => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sf_team_uninvite")?;
                s.end()
            }
            EventType::SharedContentAddInvitees => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_add_invitees")?;
                s.end()
            }
            EventType::SharedContentAddLinkExpiry => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry")?;
                s.end()
            }
            EventType::SharedContentAddLinkPassword => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_add_link_password")?;
                s.end()
            }
            EventType::SharedContentAddMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_add_member")?;
                s.end()
            }
            EventType::SharedContentChangeDownloadsPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy")?;
                s.end()
            }
            EventType::SharedContentChangeInviteeRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role")?;
                s.end()
            }
            EventType::SharedContentChangeLinkAudience => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_link_audience")?;
                s.end()
            }
            EventType::SharedContentChangeLinkExpiry => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry")?;
                s.end()
            }
            EventType::SharedContentChangeLinkPassword => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_link_password")?;
                s.end()
            }
            EventType::SharedContentChangeMemberRole => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_member_role")?;
                s.end()
            }
            EventType::SharedContentChangeViewerInfoPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy")?;
                s.end()
            }
            EventType::SharedContentClaimInvitation => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_claim_invitation")?;
                s.end()
            }
            EventType::SharedContentCopy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_copy")?;
                s.end()
            }
            EventType::SharedContentDownload => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_download")?;
                s.end()
            }
            EventType::SharedContentRelinquishMembership => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership")?;
                s.end()
            }
            EventType::SharedContentRemoveInvitee => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_remove_invitee")?;
                s.end()
            }
            EventType::SharedContentRemoveLinkExpiry => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry")?;
                s.end()
            }
            EventType::SharedContentRemoveLinkPassword => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_remove_link_password")?;
                s.end()
            }
            EventType::SharedContentRemoveMember => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_remove_member")?;
                s.end()
            }
            EventType::SharedContentRequestAccess => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_request_access")?;
                s.end()
            }
            EventType::SharedContentUnshare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_unshare")?;
                s.end()
            }
            EventType::SharedContentView => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_content_view")?;
                s.end()
            }
            EventType::SharedFolderChangeConfidentiality => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_change_confidentiality")?;
                s.end()
            }
            EventType::SharedFolderChangeLinkPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy")?;
                s.end()
            }
            EventType::SharedFolderChangeMemberManagementPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_change_member_management_policy")?;
                s.end()
            }
            EventType::SharedFolderChangeMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_change_member_policy")?;
                s.end()
            }
            EventType::SharedFolderCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_create")?;
                s.end()
            }
            EventType::SharedFolderMount => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_mount")?;
                s.end()
            }
            EventType::SharedFolderTransferOwnership => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership")?;
                s.end()
            }
            EventType::SharedFolderUnmount => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_folder_unmount")?;
                s.end()
            }
            EventType::SharedNoteOpened => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shared_note_opened")?;
                s.end()
            }
            EventType::ShmodelAppCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_app_create")?;
                s.end()
            }
            EventType::ShmodelCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_create")?;
                s.end()
            }
            EventType::ShmodelDisable => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_disable")?;
                s.end()
            }
            EventType::ShmodelFbShare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_fb_share")?;
                s.end()
            }
            EventType::ShmodelGroupShare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_group_share")?;
                s.end()
            }
            EventType::ShmodelRemoveExpiration => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_remove_expiration")?;
                s.end()
            }
            EventType::ShmodelSetExpiration => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_set_expiration")?;
                s.end()
            }
            EventType::ShmodelTeamCopy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_team_copy")?;
                s.end()
            }
            EventType::ShmodelTeamDownload => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_team_download")?;
                s.end()
            }
            EventType::ShmodelTeamShare => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_team_share")?;
                s.end()
            }
            EventType::ShmodelTeamView => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_team_view")?;
                s.end()
            }
            EventType::ShmodelVisibilityPassword => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_password")?;
                s.end()
            }
            EventType::ShmodelVisibilityPublic => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_public")?;
                s.end()
            }
            EventType::ShmodelVisibilityTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "shmodel_visibility_team_only")?;
                s.end()
            }
            EventType::RemoveLogoutUrl => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "remove_logout_url")?;
                s.end()
            }
            EventType::RemoveSsoUrl => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "remove_sso_url")?;
                s.end()
            }
            EventType::SsoChangeCert => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_change_cert")?;
                s.end()
            }
            EventType::SsoChangeLoginUrl => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_change_login_url")?;
                s.end()
            }
            EventType::SsoChangeLogoutUrl => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_change_logout_url")?;
                s.end()
            }
            EventType::SsoChangeSamlIdentityMode => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode")?;
                s.end()
            }
            EventType::TeamFolderChangeStatus => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_folder_change_status")?;
                s.end()
            }
            EventType::TeamFolderCreate => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_folder_create")?;
                s.end()
            }
            EventType::TeamFolderDowngrade => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_folder_downgrade")?;
                s.end()
            }
            EventType::TeamFolderPermanentlyDelete => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_folder_permanently_delete")?;
                s.end()
            }
            EventType::TeamFolderRename => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_folder_rename")?;
                s.end()
            }
            EventType::AccountCaptureChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "account_capture_change_policy")?;
                s.end()
            }
            EventType::AllowDownloadDisabled => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "allow_download_disabled")?;
                s.end()
            }
            EventType::AllowDownloadEnabled => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "allow_download_enabled")?;
                s.end()
            }
            EventType::DataPlacementRestrictionChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy")?;
                s.end()
            }
            EventType::DataPlacementRestrictionSatisfyPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy")?;
                s.end()
            }
            EventType::DeviceApprovalsChangeDesktopPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy")?;
                s.end()
            }
            EventType::DeviceApprovalsChangeMobilePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy")?;
                s.end()
            }
            EventType::DeviceApprovalsChangeOverageAction => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action")?;
                s.end()
            }
            EventType::DeviceApprovalsChangeUnlinkAction => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action")?;
                s.end()
            }
            EventType::EmmAddException => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_add_exception")?;
                s.end()
            }
            EventType::EmmChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_change_policy")?;
                s.end()
            }
            EventType::EmmRemoveException => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "emm_remove_exception")?;
                s.end()
            }
            EventType::ExtendedVersionHistoryChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "extended_version_history_change_policy")?;
                s.end()
            }
            EventType::FileCommentsChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_comments_change_policy")?;
                s.end()
            }
            EventType::FileRequestsChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_requests_change_policy")?;
                s.end()
            }
            EventType::FileRequestsEmailsEnabled => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_requests_emails_enabled")?;
                s.end()
            }
            EventType::FileRequestsEmailsRestrictedToTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only")?;
                s.end()
            }
            EventType::GoogleSsoChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "google_sso_change_policy")?;
                s.end()
            }
            EventType::GroupUserManagementChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "group_user_management_change_policy")?;
                s.end()
            }
            EventType::MemberRequestsChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_requests_change_policy")?;
                s.end()
            }
            EventType::MemberSpaceLimitsAddException => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_space_limits_add_exception")?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_space_limits_change_policy")?;
                s.end()
            }
            EventType::MemberSpaceLimitsRemoveException => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception")?;
                s.end()
            }
            EventType::MemberSuggestionsChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "member_suggestions_change_policy")?;
                s.end()
            }
            EventType::MicrosoftOfficeAddinChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy")?;
                s.end()
            }
            EventType::NetworkControlChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "network_control_change_policy")?;
                s.end()
            }
            EventType::PaperChangeDeploymentPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_change_deployment_policy")?;
                s.end()
            }
            EventType::PaperChangeMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_change_member_policy")?;
                s.end()
            }
            EventType::PaperChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "paper_change_policy")?;
                s.end()
            }
            EventType::PermanentDeleteChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "permanent_delete_change_policy")?;
                s.end()
            }
            EventType::SharingChangeFolderJoinPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy")?;
                s.end()
            }
            EventType::SharingChangeLinkPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sharing_change_link_policy")?;
                s.end()
            }
            EventType::SharingChangeMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sharing_change_member_policy")?;
                s.end()
            }
            EventType::SmartSyncChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "smart_sync_change_policy")?;
                s.end()
            }
            EventType::SmartSyncNotOptOut => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out")?;
                s.end()
            }
            EventType::SmartSyncOptOut => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "smart_sync_opt_out")?;
                s.end()
            }
            EventType::SsoChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "sso_change_policy")?;
                s.end()
            }
            EventType::TfaChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_change_policy")?;
                s.end()
            }
            EventType::TwoAccountChangePolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "two_account_change_policy")?;
                s.end()
            }
            EventType::WebSessionsChangeFixedLengthPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy")?;
                s.end()
            }
            EventType::WebSessionsChangeIdleLengthPolicy => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy")?;
                s.end()
            }
            EventType::TeamProfileAddLogo => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_profile_add_logo")?;
                s.end()
            }
            EventType::TeamProfileChangeLogo => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_profile_change_logo")?;
                s.end()
            }
            EventType::TeamProfileChangeName => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_profile_change_name")?;
                s.end()
            }
            EventType::TeamProfileRemoveLogo => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "team_profile_remove_logo")?;
                s.end()
            }
            EventType::TfaAddBackupPhone => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_add_backup_phone")?;
                s.end()
            }
            EventType::TfaAddSecurityKey => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_add_security_key")?;
                s.end()
            }
            EventType::TfaChangeBackupPhone => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_change_backup_phone")?;
                s.end()
            }
            EventType::TfaChangeStatus => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_change_status")?;
                s.end()
            }
            EventType::TfaRemoveBackupPhone => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone")?;
                s.end()
            }
            EventType::TfaRemoveSecurityKey => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_remove_security_key")?;
                s.end()
            }
            EventType::TfaReset => {
                // unit
                let mut s = serializer.serialize_struct("EventType", 1)?;
                s.serialize_field(".tag", "tfa_reset")?;
                s.end()
            }
            EventType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Accepted or opted out of extended version history.
#[derive(Debug)]
pub struct ExtendedVersionHistoryChangePolicyDetails {
    /// New extended version history policy.
    pub new_value: ExtendedVersionHistoryPolicy,
    /// Previous extended version history policy. Might be missing due to historical data gap.
    pub previous_value: Option<ExtendedVersionHistoryPolicy>,
}

impl ExtendedVersionHistoryChangePolicyDetails {
    pub fn new(new_value: ExtendedVersionHistoryPolicy) -> Self {
        ExtendedVersionHistoryChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ExtendedVersionHistoryPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                         "previous_value"];
impl ExtendedVersionHistoryChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ExtendedVersionHistoryChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(ExtendedVersionHistoryChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExtendedVersionHistoryChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExtendedVersionHistoryChangePolicyDetails", EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExtendedVersionHistoryChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ExtendedVersionHistoryPolicy {
    Limited,
    Unlimited,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExtendedVersionHistoryPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "limited" => Ok(ExtendedVersionHistoryPolicy::Limited),
                    "unlimited" => Ok(ExtendedVersionHistoryPolicy::Unlimited),
                    _ => Ok(ExtendedVersionHistoryPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["limited",
                                                    "unlimited",
                                                    "other"];
        deserializer.deserialize_struct("ExtendedVersionHistoryPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExtendedVersionHistoryPolicy::Limited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "limited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::Unlimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "unlimited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Provides details about a failure
#[derive(Debug)]
pub struct FailureDetailsLogInfo {
    /// A user friendly explanation of the error. Might be missing due to historical data gap.
    pub user_friendly_message: Option<String>,
    /// A technical explanation of the error. This is relevant for some errors.
    pub technical_error_message: Option<String>,
}

impl Default for FailureDetailsLogInfo {
    fn default() -> Self {
        FailureDetailsLogInfo {
            user_friendly_message: None,
            technical_error_message: None,
        }
    }
}

const FAILURE_DETAILS_LOG_INFO_FIELDS: &'static [&'static str] = &["user_friendly_message",
                                                                   "technical_error_message"];
impl FailureDetailsLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FailureDetailsLogInfo, V::Error> {
        use serde::de;
        let mut field_user_friendly_message = None;
        let mut field_technical_error_message = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_friendly_message" => {
                    if field_user_friendly_message.is_some() {
                        return Err(de::Error::duplicate_field("user_friendly_message"));
                    }
                    field_user_friendly_message = Some(map.next_value()?);
                }
                "technical_error_message" => {
                    if field_technical_error_message.is_some() {
                        return Err(de::Error::duplicate_field("technical_error_message"));
                    }
                    field_technical_error_message = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FAILURE_DETAILS_LOG_INFO_FIELDS))
            }
        }
        Ok(FailureDetailsLogInfo {
            user_friendly_message: field_user_friendly_message,
            technical_error_message: field_technical_error_message,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_friendly_message", &self.user_friendly_message)?;
        s.serialize_field("technical_error_message", &self.technical_error_message)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FailureDetailsLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FailureDetailsLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FailureDetailsLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FailureDetailsLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FailureDetailsLogInfo", FAILURE_DETAILS_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FailureDetailsLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FailureDetailsLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a file comment.
#[derive(Debug)]
pub struct FileAddCommentDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl FileAddCommentDetails {
    pub fn new(target_index: i64) -> Self {
        FileAddCommentDetails {
            target_index,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const FILE_ADD_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                   "comment_text"];
impl FileAddCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileAddCommentDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_ADD_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileAddCommentDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddCommentDetails", FILE_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added files and/or folders.
#[derive(Debug)]
pub struct FileAddDetails {
}

impl Default for FileAddDetails {
    fn default() -> Self {
        FileAddDetails {
        }
    }
}

const FILE_ADD_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileAddDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileAddDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_ADD_DETAILS_FIELDS));
        }
        Ok(FileAddDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddDetails", FILE_ADD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileAddDetails", 0)?.end()
    }
}

/// Enabled or disabled commenting on team files.
#[derive(Debug)]
pub struct FileCommentsChangePolicyDetails {
    /// New commenting on team files policy.
    pub new_value: FileCommentsPolicy,
    /// Previous commenting on team files policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileCommentsPolicy>,
}

impl FileCommentsChangePolicyDetails {
    pub fn new(new_value: FileCommentsPolicy) -> Self {
        FileCommentsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileCommentsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                              "previous_value"];
impl FileCommentsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileCommentsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(FileCommentsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCommentsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCommentsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCommentsChangePolicyDetails", FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCommentsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File comments policy
#[derive(Debug)]
pub enum FileCommentsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileCommentsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(FileCommentsPolicy::Disabled),
                    "enabled" => Ok(FileCommentsPolicy::Enabled),
                    _ => Ok(FileCommentsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("FileCommentsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileCommentsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileCommentsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileCommentsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Copied files and/or folders.
#[derive(Debug)]
pub struct FileCopyDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileCopyDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileCopyDetails {
            relocate_action_details,
        }
    }

}

const FILE_COPY_DETAILS_FIELDS: &'static [&'static str] = &["relocate_action_details"];
impl FileCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileCopyDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COPY_DETAILS_FIELDS))
            }
        }
        Ok(FileCopyDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCopyDetails", FILE_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCopyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted files and/or folders.
#[derive(Debug)]
pub struct FileDeleteDetails {
}

impl Default for FileDeleteDetails {
    fn default() -> Self {
        FileDeleteDetails {
        }
    }
}

const FILE_DELETE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_DELETE_DETAILS_FIELDS));
        }
        Ok(FileDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteDetails", FILE_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDeleteDetails", 0)?.end()
    }
}

/// Downloaded files and/or folders.
#[derive(Debug)]
pub struct FileDownloadDetails {
}

impl Default for FileDownloadDetails {
    fn default() -> Self {
        FileDownloadDetails {
        }
    }
}

const FILE_DOWNLOAD_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileDownloadDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_DOWNLOAD_DETAILS_FIELDS));
        }
        Ok(FileDownloadDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDownloadDetails", FILE_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDownloadDetails", 0)?.end()
    }
}

/// Edited files.
#[derive(Debug)]
pub struct FileEditDetails {
}

impl Default for FileEditDetails {
    fn default() -> Self {
        FileEditDetails {
        }
    }
}

const FILE_EDIT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileEditDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileEditDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_EDIT_DETAILS_FIELDS));
        }
        Ok(FileEditDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditDetails", FILE_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileEditDetails", 0)?.end()
    }
}

/// Create a copy reference to a file or folder.
#[derive(Debug)]
pub struct FileGetCopyReferenceDetails {
}

impl Default for FileGetCopyReferenceDetails {
    fn default() -> Self {
        FileGetCopyReferenceDetails {
        }
    }
}

const FILE_GET_COPY_REFERENCE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileGetCopyReferenceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileGetCopyReferenceDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_GET_COPY_REFERENCE_DETAILS_FIELDS));
        }
        Ok(FileGetCopyReferenceDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileGetCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileGetCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileGetCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileGetCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileGetCopyReferenceDetails", FILE_GET_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileGetCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileGetCopyReferenceDetails", 0)?.end()
    }
}

/// Liked a file comment.
#[derive(Debug)]
pub struct FileLikeCommentDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl FileLikeCommentDetails {
    pub fn new(target_index: i64) -> Self {
        FileLikeCommentDetails {
            target_index,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const FILE_LIKE_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                    "comment_text"];
impl FileLikeCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileLikeCommentDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LIKE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileLikeCommentDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLikeCommentDetails", FILE_LIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLikeCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File's logged information.
#[derive(Debug)]
pub struct FileLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FileLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FILE_LOG_INFO_FIELDS: &'static [&'static str] = &["path",
                                                        "display_name",
                                                        "file_id"];
impl FileLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LOG_INFO_FIELDS))
            }
        }
        Ok(FileLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLogInfo", FILE_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Moved files and/or folders.
#[derive(Debug)]
pub struct FileMoveDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileMoveDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileMoveDetails {
            relocate_action_details,
        }
    }

}

const FILE_MOVE_DETAILS_FIELDS: &'static [&'static str] = &["relocate_action_details"];
impl FileMoveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileMoveDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_MOVE_DETAILS_FIELDS))
            }
        }
        Ok(FileMoveDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMoveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMoveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMoveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMoveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMoveDetails", FILE_MOVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMoveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMoveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Generic information relevant both for files and folders
#[derive(Debug)]
pub struct FileOrFolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FileOrFolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileOrFolderLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FILE_OR_FOLDER_LOG_INFO_FIELDS: &'static [&'static str] = &["path",
                                                                  "display_name",
                                                                  "file_id"];
impl FileOrFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileOrFolderLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_OR_FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(FileOrFolderLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileOrFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileOrFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileOrFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileOrFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileOrFolderLogInfo", FILE_OR_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileOrFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileOrFolderLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted files and/or folders.
#[derive(Debug)]
pub struct FilePermanentlyDeleteDetails {
}

impl Default for FilePermanentlyDeleteDetails {
    fn default() -> Self {
        FilePermanentlyDeleteDetails {
        }
    }
}

const FILE_PERMANENTLY_DELETE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FilePermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FilePermanentlyDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_PERMANENTLY_DELETE_DETAILS_FIELDS));
        }
        Ok(FilePermanentlyDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermanentlyDeleteDetails", FILE_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePermanentlyDeleteDetails", 0)?.end()
    }
}

/// Previewed files and/or folders.
#[derive(Debug)]
pub struct FilePreviewDetails {
}

impl Default for FilePreviewDetails {
    fn default() -> Self {
        FilePreviewDetails {
        }
    }
}

const FILE_PREVIEW_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FilePreviewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FilePreviewDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_PREVIEW_DETAILS_FIELDS));
        }
        Ok(FilePreviewDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePreviewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePreviewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePreviewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePreviewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePreviewDetails", FILE_PREVIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePreviewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePreviewDetails", 0)?.end()
    }
}

/// Renamed files and/or folders.
#[derive(Debug)]
pub struct FileRenameDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileRenameDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileRenameDetails {
            relocate_action_details,
        }
    }

}

const FILE_RENAME_DETAILS_FIELDS: &'static [&'static str] = &["relocate_action_details"];
impl FileRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRenameDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(FileRenameDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRenameDetails", FILE_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a deadline to a file request.
#[derive(Debug)]
pub struct FileRequestAddDeadlineDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestAddDeadlineDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestAddDeadlineDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_ADD_DEADLINE_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestAddDeadlineDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestAddDeadlineDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_ADD_DEADLINE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestAddDeadlineDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestAddDeadlineDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestAddDeadlineDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestAddDeadlineDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestAddDeadlineDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestAddDeadlineDetails", FILE_REQUEST_ADD_DEADLINE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestAddDeadlineDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestAddDeadlineDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the file request folder.
#[derive(Debug)]
pub struct FileRequestChangeFolderDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestChangeFolderDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestChangeFolderDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_CHANGE_FOLDER_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestChangeFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestChangeFolderDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CHANGE_FOLDER_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestChangeFolderDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeFolderDetails", FILE_REQUEST_CHANGE_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeFolderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the file request title.
#[derive(Debug)]
pub struct FileRequestChangeTitleDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestChangeTitleDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestChangeTitleDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_CHANGE_TITLE_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestChangeTitleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestChangeTitleDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CHANGE_TITLE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestChangeTitleDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeTitleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeTitleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeTitleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeTitleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeTitleDetails", FILE_REQUEST_CHANGE_TITLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeTitleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeTitleDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Closed a file request.
#[derive(Debug)]
pub struct FileRequestCloseDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestCloseDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestCloseDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_CLOSE_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestCloseDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestCloseDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CLOSE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestCloseDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCloseDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCloseDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCloseDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCloseDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCloseDetails", FILE_REQUEST_CLOSE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCloseDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCloseDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a file request.
#[derive(Debug)]
pub struct FileRequestCreateDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestCreateDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestCreateDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestCreateDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestCreateDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCreateDetails", FILE_REQUEST_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Received files for a file request.
#[derive(Debug)]
pub struct FileRequestReceiveFileDetails {
    /// File request title.
    pub request_title: String,
    /// Submitted file names.
    pub submitted_file_names: Vec<String>,
}

impl FileRequestReceiveFileDetails {
    pub fn new(request_title: String, submitted_file_names: Vec<String>) -> Self {
        FileRequestReceiveFileDetails {
            request_title,
            submitted_file_names,
        }
    }

}

const FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS: &'static [&'static str] = &["request_title",
                                                                            "submitted_file_names"];
impl FileRequestReceiveFileDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestReceiveFileDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        let mut field_submitted_file_names = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                "submitted_file_names" => {
                    if field_submitted_file_names.is_some() {
                        return Err(de::Error::duplicate_field("submitted_file_names"));
                    }
                    field_submitted_file_names = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestReceiveFileDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
            submitted_file_names: field_submitted_file_names.ok_or_else(|| de::Error::missing_field("submitted_file_names"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)?;
        s.serialize_field("submitted_file_names", &self.submitted_file_names)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestReceiveFileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestReceiveFileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestReceiveFileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestReceiveFileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestReceiveFileDetails", FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestReceiveFileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestReceiveFileDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the file request deadline.
#[derive(Debug)]
pub struct FileRequestRemoveDeadlineDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestRemoveDeadlineDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestRemoveDeadlineDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_REMOVE_DEADLINE_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestRemoveDeadlineDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestRemoveDeadlineDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_REMOVE_DEADLINE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestRemoveDeadlineDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestRemoveDeadlineDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestRemoveDeadlineDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestRemoveDeadlineDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestRemoveDeadlineDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestRemoveDeadlineDetails", FILE_REQUEST_REMOVE_DEADLINE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestRemoveDeadlineDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestRemoveDeadlineDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent file request to users via email.
#[derive(Debug)]
pub struct FileRequestSendDetails {
    /// File request title.
    pub request_title: String,
}

impl FileRequestSendDetails {
    pub fn new(request_title: String) -> Self {
        FileRequestSendDetails {
            request_title,
        }
    }

}

const FILE_REQUEST_SEND_DETAILS_FIELDS: &'static [&'static str] = &["request_title"];
impl FileRequestSendDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestSendDetails, V::Error> {
        use serde::de;
        let mut field_request_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_title" => {
                    if field_request_title.is_some() {
                        return Err(de::Error::duplicate_field("request_title"));
                    }
                    field_request_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_SEND_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestSendDetails {
            request_title: field_request_title.ok_or_else(|| de::Error::missing_field("request_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_title", &self.request_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestSendDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestSendDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestSendDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestSendDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestSendDetails", FILE_REQUEST_SEND_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestSendDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestSendDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled file requests.
#[derive(Debug)]
pub struct FileRequestsChangePolicyDetails {
    /// New file requests policy.
    pub new_value: FileRequestsPolicy,
    /// Previous file requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileRequestsPolicy>,
}

impl FileRequestsChangePolicyDetails {
    pub fn new(new_value: FileRequestsPolicy) -> Self {
        FileRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                              "previous_value"];
impl FileRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsChangePolicyDetails", FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled file request emails for everyone.
#[derive(Debug)]
pub struct FileRequestsEmailsEnabledDetails {
}

impl Default for FileRequestsEmailsEnabledDetails {
    fn default() -> Self {
        FileRequestsEmailsEnabledDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileRequestsEmailsEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestsEmailsEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS));
        }
        Ok(FileRequestsEmailsEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsEnabledDetails", FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsEnabledDetails", 0)?.end()
    }
}

/// Allowed file request emails for the team.
#[derive(Debug)]
pub struct FileRequestsEmailsRestrictedToTeamOnlyDetails {
}

impl Default for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn default() -> Self {
        FileRequestsEmailsRestrictedToTeamOnlyDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileRequestsEmailsRestrictedToTeamOnlyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRequestsEmailsRestrictedToTeamOnlyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS));
        }
        Ok(FileRequestsEmailsRestrictedToTeamOnlyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsRestrictedToTeamOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsRestrictedToTeamOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", 0)?.end()
    }
}

/// File requests policy
#[derive(Debug)]
pub enum FileRequestsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(FileRequestsPolicy::Disabled),
                    "enabled" => Ok(FileRequestsPolicy::Enabled),
                    _ => Ok(FileRequestsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("FileRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileRequestsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Restored deleted files and/or folders.
#[derive(Debug)]
pub struct FileRestoreDetails {
}

impl Default for FileRestoreDetails {
    fn default() -> Self {
        FileRestoreDetails {
        }
    }
}

const FILE_RESTORE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileRestoreDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRestoreDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_RESTORE_DETAILS_FIELDS));
        }
        Ok(FileRestoreDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRestoreDetails", FILE_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRestoreDetails", 0)?.end()
    }
}

/// Reverted files to a previous version.
#[derive(Debug)]
pub struct FileRevertDetails {
}

impl Default for FileRevertDetails {
    fn default() -> Self {
        FileRevertDetails {
        }
    }
}

const FILE_REVERT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileRevertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRevertDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REVERT_DETAILS_FIELDS));
        }
        Ok(FileRevertDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRevertDetails", FILE_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRevertDetails", 0)?.end()
    }
}

/// Rolled back file change location changes.
#[derive(Debug)]
pub struct FileRollbackChangesDetails {
}

impl Default for FileRollbackChangesDetails {
    fn default() -> Self {
        FileRollbackChangesDetails {
        }
    }
}

const FILE_ROLLBACK_CHANGES_DETAILS_FIELDS: &'static [&'static str] = &[];
impl FileRollbackChangesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileRollbackChangesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_ROLLBACK_CHANGES_DETAILS_FIELDS));
        }
        Ok(FileRollbackChangesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRollbackChangesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRollbackChangesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRollbackChangesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRollbackChangesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRollbackChangesDetails", FILE_ROLLBACK_CHANGES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRollbackChangesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRollbackChangesDetails", 0)?.end()
    }
}

/// Save a file or folder using a copy reference.
#[derive(Debug)]
pub struct FileSaveCopyReferenceDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileSaveCopyReferenceDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileSaveCopyReferenceDetails {
            relocate_action_details,
        }
    }

}

const FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS: &'static [&'static str] = &["relocate_action_details"];
impl FileSaveCopyReferenceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileSaveCopyReferenceDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS))
            }
        }
        Ok(FileSaveCopyReferenceDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileSaveCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileSaveCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileSaveCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileSaveCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileSaveCopyReferenceDetails", FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileSaveCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileSaveCopyReferenceDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unliked a file comment.
#[derive(Debug)]
pub struct FileUnlikeCommentDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl FileUnlikeCommentDetails {
    pub fn new(target_index: i64) -> Self {
        FileUnlikeCommentDetails {
            target_index,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const FILE_UNLIKE_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                      "comment_text"];
impl FileUnlikeCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileUnlikeCommentDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_UNLIKE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileUnlikeCommentDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnlikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnlikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileUnlikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnlikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnlikeCommentDetails", FILE_UNLIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnlikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnlikeCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Folder's logged information.
#[derive(Debug)]
pub struct FolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FolderLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FOLDER_LOG_INFO_FIELDS: &'static [&'static str] = &["path",
                                                          "display_name",
                                                          "file_id"];
impl FolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FolderLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(FolderLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderLogInfo", FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Geographic location details.
#[derive(Debug)]
pub struct GeoLocationLogInfo {
    /// IP address.
    pub ip_address: IpAddress,
    /// City name.
    pub city: Option<String>,
    /// Region name.
    pub region: Option<String>,
    /// Country code.
    pub country: Option<String>,
}

impl GeoLocationLogInfo {
    pub fn new(ip_address: IpAddress) -> Self {
        GeoLocationLogInfo {
            ip_address,
            city: None,
            region: None,
            country: None,
        }
    }

    pub fn with_city(mut self, value: Option<String>) -> Self {
        self.city = value;
        self
    }

    pub fn with_region(mut self, value: Option<String>) -> Self {
        self.region = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

}

const GEO_LOCATION_LOG_INFO_FIELDS: &'static [&'static str] = &["ip_address",
                                                                "city",
                                                                "region",
                                                                "country"];
impl GeoLocationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GeoLocationLogInfo, V::Error> {
        use serde::de;
        let mut field_ip_address = None;
        let mut field_city = None;
        let mut field_region = None;
        let mut field_country = None;
        while let Some(key) = map.next_key()? {
            match key {
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "city" => {
                    if field_city.is_some() {
                        return Err(de::Error::duplicate_field("city"));
                    }
                    field_city = Some(map.next_value()?);
                }
                "region" => {
                    if field_region.is_some() {
                        return Err(de::Error::duplicate_field("region"));
                    }
                    field_region = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GEO_LOCATION_LOG_INFO_FIELDS))
            }
        }
        Ok(GeoLocationLogInfo {
            ip_address: field_ip_address.ok_or_else(|| de::Error::missing_field("ip_address"))?,
            city: field_city,
            region: field_region,
            country: field_country,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("city", &self.city)?;
        s.serialize_field("region", &self.region)?;
        s.serialize_field("country", &self.country)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GeoLocationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GeoLocationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GeoLocationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GeoLocationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GeoLocationLogInfo", GEO_LOCATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GeoLocationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GeoLocationLogInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsArg {
    /// Number of results to return per call.
    pub limit: u32,
    /// Filter the events by account ID. Return ony events with this account_id as either Actor,
    /// Context, or Participants.
    pub account_id: Option<super::users_common::AccountId>,
    /// Filter by time range.
    pub time: Option<super::team_common::TimeRange>,
    /// Filter the returned events to a single category.
    pub category: Option<EventCategory>,
}

impl Default for GetTeamEventsArg {
    fn default() -> Self {
        GetTeamEventsArg {
            limit: 1000,
            account_id: None,
            time: None,
            category: None,
        }
    }
}

const GET_TEAM_EVENTS_ARG_FIELDS: &'static [&'static str] = &["limit",
                                                              "account_id",
                                                              "time",
                                                              "category"];
impl GetTeamEventsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetTeamEventsArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        let mut field_account_id = None;
        let mut field_time = None;
        let mut field_category = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "time" => {
                    if field_time.is_some() {
                        return Err(de::Error::duplicate_field("time"));
                    }
                    field_time = Some(map.next_value()?);
                }
                "category" => {
                    if field_category.is_some() {
                        return Err(de::Error::duplicate_field("category"));
                    }
                    field_category = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_ARG_FIELDS))
            }
        }
        Ok(GetTeamEventsArg {
            limit: field_limit.unwrap_or(1000),
            account_id: field_account_id,
            time: field_time,
            category: field_category,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("time", &self.time)?;
        s.serialize_field("category", &self.category)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsArg", GET_TEAM_EVENTS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsContinueArg {
    /// Indicates from what point to get the next set of events.
    pub cursor: String,
}

impl GetTeamEventsContinueArg {
    pub fn new(cursor: String) -> Self {
        GetTeamEventsContinueArg {
            cursor,
        }
    }

}

const GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS: &'static [&'static str] = &["cursor"];
impl GetTeamEventsContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetTeamEventsContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(GetTeamEventsContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsContinueArg", GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors that can be raised when calling :route:`get_events/continue`.
#[derive(Debug)]
pub enum GetTeamEventsContinueError {
    /// Bad cursor.
    BadCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "bad_cursor" => Ok(GetTeamEventsContinueError::BadCursor),
                    _ => Ok(GetTeamEventsContinueError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["bad_cursor",
                                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsContinueError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsContinueError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            GetTeamEventsContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsContinueError {
    fn description(&self) -> &str {
        "GetTeamEventsContinueError"
    }
}

impl ::std::fmt::Display for GetTeamEventsContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Errors that can be raised when calling :route:`get_events`.
#[derive(Debug)]
pub enum GetTeamEventsError {
    /// No user found matching the provided account_id.
    AccountIdNotFound,
    /// Invalid time range.
    InvalidTimeRange,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "account_id_not_found" => Ok(GetTeamEventsError::AccountIdNotFound),
                    "invalid_time_range" => Ok(GetTeamEventsError::InvalidTimeRange),
                    _ => Ok(GetTeamEventsError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["account_id_not_found",
                                                    "invalid_time_range",
                                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsError::AccountIdNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "account_id_not_found")?;
                s.end()
            }
            GetTeamEventsError::InvalidTimeRange => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "invalid_time_range")?;
                s.end()
            }
            GetTeamEventsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsError {
    fn description(&self) -> &str {
        "GetTeamEventsError"
    }
}

impl ::std::fmt::Display for GetTeamEventsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GetTeamEventsResult {
    /// List of events.
    pub events: Vec<TeamEvent>,
    /// Pass the cursor into :route:`get_events/continue` to obtain additional events.
    pub cursor: String,
    /// Is true if there are additional events that have not been returned yet. An additional call
    /// to :route:`get_events/continue` can retrieve them.
    pub has_more: bool,
}

impl GetTeamEventsResult {
    pub fn new(events: Vec<TeamEvent>, cursor: String, has_more: bool) -> Self {
        GetTeamEventsResult {
            events,
            cursor,
            has_more,
        }
    }

}

const GET_TEAM_EVENTS_RESULT_FIELDS: &'static [&'static str] = &["events",
                                                                 "cursor",
                                                                 "has_more"];
impl GetTeamEventsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetTeamEventsResult, V::Error> {
        use serde::de;
        let mut field_events = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        while let Some(key) = map.next_key()? {
            match key {
                "events" => {
                    if field_events.is_some() {
                        return Err(de::Error::duplicate_field("events"));
                    }
                    field_events = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_RESULT_FIELDS))
            }
        }
        Ok(GetTeamEventsResult {
            events: field_events.ok_or_else(|| de::Error::missing_field("events"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("events", &self.events)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsResult", GET_TEAM_EVENTS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled Google single sign-on for the team.
#[derive(Debug)]
pub struct GoogleSsoChangePolicyDetails {
    /// New Google single sign-on policy.
    pub new_value: GoogleSsoPolicy,
    /// Previous Google single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<GoogleSsoPolicy>,
}

impl GoogleSsoChangePolicyDetails {
    pub fn new(new_value: GoogleSsoPolicy) -> Self {
        GoogleSsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<GoogleSsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                           "previous_value"];
impl GoogleSsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GoogleSsoChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(GoogleSsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GoogleSsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GoogleSsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GoogleSsoChangePolicyDetails", GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GoogleSsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Google SSO policy
#[derive(Debug)]
pub enum GoogleSsoPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GoogleSsoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(GoogleSsoPolicy::Disabled),
                    "enabled" => Ok(GoogleSsoPolicy::Enabled),
                    _ => Ok(GoogleSsoPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("GoogleSsoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GoogleSsoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            GoogleSsoPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            GoogleSsoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added an external ID for group.
#[derive(Debug)]
pub struct GroupAddExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
}

impl GroupAddExternalIdDetails {
    pub fn new(new_value: super::team_common::GroupExternalId) -> Self {
        GroupAddExternalIdDetails {
            new_value,
        }
    }

}

const GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS: &'static [&'static str] = &["new_value"];
impl GroupAddExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupAddExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupAddExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddExternalIdDetails", GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added team members to a group.
#[derive(Debug)]
pub struct GroupAddMemberDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupAddMemberDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupAddMemberDetails {
            is_group_owner,
        }
    }

}

const GROUP_ADD_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &["is_group_owner"];
impl GroupAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_is_group_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(GroupAddMemberDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| de::Error::missing_field("is_group_owner"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddMemberDetails", GROUP_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the external ID for group.
#[derive(Debug)]
pub struct GroupChangeExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupChangeExternalIdDetails {
    pub fn new(new_value: super::team_common::GroupExternalId, previous_value: super::team_common::GroupExternalId) -> Self {
        GroupChangeExternalIdDetails {
            new_value,
            previous_value,
        }
    }

}

const GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                           "previous_value"];
impl GroupChangeExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupChangeExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeExternalIdDetails", GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeExternalIdDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed group management type.
#[derive(Debug)]
pub struct GroupChangeManagementTypeDetails {
    /// New group management type.
    pub new_value: GroupManagementType,
    /// Previous group management type. Might be missing due to historical data gap.
    pub previous_value: Option<GroupManagementType>,
}

impl GroupChangeManagementTypeDetails {
    pub fn new(new_value: GroupManagementType) -> Self {
        GroupChangeManagementTypeDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<GroupManagementType>) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                               "previous_value"];
impl GroupChangeManagementTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupChangeManagementTypeDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeManagementTypeDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeManagementTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeManagementTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeManagementTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeManagementTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeManagementTypeDetails", GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeManagementTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeManagementTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the manager permissions belonging to a group member.
#[derive(Debug)]
pub struct GroupChangeMemberRoleDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupChangeMemberRoleDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupChangeMemberRoleDetails {
            is_group_owner,
        }
    }

}

const GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["is_group_owner"];
impl GroupChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_is_group_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeMemberRoleDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| de::Error::missing_field("is_group_owner"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeMemberRoleDetails", GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeMemberRoleDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a group.
#[derive(Debug)]
pub struct GroupCreateDetails {
    /// Group join policy.
    pub join_policy: GroupJoinPolicy,
    /// Is admin managed group. Might be missing due to historical data gap.
    pub is_admin_managed: Option<bool>,
}

impl GroupCreateDetails {
    pub fn new(join_policy: GroupJoinPolicy) -> Self {
        GroupCreateDetails {
            join_policy,
            is_admin_managed: None,
        }
    }

    pub fn with_is_admin_managed(mut self, value: Option<bool>) -> Self {
        self.is_admin_managed = value;
        self
    }

}

const GROUP_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["join_policy",
                                                               "is_admin_managed"];
impl GroupCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupCreateDetails, V::Error> {
        use serde::de;
        let mut field_join_policy = None;
        let mut field_is_admin_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "join_policy" => {
                    if field_join_policy.is_some() {
                        return Err(de::Error::duplicate_field("join_policy"));
                    }
                    field_join_policy = Some(map.next_value()?);
                }
                "is_admin_managed" => {
                    if field_is_admin_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_admin_managed"));
                    }
                    field_is_admin_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(GroupCreateDetails {
            join_policy: field_join_policy.ok_or_else(|| de::Error::missing_field("join_policy"))?,
            is_admin_managed: field_is_admin_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("join_policy", &self.join_policy)?;
        s.serialize_field("is_admin_managed", &self.is_admin_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateDetails", GROUP_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a group.
#[derive(Debug)]
pub struct GroupDeleteDetails {
    /// Is admin managed group. Might be missing due to historical data gap.
    pub is_admin_managed: Option<bool>,
}

impl Default for GroupDeleteDetails {
    fn default() -> Self {
        GroupDeleteDetails {
            is_admin_managed: None,
        }
    }
}

const GROUP_DELETE_DETAILS_FIELDS: &'static [&'static str] = &["is_admin_managed"];
impl GroupDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupDeleteDetails, V::Error> {
        use serde::de;
        let mut field_is_admin_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_admin_managed" => {
                    if field_is_admin_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_admin_managed"));
                    }
                    field_is_admin_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_DELETE_DETAILS_FIELDS))
            }
        }
        Ok(GroupDeleteDetails {
            is_admin_managed: field_is_admin_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_admin_managed", &self.is_admin_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDeleteDetails", GROUP_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Updated a group.
#[derive(Debug)]
pub struct GroupDescriptionUpdatedDetails {
}

impl Default for GroupDescriptionUpdatedDetails {
    fn default() -> Self {
        GroupDescriptionUpdatedDetails {
        }
    }
}

const GROUP_DESCRIPTION_UPDATED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl GroupDescriptionUpdatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupDescriptionUpdatedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, GROUP_DESCRIPTION_UPDATED_DETAILS_FIELDS));
        }
        Ok(GroupDescriptionUpdatedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDescriptionUpdatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDescriptionUpdatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupDescriptionUpdatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDescriptionUpdatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDescriptionUpdatedDetails", GROUP_DESCRIPTION_UPDATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDescriptionUpdatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupDescriptionUpdatedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub enum GroupJoinPolicy {
    Open,
    RequestToJoin,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "open" => Ok(GroupJoinPolicy::Open),
                    "request_to_join" => Ok(GroupJoinPolicy::RequestToJoin),
                    _ => Ok(GroupJoinPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["open",
                                                    "request_to_join",
                                                    "other"];
        deserializer.deserialize_struct("GroupJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupJoinPolicy::Open => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "open")?;
                s.end()
            }
            GroupJoinPolicy::RequestToJoin => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "request_to_join")?;
                s.end()
            }
            GroupJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Updated a group join policy.
#[derive(Debug)]
pub struct GroupJoinPolicyUpdatedDetails {
    /// Group join policy.
    pub join_policy: GroupJoinPolicy,
    /// Is admin managed group. Might be missing due to historical data gap.
    pub is_admin_managed: Option<bool>,
}

impl GroupJoinPolicyUpdatedDetails {
    pub fn new(join_policy: GroupJoinPolicy) -> Self {
        GroupJoinPolicyUpdatedDetails {
            join_policy,
            is_admin_managed: None,
        }
    }

    pub fn with_is_admin_managed(mut self, value: Option<bool>) -> Self {
        self.is_admin_managed = value;
        self
    }

}

const GROUP_JOIN_POLICY_UPDATED_DETAILS_FIELDS: &'static [&'static str] = &["join_policy",
                                                                            "is_admin_managed"];
impl GroupJoinPolicyUpdatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupJoinPolicyUpdatedDetails, V::Error> {
        use serde::de;
        let mut field_join_policy = None;
        let mut field_is_admin_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "join_policy" => {
                    if field_join_policy.is_some() {
                        return Err(de::Error::duplicate_field("join_policy"));
                    }
                    field_join_policy = Some(map.next_value()?);
                }
                "is_admin_managed" => {
                    if field_is_admin_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_admin_managed"));
                    }
                    field_is_admin_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_JOIN_POLICY_UPDATED_DETAILS_FIELDS))
            }
        }
        Ok(GroupJoinPolicyUpdatedDetails {
            join_policy: field_join_policy.ok_or_else(|| de::Error::missing_field("join_policy"))?,
            is_admin_managed: field_is_admin_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("join_policy", &self.join_policy)?;
        s.serialize_field("is_admin_managed", &self.is_admin_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicyUpdatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupJoinPolicyUpdatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicyUpdatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupJoinPolicyUpdatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupJoinPolicyUpdatedDetails", GROUP_JOIN_POLICY_UPDATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicyUpdatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupJoinPolicyUpdatedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Group's logged information.
#[derive(Debug)]
pub struct GroupLogInfo {
    /// The name of this group.
    pub display_name: String,
    /// The unique id of this group. Might be missing due to historical data gap.
    pub group_id: Option<super::team_common::GroupId>,
    /// External group ID. Might be missing due to historical data gap.
    pub external_id: Option<super::team_common::GroupExternalId>,
}

impl GroupLogInfo {
    pub fn new(display_name: String) -> Self {
        GroupLogInfo {
            display_name,
            group_id: None,
            external_id: None,
        }
    }

    pub fn with_group_id(mut self, value: Option<super::team_common::GroupId>) -> Self {
        self.group_id = value;
        self
    }

    pub fn with_external_id(mut self, value: Option<super::team_common::GroupExternalId>) -> Self {
        self.external_id = value;
        self
    }

}

const GROUP_LOG_INFO_FIELDS: &'static [&'static str] = &["display_name",
                                                         "group_id",
                                                         "external_id"];
impl GroupLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupLogInfo, V::Error> {
        use serde::de;
        let mut field_display_name = None;
        let mut field_group_id = None;
        let mut field_external_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "group_id" => {
                    if field_group_id.is_some() {
                        return Err(de::Error::duplicate_field("group_id"));
                    }
                    field_group_id = Some(map.next_value()?);
                }
                "external_id" => {
                    if field_external_id.is_some() {
                        return Err(de::Error::duplicate_field("external_id"));
                    }
                    field_external_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_LOG_INFO_FIELDS))
            }
        }
        Ok(GroupLogInfo {
            display_name: field_display_name.ok_or_else(|| de::Error::missing_field("display_name"))?,
            group_id: field_group_id,
            external_id: field_external_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("group_id", &self.group_id)?;
        s.serialize_field("external_id", &self.external_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupLogInfo", GROUP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupManagementType {
    AdminManagementGroup,
    MemberManagementGroup,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupManagementType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupManagementType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupManagementType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "admin_management_group" => Ok(GroupManagementType::AdminManagementGroup),
                    "member_management_group" => Ok(GroupManagementType::MemberManagementGroup),
                    _ => Ok(GroupManagementType::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["admin_management_group",
                                                    "member_management_group",
                                                    "other"];
        deserializer.deserialize_struct("GroupManagementType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupManagementType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupManagementType::AdminManagementGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupManagementType", 1)?;
                s.serialize_field(".tag", "admin_management_group")?;
                s.end()
            }
            GroupManagementType::MemberManagementGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupManagementType", 1)?;
                s.serialize_field(".tag", "member_management_group")?;
                s.end()
            }
            GroupManagementType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Moved a group.
#[derive(Debug)]
pub struct GroupMovedDetails {
}

impl Default for GroupMovedDetails {
    fn default() -> Self {
        GroupMovedDetails {
        }
    }
}

const GROUP_MOVED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl GroupMovedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupMovedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, GROUP_MOVED_DETAILS_FIELDS));
        }
        Ok(GroupMovedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMovedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMovedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMovedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMovedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMovedDetails", GROUP_MOVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMovedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupMovedDetails", 0)?.end()
    }
}

/// Removed the external ID for group.
#[derive(Debug)]
pub struct GroupRemoveExternalIdDetails {
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupRemoveExternalIdDetails {
    pub fn new(previous_value: super::team_common::GroupExternalId) -> Self {
        GroupRemoveExternalIdDetails {
            previous_value,
        }
    }

}

const GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS: &'static [&'static str] = &["previous_value"];
impl GroupRemoveExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupRemoveExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupRemoveExternalIdDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveExternalIdDetails", GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed team members from a group.
#[derive(Debug)]
pub struct GroupRemoveMemberDetails {
}

impl Default for GroupRemoveMemberDetails {
    fn default() -> Self {
        GroupRemoveMemberDetails {
        }
    }
}

const GROUP_REMOVE_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &[];
impl GroupRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupRemoveMemberDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, GROUP_REMOVE_MEMBER_DETAILS_FIELDS));
        }
        Ok(GroupRemoveMemberDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveMemberDetails", GROUP_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupRemoveMemberDetails", 0)?.end()
    }
}

/// Renamed a group.
#[derive(Debug)]
pub struct GroupRenameDetails {
    /// Previous display name.
    pub previous_value: String,
}

impl GroupRenameDetails {
    pub fn new(previous_value: String) -> Self {
        GroupRenameDetails {
            previous_value,
        }
    }

}

const GROUP_RENAME_DETAILS_FIELDS: &'static [&'static str] = &["previous_value"];
impl GroupRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupRenameDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(GroupRenameDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRenameDetails", GROUP_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can create groups.
#[derive(Debug)]
pub struct GroupUserManagementChangePolicyDetails {
    /// New group users management policy.
    pub new_value: GroupUserManagementPolicy,
    /// Previous group users management policy. Might be missing due to historical data gap.
    pub previous_value: Option<GroupUserManagementPolicy>,
}

impl GroupUserManagementChangePolicyDetails {
    pub fn new(new_value: GroupUserManagementPolicy) -> Self {
        GroupUserManagementChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<GroupUserManagementPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                      "previous_value"];
impl GroupUserManagementChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupUserManagementChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(GroupUserManagementChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUserManagementChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUserManagementChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUserManagementChangePolicyDetails", GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUserManagementChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupUserManagementPolicy {
    AllUsers,
    OnlyAdmins,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupUserManagementPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "all_users" => Ok(GroupUserManagementPolicy::AllUsers),
                    "only_admins" => Ok(GroupUserManagementPolicy::OnlyAdmins),
                    _ => Ok(GroupUserManagementPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["all_users",
                                                    "only_admins",
                                                    "other"];
        deserializer.deserialize_struct("GroupUserManagementPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupUserManagementPolicy::AllUsers => {
                // unit
                let mut s = serializer.serialize_struct("GroupUserManagementPolicy", 1)?;
                s.serialize_field(".tag", "all_users")?;
                s.end()
            }
            GroupUserManagementPolicy::OnlyAdmins => {
                // unit
                let mut s = serializer.serialize_struct("GroupUserManagementPolicy", 1)?;
                s.serialize_field(".tag", "only_admins")?;
                s.end()
            }
            GroupUserManagementPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Host details.
#[derive(Debug)]
pub struct HostLogInfo {
    /// Host ID. Might be missing due to historical data gap.
    pub host_id: Option<u64>,
    /// Host name. Might be missing due to historical data gap.
    pub host_name: Option<String>,
}

impl Default for HostLogInfo {
    fn default() -> Self {
        HostLogInfo {
            host_id: None,
            host_name: None,
        }
    }
}

const HOST_LOG_INFO_FIELDS: &'static [&'static str] = &["host_id",
                                                        "host_name"];
impl HostLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<HostLogInfo, V::Error> {
        use serde::de;
        let mut field_host_id = None;
        let mut field_host_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "host_id" => {
                    if field_host_id.is_some() {
                        return Err(de::Error::duplicate_field("host_id"));
                    }
                    field_host_id = Some(map.next_value()?);
                }
                "host_name" => {
                    if field_host_name.is_some() {
                        return Err(de::Error::duplicate_field("host_name"));
                    }
                    field_host_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, HOST_LOG_INFO_FIELDS))
            }
        }
        Ok(HostLogInfo {
            host_id: field_host_id,
            host_name: field_host_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("host_id", &self.host_id)?;
        s.serialize_field("host_name", &self.host_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for HostLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = HostLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a HostLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                HostLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("HostLogInfo", HOST_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for HostLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("HostLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Additional information relevant when a new member joins the team.
#[derive(Debug)]
pub struct JoinTeamDetails {
    /// Linked applications.
    pub linked_apps: Vec<AppLogInfo>,
    /// Linked devices.
    pub linked_devices: Vec<DeviceLogInfo>,
    /// Linked shared folders.
    pub linked_shared_folders: Vec<FolderLogInfo>,
}

impl JoinTeamDetails {
    pub fn new(linked_apps: Vec<AppLogInfo>, linked_devices: Vec<DeviceLogInfo>, linked_shared_folders: Vec<FolderLogInfo>) -> Self {
        JoinTeamDetails {
            linked_apps,
            linked_devices,
            linked_shared_folders,
        }
    }

}

const JOIN_TEAM_DETAILS_FIELDS: &'static [&'static str] = &["linked_apps",
                                                            "linked_devices",
                                                            "linked_shared_folders"];
impl JoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<JoinTeamDetails, V::Error> {
        use serde::de;
        let mut field_linked_apps = None;
        let mut field_linked_devices = None;
        let mut field_linked_shared_folders = None;
        while let Some(key) = map.next_key()? {
            match key {
                "linked_apps" => {
                    if field_linked_apps.is_some() {
                        return Err(de::Error::duplicate_field("linked_apps"));
                    }
                    field_linked_apps = Some(map.next_value()?);
                }
                "linked_devices" => {
                    if field_linked_devices.is_some() {
                        return Err(de::Error::duplicate_field("linked_devices"));
                    }
                    field_linked_devices = Some(map.next_value()?);
                }
                "linked_shared_folders" => {
                    if field_linked_shared_folders.is_some() {
                        return Err(de::Error::duplicate_field("linked_shared_folders"));
                    }
                    field_linked_shared_folders = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, JOIN_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(JoinTeamDetails {
            linked_apps: field_linked_apps.ok_or_else(|| de::Error::missing_field("linked_apps"))?,
            linked_devices: field_linked_devices.ok_or_else(|| de::Error::missing_field("linked_devices"))?,
            linked_shared_folders: field_linked_shared_folders.ok_or_else(|| de::Error::missing_field("linked_shared_folders"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("linked_apps", &self.linked_apps)?;
        s.serialize_field("linked_devices", &self.linked_devices)?;
        s.serialize_field("linked_shared_folders", &self.linked_shared_folders)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for JoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = JoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a JoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                JoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("JoinTeamDetails", JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for JoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("JoinTeamDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum LinkAudience {
    Public,
    Team,
    Members,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkAudience {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkAudience;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkAudience structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "public" => Ok(LinkAudience::Public),
                    "team" => Ok(LinkAudience::Team),
                    "members" => Ok(LinkAudience::Members),
                    _ => Ok(LinkAudience::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["public",
                                                    "team",
                                                    "members",
                                                    "other"];
        deserializer.deserialize_struct("LinkAudience", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkAudience {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkAudience::Public => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            LinkAudience::Team => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            LinkAudience::Members => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            LinkAudience::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Signed out.
#[derive(Debug)]
pub struct LogoutDetails {
}

impl Default for LogoutDetails {
    fn default() -> Self {
        LogoutDetails {
        }
    }
}

const LOGOUT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl LogoutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<LogoutDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, LOGOUT_DETAILS_FIELDS));
        }
        Ok(LogoutDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LogoutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LogoutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LogoutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LogoutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LogoutDetails", LOGOUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LogoutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("LogoutDetails", 0)?.end()
    }
}

/// Set team member name when joining team.
#[derive(Debug)]
pub struct MemberAddNameDetails {
    /// User's name.
    pub value: UserNameLogInfo,
}

impl MemberAddNameDetails {
    pub fn new(value: UserNameLogInfo) -> Self {
        MemberAddNameDetails {
            value,
        }
    }

}

const MEMBER_ADD_NAME_DETAILS_FIELDS: &'static [&'static str] = &["value"];
impl MemberAddNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberAddNameDetails, V::Error> {
        use serde::de;
        let mut field_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "value" => {
                    if field_value.is_some() {
                        return Err(de::Error::duplicate_field("value"));
                    }
                    field_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ADD_NAME_DETAILS_FIELDS))
            }
        }
        Ok(MemberAddNameDetails {
            value: field_value.ok_or_else(|| de::Error::missing_field("value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("value", &self.value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAddNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddNameDetails", MEMBER_ADD_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddNameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the admin role belonging to team member.
#[derive(Debug)]
pub struct MemberChangeAdminRoleDetails {
    /// New admin role. This field is relevant when the admin role is changed or whenthe user role
    /// changes from no admin rights to with admin rights.
    pub new_value: Option<AdminRole>,
    /// Previous admin role. This field is relevant when the admin role is changed or when the admin
    /// role is removed.
    pub previous_value: Option<AdminRole>,
}

impl Default for MemberChangeAdminRoleDetails {
    fn default() -> Self {
        MemberChangeAdminRoleDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                           "previous_value"];
impl MemberChangeAdminRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberChangeAdminRoleDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeAdminRoleDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeAdminRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeAdminRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeAdminRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeAdminRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeAdminRoleDetails", MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeAdminRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeAdminRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member email address.
#[derive(Debug)]
pub struct MemberChangeEmailDetails {
    /// New email.
    pub new_value: super::common::EmailAddress,
    /// Previous email. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::EmailAddress>,
}

impl MemberChangeEmailDetails {
    pub fn new(new_value: super::common::EmailAddress) -> Self {
        MemberChangeEmailDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::common::EmailAddress>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_CHANGE_EMAIL_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                      "previous_value"];
impl MemberChangeEmailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberChangeEmailDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_EMAIL_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeEmailDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeEmailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeEmailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeEmailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeEmailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeEmailDetails", MEMBER_CHANGE_EMAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeEmailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeEmailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the membership type (limited vs full) for team member.
#[derive(Debug)]
pub struct MemberChangeMembershipTypeDetails {
    /// Previous membership type.
    pub prev_value: TeamMembershipType,
    /// New membership type.
    pub new_value: TeamMembershipType,
}

impl MemberChangeMembershipTypeDetails {
    pub fn new(prev_value: TeamMembershipType, new_value: TeamMembershipType) -> Self {
        MemberChangeMembershipTypeDetails {
            prev_value,
            new_value,
        }
    }

}

const MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS: &'static [&'static str] = &["prev_value",
                                                                                "new_value"];
impl MemberChangeMembershipTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberChangeMembershipTypeDetails, V::Error> {
        use serde::de;
        let mut field_prev_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "prev_value" => {
                    if field_prev_value.is_some() {
                        return Err(de::Error::duplicate_field("prev_value"));
                    }
                    field_prev_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeMembershipTypeDetails {
            prev_value: field_prev_value.ok_or_else(|| de::Error::missing_field("prev_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("prev_value", &self.prev_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeMembershipTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeMembershipTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeMembershipTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeMembershipTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeMembershipTypeDetails", MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeMembershipTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeMembershipTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member name.
#[derive(Debug)]
pub struct MemberChangeNameDetails {
    /// New user's name.
    pub new_value: UserNameLogInfo,
    /// Previous user's name.
    pub previous_value: UserNameLogInfo,
}

impl MemberChangeNameDetails {
    pub fn new(new_value: UserNameLogInfo, previous_value: UserNameLogInfo) -> Self {
        MemberChangeNameDetails {
            new_value,
            previous_value,
        }
    }

}

const MEMBER_CHANGE_NAME_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                     "previous_value"];
impl MemberChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberChangeNameDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_NAME_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeNameDetails", MEMBER_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the membership status of a team member.
#[derive(Debug)]
pub struct MemberChangeStatusDetails {
    /// New member status.
    pub new_value: MemberStatus,
    /// Previous member status. Might be missing due to historical data gap.
    pub previous_value: Option<MemberStatus>,
    /// Additional information relevant when a new member joins the team.
    pub team_join_details: Option<JoinTeamDetails>,
}

impl MemberChangeStatusDetails {
    pub fn new(new_value: MemberStatus) -> Self {
        MemberChangeStatusDetails {
            new_value,
            previous_value: None,
            team_join_details: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberStatus>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_team_join_details(mut self, value: Option<JoinTeamDetails>) -> Self {
        self.team_join_details = value;
        self
    }

}

const MEMBER_CHANGE_STATUS_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                       "previous_value",
                                                                       "team_join_details"];
impl MemberChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_team_join_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "team_join_details" => {
                    if field_team_join_details.is_some() {
                        return Err(de::Error::duplicate_field("team_join_details"));
                    }
                    field_team_join_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            team_join_details: field_team_join_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("team_join_details", &self.team_join_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeStatusDetails", MEMBER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted contents of a removed team member account.
#[derive(Debug)]
pub struct MemberPermanentlyDeleteAccountContentsDetails {
}

impl Default for MemberPermanentlyDeleteAccountContentsDetails {
    fn default() -> Self {
        MemberPermanentlyDeleteAccountContentsDetails {
        }
    }
}

const MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS: &'static [&'static str] = &[];
impl MemberPermanentlyDeleteAccountContentsDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberPermanentlyDeleteAccountContentsDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS));
        }
        Ok(MemberPermanentlyDeleteAccountContentsDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermanentlyDeleteAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermanentlyDeleteAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberPermanentlyDeleteAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermanentlyDeleteAccountContentsDetails", MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermanentlyDeleteAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberPermanentlyDeleteAccountContentsDetails", 0)?.end()
    }
}

/// Changed whether users can find the team when not invited.
#[derive(Debug)]
pub struct MemberRequestsChangePolicyDetails {
    /// New member change requests policy.
    pub new_value: MemberRequestsPolicy,
    /// Previous member change requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberRequestsPolicy>,
}

impl MemberRequestsChangePolicyDetails {
    pub fn new(new_value: MemberRequestsPolicy) -> Self {
        MemberRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                "previous_value"];
impl MemberRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberRequestsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRequestsChangePolicyDetails", MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberRequestsPolicy {
    Disabled,
    RequireApproval,
    AutoApproval,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(MemberRequestsPolicy::Disabled),
                    "require_approval" => Ok(MemberRequestsPolicy::RequireApproval),
                    "auto_approval" => Ok(MemberRequestsPolicy::AutoApproval),
                    _ => Ok(MemberRequestsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "require_approval",
                                                    "auto_approval",
                                                    "other"];
        deserializer.deserialize_struct("MemberRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberRequestsPolicy::RequireApproval => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "require_approval")?;
                s.end()
            }
            MemberRequestsPolicy::AutoApproval => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "auto_approval")?;
                s.end()
            }
            MemberRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added an exception for one or more team members to bypass space limits imposed by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsAddExceptionDetails {
}

impl Default for MemberSpaceLimitsAddExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsAddExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl MemberSpaceLimitsAddExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSpaceLimitsAddExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(MemberSpaceLimitsAddExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddExceptionDetails", MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsAddExceptionDetails", 0)?.end()
    }
}

/// Changed the storage limits applied to team members by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangePolicyDetails {
    /// Previous storage limits policy.
    pub previous_value: SpaceLimitsLevel,
    /// New storage limits policy.
    pub new_value: SpaceLimitsLevel,
}

impl MemberSpaceLimitsChangePolicyDetails {
    pub fn new(previous_value: SpaceLimitsLevel, new_value: SpaceLimitsLevel) -> Self {
        MemberSpaceLimitsChangePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                                    "new_value"];
impl MemberSpaceLimitsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSpaceLimitsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangePolicyDetails", MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the status with respect to whether the team member is under or over storage quota
/// specified by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeStatusDetails {
    /// Previous storage quota status.
    pub previous_value: SpaceLimitsStatus,
    /// New storage quota status.
    pub new_value: SpaceLimitsStatus,
}

impl MemberSpaceLimitsChangeStatusDetails {
    pub fn new(previous_value: SpaceLimitsStatus, new_value: SpaceLimitsStatus) -> Self {
        MemberSpaceLimitsChangeStatusDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                                    "new_value"];
impl MemberSpaceLimitsChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSpaceLimitsChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeStatusDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeStatusDetails", MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed an exception for one or more team members to bypass space limits imposed by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveExceptionDetails {
}

impl Default for MemberSpaceLimitsRemoveExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsRemoveExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl MemberSpaceLimitsRemoveExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSpaceLimitsRemoveExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(MemberSpaceLimitsRemoveExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveExceptionDetails", MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub enum MemberStatus {
    NotJoined,
    Invited,
    Active,
    Suspended,
    Removed,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "not_joined" => Ok(MemberStatus::NotJoined),
                    "invited" => Ok(MemberStatus::Invited),
                    "active" => Ok(MemberStatus::Active),
                    "suspended" => Ok(MemberStatus::Suspended),
                    "removed" => Ok(MemberStatus::Removed),
                    _ => Ok(MemberStatus::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["not_joined",
                                                    "invited",
                                                    "active",
                                                    "suspended",
                                                    "removed",
                                                    "other"];
        deserializer.deserialize_struct("MemberStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberStatus::NotJoined => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "not_joined")?;
                s.end()
            }
            MemberStatus::Invited => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            MemberStatus::Active => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            MemberStatus::Suspended => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "suspended")?;
                s.end()
            }
            MemberStatus::Removed => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "removed")?;
                s.end()
            }
            MemberStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Suggested a new team member to be added to the team.
#[derive(Debug)]
pub struct MemberSuggestDetails {
}

impl Default for MemberSuggestDetails {
    fn default() -> Self {
        MemberSuggestDetails {
        }
    }
}

const MEMBER_SUGGEST_DETAILS_FIELDS: &'static [&'static str] = &[];
impl MemberSuggestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSuggestDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SUGGEST_DETAILS_FIELDS));
        }
        Ok(MemberSuggestDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestDetails", MEMBER_SUGGEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSuggestDetails", 0)?.end()
    }
}

/// Enabled or disabled the option for team members to suggest new members to add to the team.
#[derive(Debug)]
pub struct MemberSuggestionsChangePolicyDetails {
    /// New team member suggestions policy.
    pub new_value: MemberSuggestionsPolicy,
    /// Previous team member suggestions policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberSuggestionsPolicy>,
}

impl MemberSuggestionsChangePolicyDetails {
    pub fn new(new_value: MemberSuggestionsPolicy) -> Self {
        MemberSuggestionsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberSuggestionsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                   "previous_value"];
impl MemberSuggestionsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberSuggestionsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberSuggestionsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestionsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestionsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestionsChangePolicyDetails", MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestionsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Member suggestions policy
#[derive(Debug)]
pub enum MemberSuggestionsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSuggestionsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(MemberSuggestionsPolicy::Disabled),
                    "enabled" => Ok(MemberSuggestionsPolicy::Enabled),
                    _ => Ok(MemberSuggestionsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("MemberSuggestionsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSuggestionsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Transferred contents of a removed team member account to another member.
#[derive(Debug)]
pub struct MemberTransferAccountContentsDetails {
    /// Source asset index.
    pub src_index: i64,
    /// Destination asset index.
    pub dest_index: i64,
}

impl MemberTransferAccountContentsDetails {
    pub fn new(src_index: i64, dest_index: i64) -> Self {
        MemberTransferAccountContentsDetails {
            src_index,
            dest_index,
        }
    }

}

const MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS: &'static [&'static str] = &["src_index",
                                                                                   "dest_index"];
impl MemberTransferAccountContentsDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberTransferAccountContentsDetails, V::Error> {
        use serde::de;
        let mut field_src_index = None;
        let mut field_dest_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "src_index" => {
                    if field_src_index.is_some() {
                        return Err(de::Error::duplicate_field("src_index"));
                    }
                    field_src_index = Some(map.next_value()?);
                }
                "dest_index" => {
                    if field_dest_index.is_some() {
                        return Err(de::Error::duplicate_field("dest_index"));
                    }
                    field_dest_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS))
            }
        }
        Ok(MemberTransferAccountContentsDetails {
            src_index: field_src_index.ok_or_else(|| de::Error::missing_field("src_index"))?,
            dest_index: field_dest_index.ok_or_else(|| de::Error::missing_field("dest_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("src_index", &self.src_index)?;
        s.serialize_field("dest_index", &self.dest_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberTransferAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberTransferAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberTransferAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberTransferAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberTransferAccountContentsDetails", MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberTransferAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberTransferAccountContentsDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled the Microsoft Office add-in, which lets team members save files to Dropbox
/// directly from Microsoft Office.
#[derive(Debug)]
pub struct MicrosoftOfficeAddinChangePolicyDetails {
    /// New Microsoft Office addin policy.
    pub new_value: MicrosoftOfficeAddinPolicy,
    /// Previous Microsoft Office addin policy. Might be missing due to historical data gap.
    pub previous_value: Option<MicrosoftOfficeAddinPolicy>,
}

impl MicrosoftOfficeAddinChangePolicyDetails {
    pub fn new(new_value: MicrosoftOfficeAddinPolicy) -> Self {
        MicrosoftOfficeAddinChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MicrosoftOfficeAddinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                       "previous_value"];
impl MicrosoftOfficeAddinChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MicrosoftOfficeAddinChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MicrosoftOfficeAddinChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MicrosoftOfficeAddinChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MicrosoftOfficeAddinChangePolicyDetails", MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MicrosoftOfficeAddinChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Microsoft Office addin policy
#[derive(Debug)]
pub enum MicrosoftOfficeAddinPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MicrosoftOfficeAddinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(MicrosoftOfficeAddinPolicy::Disabled),
                    "enabled" => Ok(MicrosoftOfficeAddinPolicy::Enabled),
                    _ => Ok(MicrosoftOfficeAddinPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("MicrosoftOfficeAddinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MicrosoftOfficeAddinPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// An indication that an event was returned with missing details
#[derive(Debug)]
pub struct MissingDetails {
}

impl Default for MissingDetails {
    fn default() -> Self {
        MissingDetails {
        }
    }
}

const MISSING_DETAILS_FIELDS: &'static [&'static str] = &[];
impl MissingDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MissingDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MISSING_DETAILS_FIELDS));
        }
        Ok(MissingDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MissingDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MissingDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MissingDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MissingDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MissingDetails", MISSING_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MissingDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MissingDetails", 0)?.end()
    }
}

/// Mobile session.
#[derive(Debug)]
pub struct MobileSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for MobileSessionLogInfo {
    fn default() -> Self {
        MobileSessionLogInfo {
            session_id: None,
        }
    }
}

const MOBILE_SESSION_LOG_INFO_FIELDS: &'static [&'static str] = &["session_id"];
impl MobileSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MobileSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MOBILE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(MobileSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MobileSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileSessionLogInfo", MOBILE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Namespace relative path details.
#[derive(Debug)]
pub struct NamespaceRelativePathLogInfo {
    /// Namespace ID. Might be missing due to historical data gap.
    pub ns_id: Option<super::common::NamespaceId>,
    /// A path relative to the specified namespace ID. Might be missing due to historical data gap.
    pub relative_path: Option<super::files::Path>,
}

impl Default for NamespaceRelativePathLogInfo {
    fn default() -> Self {
        NamespaceRelativePathLogInfo {
            ns_id: None,
            relative_path: None,
        }
    }
}

const NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS: &'static [&'static str] = &["ns_id",
                                                                           "relative_path"];
impl NamespaceRelativePathLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NamespaceRelativePathLogInfo, V::Error> {
        use serde::de;
        let mut field_ns_id = None;
        let mut field_relative_path = None;
        while let Some(key) = map.next_key()? {
            match key {
                "ns_id" => {
                    if field_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("ns_id"));
                    }
                    field_ns_id = Some(map.next_value()?);
                }
                "relative_path" => {
                    if field_relative_path.is_some() {
                        return Err(de::Error::duplicate_field("relative_path"));
                    }
                    field_relative_path = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS))
            }
        }
        Ok(NamespaceRelativePathLogInfo {
            ns_id: field_ns_id,
            relative_path: field_relative_path,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ns_id", &self.ns_id)?;
        s.serialize_field("relative_path", &self.relative_path)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NamespaceRelativePathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NamespaceRelativePathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NamespaceRelativePathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NamespaceRelativePathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NamespaceRelativePathLogInfo", NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NamespaceRelativePathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NamespaceRelativePathLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled network control.
#[derive(Debug)]
pub struct NetworkControlChangePolicyDetails {
    /// New network control policy.
    pub new_value: NetworkControlPolicy,
    /// Previous network control policy. Might be missing due to historical data gap.
    pub previous_value: Option<NetworkControlPolicy>,
}

impl NetworkControlChangePolicyDetails {
    pub fn new(new_value: NetworkControlPolicy) -> Self {
        NetworkControlChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<NetworkControlPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                "previous_value"];
impl NetworkControlChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NetworkControlChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(NetworkControlChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NetworkControlChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NetworkControlChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NetworkControlChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NetworkControlChangePolicyDetails", NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NetworkControlChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Network control policy
#[derive(Debug)]
pub enum NetworkControlPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = NetworkControlPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NetworkControlPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(NetworkControlPolicy::Disabled),
                    "enabled" => Ok(NetworkControlPolicy::Enabled),
                    _ => Ok(NetworkControlPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("NetworkControlPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            NetworkControlPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            NetworkControlPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            NetworkControlPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Non team member's logged information.
#[derive(Debug)]
pub struct NonTeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayName>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<super::common::EmailAddress>,
}

impl Default for NonTeamMemberLogInfo {
    fn default() -> Self {
        NonTeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
        }
    }
}

const NON_TEAM_MEMBER_LOG_INFO_FIELDS: &'static [&'static str] = &["account_id",
                                                                   "display_name",
                                                                   "email"];
impl NonTeamMemberLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NonTeamMemberLogInfo, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NON_TEAM_MEMBER_LOG_INFO_FIELDS))
            }
        }
        Ok(NonTeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NonTeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NonTeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NonTeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NonTeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NonTeamMemberLogInfo", NON_TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NonTeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NonTeamMemberLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a Paper document to be invite-only.
#[derive(Debug)]
pub struct NoteAclInviteOnlyDetails {
}

impl Default for NoteAclInviteOnlyDetails {
    fn default() -> Self {
        NoteAclInviteOnlyDetails {
        }
    }
}

const NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl NoteAclInviteOnlyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NoteAclInviteOnlyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS));
        }
        Ok(NoteAclInviteOnlyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclInviteOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclInviteOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclInviteOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclInviteOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclInviteOnlyDetails", NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclInviteOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclInviteOnlyDetails", 0)?.end()
    }
}

/// Changed a Paper document to be link accessible.
#[derive(Debug)]
pub struct NoteAclLinkDetails {
}

impl Default for NoteAclLinkDetails {
    fn default() -> Self {
        NoteAclLinkDetails {
        }
    }
}

const NOTE_ACL_LINK_DETAILS_FIELDS: &'static [&'static str] = &[];
impl NoteAclLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NoteAclLinkDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_LINK_DETAILS_FIELDS));
        }
        Ok(NoteAclLinkDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclLinkDetails", NOTE_ACL_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclLinkDetails", 0)?.end()
    }
}

/// Changed a Paper document to be link accessible for the team.
#[derive(Debug)]
pub struct NoteAclTeamLinkDetails {
}

impl Default for NoteAclTeamLinkDetails {
    fn default() -> Self {
        NoteAclTeamLinkDetails {
        }
    }
}

const NOTE_ACL_TEAM_LINK_DETAILS_FIELDS: &'static [&'static str] = &[];
impl NoteAclTeamLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NoteAclTeamLinkDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_TEAM_LINK_DETAILS_FIELDS));
        }
        Ok(NoteAclTeamLinkDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclTeamLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclTeamLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclTeamLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclTeamLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclTeamLinkDetails", NOTE_ACL_TEAM_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclTeamLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclTeamLinkDetails", 0)?.end()
    }
}

/// Shared Paper document received.
#[derive(Debug)]
pub struct NoteShareReceiveDetails {
}

impl Default for NoteShareReceiveDetails {
    fn default() -> Self {
        NoteShareReceiveDetails {
        }
    }
}

const NOTE_SHARE_RECEIVE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl NoteShareReceiveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NoteShareReceiveDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_SHARE_RECEIVE_DETAILS_FIELDS));
        }
        Ok(NoteShareReceiveDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteShareReceiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteShareReceiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteShareReceiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteShareReceiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteShareReceiveDetails", NOTE_SHARE_RECEIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteShareReceiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteShareReceiveDetails", 0)?.end()
    }
}

/// Shared a Paper doc.
#[derive(Debug)]
pub struct NoteSharedDetails {
}

impl Default for NoteSharedDetails {
    fn default() -> Self {
        NoteSharedDetails {
        }
    }
}

const NOTE_SHARED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl NoteSharedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<NoteSharedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_SHARED_DETAILS_FIELDS));
        }
        Ok(NoteSharedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteSharedDetails", NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteSharedDetails", 0)?.end()
    }
}

/// Opened a shared Paper doc.
#[derive(Debug)]
pub struct OpenNoteSharedDetails {
}

impl Default for OpenNoteSharedDetails {
    fn default() -> Self {
        OpenNoteSharedDetails {
        }
    }
}

const OPEN_NOTE_SHARED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl OpenNoteSharedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<OpenNoteSharedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, OPEN_NOTE_SHARED_DETAILS_FIELDS));
        }
        Ok(OpenNoteSharedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OpenNoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OpenNoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a OpenNoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OpenNoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OpenNoteSharedDetails", OPEN_NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OpenNoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("OpenNoteSharedDetails", 0)?.end()
    }
}

/// The origin from which the actor performed the action.
#[derive(Debug)]
pub struct OriginLogInfo {
    /// The method that was used to perform the action.
    pub access_method: AccessMethodLogInfo,
    /// Geographic location details.
    pub geo_location: Option<GeoLocationLogInfo>,
    /// Host details.
    pub host: Option<HostLogInfo>,
}

impl OriginLogInfo {
    pub fn new(access_method: AccessMethodLogInfo) -> Self {
        OriginLogInfo {
            access_method,
            geo_location: None,
            host: None,
        }
    }

    pub fn with_geo_location(mut self, value: Option<GeoLocationLogInfo>) -> Self {
        self.geo_location = value;
        self
    }

    pub fn with_host(mut self, value: Option<HostLogInfo>) -> Self {
        self.host = value;
        self
    }

}

const ORIGIN_LOG_INFO_FIELDS: &'static [&'static str] = &["access_method",
                                                          "geo_location",
                                                          "host"];
impl OriginLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<OriginLogInfo, V::Error> {
        use serde::de;
        let mut field_access_method = None;
        let mut field_geo_location = None;
        let mut field_host = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_method" => {
                    if field_access_method.is_some() {
                        return Err(de::Error::duplicate_field("access_method"));
                    }
                    field_access_method = Some(map.next_value()?);
                }
                "geo_location" => {
                    if field_geo_location.is_some() {
                        return Err(de::Error::duplicate_field("geo_location"));
                    }
                    field_geo_location = Some(map.next_value()?);
                }
                "host" => {
                    if field_host.is_some() {
                        return Err(de::Error::duplicate_field("host"));
                    }
                    field_host = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ORIGIN_LOG_INFO_FIELDS))
            }
        }
        Ok(OriginLogInfo {
            access_method: field_access_method.ok_or_else(|| de::Error::missing_field("access_method"))?,
            geo_location: field_geo_location,
            host: field_host,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_method", &self.access_method)?;
        s.serialize_field("geo_location", &self.geo_location)?;
        s.serialize_field("host", &self.host)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OriginLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OriginLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a OriginLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OriginLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OriginLogInfo", ORIGIN_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OriginLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OriginLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperAccessType {
    Viewer,
    Commenter,
    Editor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperAccessType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "viewer" => Ok(PaperAccessType::Viewer),
                    "commenter" => Ok(PaperAccessType::Commenter),
                    "editor" => Ok(PaperAccessType::Editor),
                    _ => Ok(PaperAccessType::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["viewer",
                                                    "commenter",
                                                    "editor",
                                                    "other"];
        deserializer.deserialize_struct("PaperAccessType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperAccessType::Viewer => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "viewer")?;
                s.end()
            }
            PaperAccessType::Commenter => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "commenter")?;
                s.end()
            }
            PaperAccessType::Editor => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "editor")?;
                s.end()
            }
            PaperAccessType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed whether Dropbox Paper, when enabled, is deployed to all teams or to specific members of
/// the team.
#[derive(Debug)]
pub struct PaperChangeDeploymentPolicyDetails {
    /// New Dropbox Paper deployment policy.
    pub new_value: PaperDeploymentPolicy,
    /// Previous Dropbox Paper deployment policy. Might be missing due to historical data gap.
    pub previous_value: Option<PaperDeploymentPolicy>,
}

impl PaperChangeDeploymentPolicyDetails {
    pub fn new(new_value: PaperDeploymentPolicy) -> Self {
        PaperChangeDeploymentPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<PaperDeploymentPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                 "previous_value"];
impl PaperChangeDeploymentPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperChangeDeploymentPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangeDeploymentPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeDeploymentPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeDeploymentPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeDeploymentPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeDeploymentPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeDeploymentPolicyDetails", PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeDeploymentPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeDeploymentPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share Paper documents externally (i.e. outside the team), and
/// if so, whether they should be accessible only by team members or anyone by default.
#[derive(Debug)]
pub struct PaperChangeMemberPolicyDetails {
    /// New paper external accessibility policy.
    pub new_value: PaperMemberPolicy,
    /// Previous paper external accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<PaperMemberPolicy>,
}

impl PaperChangeMemberPolicyDetails {
    pub fn new(new_value: PaperMemberPolicy) -> Self {
        PaperChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<PaperMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                             "previous_value"];
impl PaperChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperChangeMemberPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberPolicyDetails", PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled Dropbox Paper for the team.
#[derive(Debug)]
pub struct PaperChangePolicyDetails {
    /// New Dropbox Paper policy.
    pub new_value: PaperPolicy,
    /// Previous Dropbox Paper policy. Might be missing due to historical data gap.
    pub previous_value: Option<PaperPolicy>,
}

impl PaperChangePolicyDetails {
    pub fn new(new_value: PaperPolicy) -> Self {
        PaperChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<PaperPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                      "previous_value"];
impl PaperChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangePolicyDetails", PAPER_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users to the membership of a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentAddMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentAddMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentAddMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentAddMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddMemberDetails", PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added Paper doc or folder to a folder.
#[derive(Debug)]
pub struct PaperContentAddToFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Target asset index.
    pub target_index: i64,
    /// Parent asset index.
    pub parent_index: i64,
}

impl PaperContentAddToFolderDetails {
    pub fn new(event_uuid: String, target_index: i64, parent_index: i64) -> Self {
        PaperContentAddToFolderDetails {
            event_uuid,
            target_index,
            parent_index,
        }
    }

}

const PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                              "target_index",
                                                                              "parent_index"];
impl PaperContentAddToFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentAddToFolderDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_target_index = None;
        let mut field_parent_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "parent_index" => {
                    if field_parent_index.is_some() {
                        return Err(de::Error::duplicate_field("parent_index"));
                    }
                    field_parent_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentAddToFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            parent_index: field_parent_index.ok_or_else(|| de::Error::missing_field("parent_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("parent_index", &self.parent_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddToFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddToFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddToFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddToFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddToFolderDetails", PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddToFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddToFolderDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentArchiveDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentArchiveDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentArchiveDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentArchiveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentArchiveDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentArchiveDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentArchiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentArchiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentArchiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentArchiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentArchiveDetails", PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentArchiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentArchiveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed or unfollowed a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentChangeSubscriptionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New subscription level.
    pub new_subscription_level: PaperTaggedValue,
    /// Previous subscription level. Might be missing due to historical data gap.
    pub previous_subscription_level: Option<PaperTaggedValue>,
}

impl PaperContentChangeSubscriptionDetails {
    pub fn new(event_uuid: String, new_subscription_level: PaperTaggedValue) -> Self {
        PaperContentChangeSubscriptionDetails {
            event_uuid,
            new_subscription_level,
            previous_subscription_level: None,
        }
    }

    pub fn with_previous_subscription_level(mut self, value: Option<PaperTaggedValue>) -> Self {
        self.previous_subscription_level = value;
        self
    }

}

const PAPER_CONTENT_CHANGE_SUBSCRIPTION_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                                    "new_subscription_level",
                                                                                    "previous_subscription_level"];
impl PaperContentChangeSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentChangeSubscriptionDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_new_subscription_level = None;
        let mut field_previous_subscription_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_subscription_level" => {
                    if field_new_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("new_subscription_level"));
                    }
                    field_new_subscription_level = Some(map.next_value()?);
                }
                "previous_subscription_level" => {
                    if field_previous_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("previous_subscription_level"));
                    }
                    field_previous_subscription_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_CHANGE_SUBSCRIPTION_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentChangeSubscriptionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            new_subscription_level: field_new_subscription_level.ok_or_else(|| de::Error::missing_field("new_subscription_level"))?,
            previous_subscription_level: field_previous_subscription_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_subscription_level", &self.new_subscription_level)?;
        s.serialize_field("previous_subscription_level", &self.previous_subscription_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentChangeSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentChangeSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentChangeSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentChangeSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentChangeSubscriptionDetails", PAPER_CONTENT_CHANGE_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentChangeSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentChangeSubscriptionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentCreateDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentCreateDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentCreateDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentCreateDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentCreateDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentCreateDetails", PAPER_CONTENT_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentPermanentlyDeleteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentPermanentlyDeleteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentPermanentlyDeleteDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentPermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentPermanentlyDeleteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentPermanentlyDeleteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentPermanentlyDeleteDetails", PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentPermanentlyDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed Paper doc or folder from a folder.
#[derive(Debug)]
pub struct PaperContentRemoveFromFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRemoveFromFolderDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveFromFolderDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentRemoveFromFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentRemoveFromFolderDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRemoveFromFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveFromFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveFromFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveFromFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveFromFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveFromFolderDetails", PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveFromFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveFromFolderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a user from the membership of a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRemoveMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRemoveMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentRemoveMemberDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRemoveMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveMemberDetails", PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRenameDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRenameDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRenameDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RENAME_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentRenameDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRenameDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRenameDetails", PAPER_CONTENT_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored an archived Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRestoreDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRestoreDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRestoreDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RESTORE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperContentRestoreDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperContentRestoreDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RESTORE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRestoreDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRestoreDetails", PAPER_CONTENT_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRestoreDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperDeploymentPolicy {
    Partial,
    Full,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDeploymentPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDeploymentPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDeploymentPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "partial" => Ok(PaperDeploymentPolicy::Partial),
                    "full" => Ok(PaperDeploymentPolicy::Full),
                    _ => Ok(PaperDeploymentPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["partial",
                                                    "full",
                                                    "other"];
        deserializer.deserialize_struct("PaperDeploymentPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDeploymentPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDeploymentPolicy::Partial => {
                // unit
                let mut s = serializer.serialize_struct("PaperDeploymentPolicy", 1)?;
                s.serialize_field(".tag", "partial")?;
                s.end()
            }
            PaperDeploymentPolicy::Full => {
                // unit
                let mut s = serializer.serialize_struct("PaperDeploymentPolicy", 1)?;
                s.serialize_field(".tag", "full")?;
                s.end()
            }
            PaperDeploymentPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocAddCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocAddCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocAddCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                        "comment_text"];
impl PaperDocAddCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocAddCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocAddCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocAddCommentDetails", PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocAddCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of a Paper doc member.
#[derive(Debug)]
pub struct PaperDocChangeMemberRoleDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Paper doc access type.
    pub access_type: PaperAccessType,
}

impl PaperDocChangeMemberRoleDetails {
    pub fn new(event_uuid: String, access_type: PaperAccessType) -> Self {
        PaperDocChangeMemberRoleDetails {
            event_uuid,
            access_type,
        }
    }

}

const PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                               "access_type"];
impl PaperDocChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_access_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocChangeMemberRoleDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("access_type", &self.access_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeMemberRoleDetails", PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeMemberRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sharing policy for Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeSharingPolicyDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Sharing policy with external users. Might be missing due to historical data gap.
    pub public_sharing_policy: Option<String>,
    /// Sharing policy with team. Might be missing due to historical data gap.
    pub team_sharing_policy: Option<String>,
}

impl PaperDocChangeSharingPolicyDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocChangeSharingPolicyDetails {
            event_uuid,
            public_sharing_policy: None,
            team_sharing_policy: None,
        }
    }

    pub fn with_public_sharing_policy(mut self, value: Option<String>) -> Self {
        self.public_sharing_policy = value;
        self
    }

    pub fn with_team_sharing_policy(mut self, value: Option<String>) -> Self {
        self.team_sharing_policy = value;
        self
    }

}

const PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                                  "public_sharing_policy",
                                                                                  "team_sharing_policy"];
impl PaperDocChangeSharingPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocChangeSharingPolicyDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_public_sharing_policy = None;
        let mut field_team_sharing_policy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "public_sharing_policy" => {
                    if field_public_sharing_policy.is_some() {
                        return Err(de::Error::duplicate_field("public_sharing_policy"));
                    }
                    field_public_sharing_policy = Some(map.next_value()?);
                }
                "team_sharing_policy" => {
                    if field_team_sharing_policy.is_some() {
                        return Err(de::Error::duplicate_field("team_sharing_policy"));
                    }
                    field_team_sharing_policy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocChangeSharingPolicyDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            public_sharing_policy: field_public_sharing_policy,
            team_sharing_policy: field_team_sharing_policy,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("public_sharing_policy", &self.public_sharing_policy)?;
        s.serialize_field("team_sharing_policy", &self.team_sharing_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSharingPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSharingPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSharingPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSharingPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSharingPolicyDetails", PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSharingPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSharingPolicyDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocDeleteCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocDeleteCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeleteCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                           "comment_text"];
impl PaperDocDeleteCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocDeleteCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDeleteCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeleteCommentDetails", PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeleteCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc archived.
#[derive(Debug)]
pub struct PaperDocDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_DELETED_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocDeletedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeletedDetails", PAPER_DOC_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded a Paper doc in a particular output format.
#[derive(Debug)]
pub struct PaperDocDownloadDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Export file format.
    pub export_file_format: PaperDownloadFormat,
}

impl PaperDocDownloadDetails {
    pub fn new(event_uuid: String, export_file_format: PaperDownloadFormat) -> Self {
        PaperDocDownloadDetails {
            event_uuid,
            export_file_format,
        }
    }

}

const PAPER_DOC_DOWNLOAD_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                     "export_file_format"];
impl PaperDocDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocDownloadDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_export_file_format = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "export_file_format" => {
                    if field_export_file_format.is_some() {
                        return Err(de::Error::duplicate_field("export_file_format"));
                    }
                    field_export_file_format = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DOWNLOAD_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDownloadDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            export_file_format: field_export_file_format.ok_or_else(|| de::Error::missing_field("export_file_format"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("export_file_format", &self.export_file_format)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDownloadDetails", PAPER_DOC_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDownloadDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocEditCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocEditCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                         "comment_text"];
impl PaperDocEditCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocEditCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocEditCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditCommentDetails", PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited a Paper doc.
#[derive(Debug)]
pub struct PaperDocEditDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocEditDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_EDIT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocEditDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocEditDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocEditDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditDetails", PAPER_DOC_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed a Paper doc.
#[derive(Debug)]
pub struct PaperDocFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_FOLLOWED_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocFollowedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_FOLLOWED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocFollowedDetails", PAPER_DOC_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Mentioned a member in a Paper doc.
#[derive(Debug)]
pub struct PaperDocMentionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocMentionDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocMentionDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_MENTION_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocMentionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocMentionDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_MENTION_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocMentionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocMentionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocMentionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocMentionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocMentionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocMentionDetails", PAPER_DOC_MENTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocMentionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocMentionDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to be a member on a Paper doc.
#[derive(Debug)]
pub struct PaperDocRequestAccessDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRequestAccessDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRequestAccessDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocRequestAccessDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocRequestAccessDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRequestAccessDetails", PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc comment resolved.
#[derive(Debug)]
pub struct PaperDocResolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocResolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocResolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                            "comment_text"];
impl PaperDocResolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocResolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocResolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocResolveCommentDetails", PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocResolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored a Paper doc to previous revision.
#[derive(Debug)]
pub struct PaperDocRevertDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRevertDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRevertDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REVERT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocRevertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocRevertDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REVERT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocRevertDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRevertDetails", PAPER_DOC_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRevertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc link shared via slack.
#[derive(Debug)]
pub struct PaperDocSlackShareDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocSlackShareDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocSlackShareDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocSlackShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocSlackShareDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocSlackShareDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocSlackShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocSlackShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocSlackShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocSlackShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocSlackShareDetails", PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocSlackShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocSlackShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc shared with team member.
#[derive(Debug)]
pub struct PaperDocTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTeamInviteDetails", PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocUnresolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocUnresolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocUnresolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid",
                                                                              "comment_text"];
impl PaperDocUnresolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocUnresolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocUnresolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUnresolveCommentDetails", PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUnresolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed Paper doc.
#[derive(Debug)]
pub struct PaperDocViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocViewDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocViewDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_VIEW_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperDocViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocViewDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_VIEW_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocViewDetails", PAPER_DOC_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper document's logged information.
#[derive(Debug)]
pub struct PaperDocumentLogInfo {
    /// Papers document Id.
    pub doc_id: String,
    /// Paper document title.
    pub doc_title: String,
}

impl PaperDocumentLogInfo {
    pub fn new(doc_id: String, doc_title: String) -> Self {
        PaperDocumentLogInfo {
            doc_id,
            doc_title,
        }
    }

}

const PAPER_DOCUMENT_LOG_INFO_FIELDS: &'static [&'static str] = &["doc_id",
                                                                  "doc_title"];
impl PaperDocumentLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperDocumentLogInfo, V::Error> {
        use serde::de;
        let mut field_doc_id = None;
        let mut field_doc_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "doc_id" => {
                    if field_doc_id.is_some() {
                        return Err(de::Error::duplicate_field("doc_id"));
                    }
                    field_doc_id = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOCUMENT_LOG_INFO_FIELDS))
            }
        }
        Ok(PaperDocumentLogInfo {
            doc_id: field_doc_id.ok_or_else(|| de::Error::missing_field("doc_id"))?,
            doc_title: field_doc_title.ok_or_else(|| de::Error::missing_field("doc_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("doc_id", &self.doc_id)?;
        s.serialize_field("doc_title", &self.doc_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocumentLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocumentLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocumentLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocumentLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocumentLogInfo", PAPER_DOCUMENT_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocumentLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocumentLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperDownloadFormat {
    Docx,
    Html,
    Markdown,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDownloadFormat {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDownloadFormat;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDownloadFormat structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "docx" => Ok(PaperDownloadFormat::Docx),
                    "html" => Ok(PaperDownloadFormat::Html),
                    "markdown" => Ok(PaperDownloadFormat::Markdown),
                    _ => Ok(PaperDownloadFormat::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["docx",
                                                    "html",
                                                    "markdown",
                                                    "other"];
        deserializer.deserialize_struct("PaperDownloadFormat", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDownloadFormat {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDownloadFormat::Docx => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "docx")?;
                s.end()
            }
            PaperDownloadFormat::Html => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "html")?;
                s.end()
            }
            PaperDownloadFormat::Markdown => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "markdown")?;
                s.end()
            }
            PaperDownloadFormat::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Users added to Paper enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupAdditionDetails {
}

impl Default for PaperEnabledUsersGroupAdditionDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupAdditionDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PaperEnabledUsersGroupAdditionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperEnabledUsersGroupAdditionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS));
        }
        Ok(PaperEnabledUsersGroupAdditionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupAdditionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupAdditionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupAdditionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupAdditionDetails", PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupAdditionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupAdditionDetails", 0)?.end()
    }
}

/// Users removed from Paper enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupRemovalDetails {
}

impl Default for PaperEnabledUsersGroupRemovalDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupRemovalDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PaperEnabledUsersGroupRemovalDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperEnabledUsersGroupRemovalDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS));
        }
        Ok(PaperEnabledUsersGroupRemovalDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupRemovalDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupRemovalDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupRemovalDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupRemovalDetails", PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupRemovalDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupRemovalDetails", 0)?.end()
    }
}

/// Paper external sharing policy changed: anyone.
#[derive(Debug)]
pub struct PaperExternalViewAllowDetails {
}

impl Default for PaperExternalViewAllowDetails {
    fn default() -> Self {
        PaperExternalViewAllowDetails {
        }
    }
}

const PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PaperExternalViewAllowDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperExternalViewAllowDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS));
        }
        Ok(PaperExternalViewAllowDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewAllowDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewAllowDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewAllowDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewAllowDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewAllowDetails", PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewAllowDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperExternalViewAllowDetails", 0)?.end()
    }
}

/// Paper external sharing policy changed: default team.
#[derive(Debug)]
pub struct PaperExternalViewDefaultTeamDetails {
}

impl Default for PaperExternalViewDefaultTeamDetails {
    fn default() -> Self {
        PaperExternalViewDefaultTeamDetails {
        }
    }
}

const PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PaperExternalViewDefaultTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperExternalViewDefaultTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS));
        }
        Ok(PaperExternalViewDefaultTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewDefaultTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewDefaultTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewDefaultTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewDefaultTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewDefaultTeamDetails", PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewDefaultTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperExternalViewDefaultTeamDetails", 0)?.end()
    }
}

/// Paper external sharing policy changed: team-only.
#[derive(Debug)]
pub struct PaperExternalViewForbidDetails {
}

impl Default for PaperExternalViewForbidDetails {
    fn default() -> Self {
        PaperExternalViewForbidDetails {
        }
    }
}

const PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PaperExternalViewForbidDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperExternalViewForbidDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS));
        }
        Ok(PaperExternalViewForbidDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewForbidDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewForbidDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewForbidDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewForbidDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewForbidDetails", PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewForbidDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperExternalViewForbidDetails", 0)?.end()
    }
}

/// Paper folder archived.
#[derive(Debug)]
pub struct PaperFolderDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_DELETED_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperFolderDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperFolderDeletedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_DELETED_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderDeletedDetails", PAPER_FOLDER_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed a Paper folder.
#[derive(Debug)]
pub struct PaperFolderFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperFolderFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperFolderFollowedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderFollowedDetails", PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder's logged information.
#[derive(Debug)]
pub struct PaperFolderLogInfo {
    /// Papers folder Id.
    pub folder_id: String,
    /// Paper folder name.
    pub folder_name: String,
}

impl PaperFolderLogInfo {
    pub fn new(folder_id: String, folder_name: String) -> Self {
        PaperFolderLogInfo {
            folder_id,
            folder_name,
        }
    }

}

const PAPER_FOLDER_LOG_INFO_FIELDS: &'static [&'static str] = &["folder_id",
                                                                "folder_name"];
impl PaperFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperFolderLogInfo, V::Error> {
        use serde::de;
        let mut field_folder_id = None;
        let mut field_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "folder_id" => {
                    if field_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("folder_id"));
                    }
                    field_folder_id = Some(map.next_value()?);
                }
                "folder_name" => {
                    if field_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("folder_name"));
                    }
                    field_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(PaperFolderLogInfo {
            folder_id: field_folder_id.ok_or_else(|| de::Error::missing_field("folder_id"))?,
            folder_name: field_folder_name.ok_or_else(|| de::Error::missing_field("folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_id", &self.folder_id)?;
        s.serialize_field("folder_name", &self.folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderLogInfo", PAPER_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder shared with team member.
#[derive(Debug)]
pub struct PaperFolderTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS: &'static [&'static str] = &["event_uuid"];
impl PaperFolderTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperFolderTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderTeamInviteDetails", PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can share Paper documents externally.
#[derive(Debug)]
pub enum PaperMemberPolicy {
    TeamOnly,
    DefaultTeamOnly,
    DefaultAnyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_only" => Ok(PaperMemberPolicy::TeamOnly),
                    "default_team_only" => Ok(PaperMemberPolicy::DefaultTeamOnly),
                    "default_anyone" => Ok(PaperMemberPolicy::DefaultAnyone),
                    _ => Ok(PaperMemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_only",
                                                    "default_team_only",
                                                    "default_anyone",
                                                    "other"];
        deserializer.deserialize_struct("PaperMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperMemberPolicy::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            PaperMemberPolicy::DefaultTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "default_team_only")?;
                s.end()
            }
            PaperMemberPolicy::DefaultAnyone => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "default_anyone")?;
                s.end()
            }
            PaperMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for enabling or disabling Dropbox Paper for the team.
#[derive(Debug)]
pub enum PaperPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(PaperPolicy::Disabled),
                    "enabled" => Ok(PaperPolicy::Enabled),
                    _ => Ok(PaperPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("PaperPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("PaperPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            PaperPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("PaperPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            PaperPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Paper tagged value.
#[derive(Debug)]
pub struct PaperTaggedValue {
    /// Tag.
    pub tag: String,
}

impl PaperTaggedValue {
    pub fn new(tag: String) -> Self {
        PaperTaggedValue {
            tag,
        }
    }

}

const PAPER_TAGGED_VALUE_FIELDS: &'static [&'static str] = &["tag"];
impl PaperTaggedValue {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PaperTaggedValue, V::Error> {
        use serde::de;
        let mut field_tag = None;
        while let Some(key) = map.next_key()? {
            match key {
                "tag" => {
                    if field_tag.is_some() {
                        return Err(de::Error::duplicate_field("tag"));
                    }
                    field_tag = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_TAGGED_VALUE_FIELDS))
            }
        }
        Ok(PaperTaggedValue {
            tag: field_tag.ok_or_else(|| de::Error::missing_field("tag"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("tag", &self.tag)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperTaggedValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperTaggedValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperTaggedValue struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperTaggedValue::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperTaggedValue", PAPER_TAGGED_VALUE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperTaggedValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperTaggedValue", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// A user or group
#[derive(Debug)]
pub enum ParticipantLogInfo {
    /// User details.
    User(UserLogInfo),
    /// Group details.
    Group(GroupLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ParticipantLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ParticipantLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ParticipantLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ParticipantLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group" => Ok(ParticipantLogInfo::Group(GroupLogInfo::internal_deserialize(map)?)),
                    _ => Ok(ParticipantLogInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user",
                                                    "group",
                                                    "other"];
        deserializer.deserialize_struct("ParticipantLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ParticipantLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ParticipantLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ParticipantLogInfo::Group(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ParticipantLogInfo", 4)?;
                s.serialize_field(".tag", "group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ParticipantLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed password.
#[derive(Debug)]
pub struct PasswordChangeDetails {
}

impl Default for PasswordChangeDetails {
    fn default() -> Self {
        PasswordChangeDetails {
        }
    }
}

const PASSWORD_CHANGE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PasswordChangeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PasswordChangeDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_CHANGE_DETAILS_FIELDS));
        }
        Ok(PasswordChangeDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordChangeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordChangeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordChangeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordChangeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordChangeDetails", PASSWORD_CHANGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordChangeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordChangeDetails", 0)?.end()
    }
}

/// Failed to sign in using a password.
#[derive(Debug)]
pub struct PasswordLoginFailDetails {
    /// Login failure details.
    pub error_details: FailureDetailsLogInfo,
}

impl PasswordLoginFailDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        PasswordLoginFailDetails {
            error_details,
        }
    }

}

const PASSWORD_LOGIN_FAIL_DETAILS_FIELDS: &'static [&'static str] = &["error_details"];
impl PasswordLoginFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PasswordLoginFailDetails, V::Error> {
        use serde::de;
        let mut field_error_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PASSWORD_LOGIN_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(PasswordLoginFailDetails {
            error_details: field_error_details.ok_or_else(|| de::Error::missing_field("error_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordLoginFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordLoginFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordLoginFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordLoginFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordLoginFailDetails", PASSWORD_LOGIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordLoginFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordLoginFailDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Signed in using a password.
#[derive(Debug)]
pub struct PasswordLoginSuccessDetails {
}

impl Default for PasswordLoginSuccessDetails {
    fn default() -> Self {
        PasswordLoginSuccessDetails {
        }
    }
}

const PASSWORD_LOGIN_SUCCESS_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PasswordLoginSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PasswordLoginSuccessDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_LOGIN_SUCCESS_DETAILS_FIELDS));
        }
        Ok(PasswordLoginSuccessDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordLoginSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordLoginSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordLoginSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordLoginSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordLoginSuccessDetails", PASSWORD_LOGIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordLoginSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordLoginSuccessDetails", 0)?.end()
    }
}

/// Reset all team member passwords.
#[derive(Debug)]
pub struct PasswordResetAllDetails {
}

impl Default for PasswordResetAllDetails {
    fn default() -> Self {
        PasswordResetAllDetails {
        }
    }
}

const PASSWORD_RESET_ALL_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PasswordResetAllDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PasswordResetAllDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_RESET_ALL_DETAILS_FIELDS));
        }
        Ok(PasswordResetAllDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetAllDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetAllDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetAllDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetAllDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetAllDetails", PASSWORD_RESET_ALL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetAllDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetAllDetails", 0)?.end()
    }
}

/// Reset password.
#[derive(Debug)]
pub struct PasswordResetDetails {
}

impl Default for PasswordResetDetails {
    fn default() -> Self {
        PasswordResetDetails {
        }
    }
}

const PASSWORD_RESET_DETAILS_FIELDS: &'static [&'static str] = &[];
impl PasswordResetDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PasswordResetDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_RESET_DETAILS_FIELDS));
        }
        Ok(PasswordResetDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetDetails", PASSWORD_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetDetails", 0)?.end()
    }
}

/// Path's details.
#[derive(Debug)]
pub struct PathLogInfo {
    /// Path relative to the namespace containing the content.
    pub namespace_relative: NamespaceRelativePathLogInfo,
    /// Fully qualified path relative to event's context. Might be missing due to historical data
    /// gap.
    pub contextual: Option<super::files::Path>,
}

impl PathLogInfo {
    pub fn new(namespace_relative: NamespaceRelativePathLogInfo) -> Self {
        PathLogInfo {
            namespace_relative,
            contextual: None,
        }
    }

    pub fn with_contextual(mut self, value: Option<super::files::Path>) -> Self {
        self.contextual = value;
        self
    }

}

const PATH_LOG_INFO_FIELDS: &'static [&'static str] = &["namespace_relative",
                                                        "contextual"];
impl PathLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PathLogInfo, V::Error> {
        use serde::de;
        let mut field_namespace_relative = None;
        let mut field_contextual = None;
        while let Some(key) = map.next_key()? {
            match key {
                "namespace_relative" => {
                    if field_namespace_relative.is_some() {
                        return Err(de::Error::duplicate_field("namespace_relative"));
                    }
                    field_namespace_relative = Some(map.next_value()?);
                }
                "contextual" => {
                    if field_contextual.is_some() {
                        return Err(de::Error::duplicate_field("contextual"));
                    }
                    field_contextual = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PATH_LOG_INFO_FIELDS))
            }
        }
        Ok(PathLogInfo {
            namespace_relative: field_namespace_relative.ok_or_else(|| de::Error::missing_field("namespace_relative"))?,
            contextual: field_contextual,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("namespace_relative", &self.namespace_relative)?;
        s.serialize_field("contextual", &self.contextual)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PathLogInfo", PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PathLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled the ability of team members to permanently delete content.
#[derive(Debug)]
pub struct PermanentDeleteChangePolicyDetails {
    /// New permanent delete content policy.
    pub new_value: ContentPermanentDeletePolicy,
    /// Previous permanent delete content policy. Might be missing due to historical data gap.
    pub previous_value: Option<ContentPermanentDeletePolicy>,
}

impl PermanentDeleteChangePolicyDetails {
    pub fn new(new_value: ContentPermanentDeletePolicy) -> Self {
        PermanentDeleteChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ContentPermanentDeletePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                 "previous_value"];
impl PermanentDeleteChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PermanentDeleteChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PermanentDeleteChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PermanentDeleteChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PermanentDeleteChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PermanentDeleteChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PermanentDeleteChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PermanentDeleteChangePolicyDetails", PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PermanentDeleteChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PermanentDeleteChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PlacementRestriction {
    EuropeOnly,
    NoneVariant,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PlacementRestriction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PlacementRestriction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PlacementRestriction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "europe_only" => Ok(PlacementRestriction::EuropeOnly),
                    "none" => Ok(PlacementRestriction::NoneVariant),
                    _ => Ok(PlacementRestriction::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["europe_only",
                                                    "none",
                                                    "other"];
        deserializer.deserialize_struct("PlacementRestriction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PlacementRestriction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PlacementRestriction::EuropeOnly => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "europe_only")?;
                s.end()
            }
            PlacementRestriction::NoneVariant => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "none")?;
                s.end()
            }
            PlacementRestriction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Provides the indices of the source asset and the destination asset for a relocate action.
#[derive(Debug)]
pub struct RelocateAssetReferencesLogInfo {
    /// Source asset index.
    pub src_index: i64,
    /// Destination asset index.
    pub dest_index: i64,
}

impl RelocateAssetReferencesLogInfo {
    pub fn new(src_index: i64, dest_index: i64) -> Self {
        RelocateAssetReferencesLogInfo {
            src_index,
            dest_index,
        }
    }

}

const RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS: &'static [&'static str] = &["src_index",
                                                                             "dest_index"];
impl RelocateAssetReferencesLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RelocateAssetReferencesLogInfo, V::Error> {
        use serde::de;
        let mut field_src_index = None;
        let mut field_dest_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "src_index" => {
                    if field_src_index.is_some() {
                        return Err(de::Error::duplicate_field("src_index"));
                    }
                    field_src_index = Some(map.next_value()?);
                }
                "dest_index" => {
                    if field_dest_index.is_some() {
                        return Err(de::Error::duplicate_field("dest_index"));
                    }
                    field_dest_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS))
            }
        }
        Ok(RelocateAssetReferencesLogInfo {
            src_index: field_src_index.ok_or_else(|| de::Error::missing_field("src_index"))?,
            dest_index: field_dest_index.ok_or_else(|| de::Error::missing_field("dest_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("src_index", &self.src_index)?;
        s.serialize_field("dest_index", &self.dest_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RelocateAssetReferencesLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RelocateAssetReferencesLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelocateAssetReferencesLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RelocateAssetReferencesLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RelocateAssetReferencesLogInfo", RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RelocateAssetReferencesLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RelocateAssetReferencesLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed single sign-on logout URL.
#[derive(Debug)]
pub struct RemoveLogoutUrlDetails {
    /// Previous single sign-on logout URL.
    pub previous_value: String,
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl RemoveLogoutUrlDetails {
    pub fn new(previous_value: String) -> Self {
        RemoveLogoutUrlDetails {
            previous_value,
            new_value: None,
        }
    }

    pub fn with_new_value(mut self, value: Option<String>) -> Self {
        self.new_value = value;
        self
    }

}

const REMOVE_LOGOUT_URL_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                    "new_value"];
impl RemoveLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RemoveLogoutUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REMOVE_LOGOUT_URL_DETAILS_FIELDS))
            }
        }
        Ok(RemoveLogoutUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RemoveLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RemoveLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RemoveLogoutUrlDetails", REMOVE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RemoveLogoutUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sign-out URL for SSO.
#[derive(Debug)]
pub struct RemoveSsoUrlDetails {
    /// Previous single sign-on logout URL.
    pub previous_value: String,
}

impl RemoveSsoUrlDetails {
    pub fn new(previous_value: String) -> Self {
        RemoveSsoUrlDetails {
            previous_value,
        }
    }

}

const REMOVE_SSO_URL_DETAILS_FIELDS: &'static [&'static str] = &["previous_value"];
impl RemoveSsoUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RemoveSsoUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REMOVE_SSO_URL_DETAILS_FIELDS))
            }
        }
        Ok(RemoveSsoUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveSsoUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RemoveSsoUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveSsoUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RemoveSsoUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RemoveSsoUrlDetails", REMOVE_SSO_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveSsoUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RemoveSsoUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reseller information.
#[derive(Debug)]
pub struct ResellerLogInfo {
    /// Reseller name.
    pub reseller_name: String,
    /// Reseller ID.
    pub reseller_id: super::team_common::ResellerId,
}

impl ResellerLogInfo {
    pub fn new(reseller_name: String, reseller_id: super::team_common::ResellerId) -> Self {
        ResellerLogInfo {
            reseller_name,
            reseller_id,
        }
    }

}

const RESELLER_LOG_INFO_FIELDS: &'static [&'static str] = &["reseller_name",
                                                            "reseller_id"];
impl ResellerLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ResellerLogInfo, V::Error> {
        use serde::de;
        let mut field_reseller_name = None;
        let mut field_reseller_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "reseller_name" => {
                    if field_reseller_name.is_some() {
                        return Err(de::Error::duplicate_field("reseller_name"));
                    }
                    field_reseller_name = Some(map.next_value()?);
                }
                "reseller_id" => {
                    if field_reseller_id.is_some() {
                        return Err(de::Error::duplicate_field("reseller_id"));
                    }
                    field_reseller_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RESELLER_LOG_INFO_FIELDS))
            }
        }
        Ok(ResellerLogInfo {
            reseller_name: field_reseller_name.ok_or_else(|| de::Error::missing_field("reseller_name"))?,
            reseller_id: field_reseller_id.ok_or_else(|| de::Error::missing_field("reseller_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("reseller_name", &self.reseller_name)?;
        s.serialize_field("reseller_id", &self.reseller_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerLogInfo", RESELLER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionEndDetails {
}

impl Default for ResellerSupportSessionEndDetails {
    fn default() -> Self {
        ResellerSupportSessionEndDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ResellerSupportSessionEndDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ResellerSupportSessionEndDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS));
        }
        Ok(ResellerSupportSessionEndDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionEndDetails", RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionEndDetails", 0)?.end()
    }
}

/// Started reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionStartDetails {
}

impl Default for ResellerSupportSessionStartDetails {
    fn default() -> Self {
        ResellerSupportSessionStartDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ResellerSupportSessionStartDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ResellerSupportSessionStartDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS));
        }
        Ok(ResellerSupportSessionStartDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionStartDetails", RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionStartDetails", 0)?.end()
    }
}

/// Session's logged information.
#[derive(Debug)]
pub enum SessionLogInfo {
    Web(WebSessionLogInfo),
    Desktop(DesktopSessionLogInfo),
    Mobile(MobileSessionLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for SessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SessionLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "web" => Ok(SessionLogInfo::Web(WebSessionLogInfo::internal_deserialize(map)?)),
                    "desktop" => Ok(SessionLogInfo::Desktop(DesktopSessionLogInfo::internal_deserialize(map)?)),
                    "mobile" => Ok(SessionLogInfo::Mobile(MobileSessionLogInfo::internal_deserialize(map)?)),
                    _ => Ok(SessionLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["mobile",
                                                    "mobile",
                                                    "mobile"];
        deserializer.deserialize_struct("SessionLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            SessionLogInfo::Web(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "web")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Desktop(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "desktop")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Mobile(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "mobile")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Added the team to a shared folder.
#[derive(Debug)]
pub struct SfAddGroupDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Team name.
    pub team_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfAddGroupDetails {
    pub fn new(target_index: i64, original_folder_name: String, team_name: String) -> Self {
        SfAddGroupDetails {
            target_index,
            original_folder_name,
            team_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_ADD_GROUP_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                               "original_folder_name",
                                                               "team_name",
                                                               "sharing_permission"];
impl SfAddGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfAddGroupDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_team_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ADD_GROUP_DETAILS_FIELDS))
            }
        }
        Ok(SfAddGroupDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAddGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAddGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAddGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAddGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAddGroupDetails", SF_ADD_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAddGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAddGroupDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Allowed non collaborators to view links to files in a shared folder.
#[derive(Debug)]
pub struct SfAllowNonMembersToViewSharedLinksDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SfAllowNonMembersToViewSharedLinksDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfAllowNonMembersToViewSharedLinksDetails {
            target_index,
            original_folder_name,
            shared_folder_type: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                            "original_folder_name",
                                                                                            "shared_folder_type"];
impl SfAllowNonMembersToViewSharedLinksDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfAllowNonMembersToViewSharedLinksDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS))
            }
        }
        Ok(SfAllowNonMembersToViewSharedLinksDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAllowNonMembersToViewSharedLinksDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAllowNonMembersToViewSharedLinksDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAllowNonMembersToViewSharedLinksDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAllowNonMembersToViewSharedLinksDetails", SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAllowNonMembersToViewSharedLinksDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAllowNonMembersToViewSharedLinksDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Admin settings: team members see a warning before sharing folders outside the team (DEPRECATED
/// FEATURE).
#[derive(Debug)]
pub struct SfExternalInviteWarnDetails {
}

impl Default for SfExternalInviteWarnDetails {
    fn default() -> Self {
        SfExternalInviteWarnDetails {
        }
    }
}

const SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS: &'static [&'static str] = &[];
impl SfExternalInviteWarnDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfExternalInviteWarnDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS));
        }
        Ok(SfExternalInviteWarnDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfExternalInviteWarnDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfExternalInviteWarnDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfExternalInviteWarnDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfExternalInviteWarnDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfExternalInviteWarnDetails", SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfExternalInviteWarnDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SfExternalInviteWarnDetails", 0)?.end()
    }
}

/// Invited a group to a shared folder.
#[derive(Debug)]
pub struct SfInviteGroupDetails {
    /// Target asset index.
    pub target_index: i64,
}

impl SfInviteGroupDetails {
    pub fn new(target_index: i64) -> Self {
        SfInviteGroupDetails {
            target_index,
        }
    }

}

const SF_INVITE_GROUP_DETAILS_FIELDS: &'static [&'static str] = &["target_index"];
impl SfInviteGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfInviteGroupDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_INVITE_GROUP_DETAILS_FIELDS))
            }
        }
        Ok(SfInviteGroupDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfInviteGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfInviteGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfInviteGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfInviteGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfInviteGroupDetails", SF_INVITE_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfInviteGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfInviteGroupDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed parent of shared folder.
#[derive(Debug)]
pub struct SfNestDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Previous parent namespace ID. Might be missing due to historical data gap.
    pub prev_parent_ns_id: Option<super::common::NamespaceId>,
    /// New parent namespace ID. Might be missing due to historical data gap.
    pub new_parent_ns_id: Option<super::common::NamespaceId>,
}

impl SfNestDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfNestDetails {
            target_index,
            original_folder_name,
            prev_parent_ns_id: None,
            new_parent_ns_id: None,
        }
    }

    pub fn with_prev_parent_ns_id(mut self, value: Option<super::common::NamespaceId>) -> Self {
        self.prev_parent_ns_id = value;
        self
    }

    pub fn with_new_parent_ns_id(mut self, value: Option<super::common::NamespaceId>) -> Self {
        self.new_parent_ns_id = value;
        self
    }

}

const SF_NEST_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                          "original_folder_name",
                                                          "prev_parent_ns_id",
                                                          "new_parent_ns_id"];
impl SfNestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfNestDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_prev_parent_ns_id = None;
        let mut field_new_parent_ns_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "prev_parent_ns_id" => {
                    if field_prev_parent_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("prev_parent_ns_id"));
                    }
                    field_prev_parent_ns_id = Some(map.next_value()?);
                }
                "new_parent_ns_id" => {
                    if field_new_parent_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("new_parent_ns_id"));
                    }
                    field_new_parent_ns_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_NEST_DETAILS_FIELDS))
            }
        }
        Ok(SfNestDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            prev_parent_ns_id: field_prev_parent_ns_id,
            new_parent_ns_id: field_new_parent_ns_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("prev_parent_ns_id", &self.prev_parent_ns_id)?;
        s.serialize_field("new_parent_ns_id", &self.new_parent_ns_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfNestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfNestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfNestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfNestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfNestDetails", SF_NEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfNestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfNestDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Declined a team member's invitation to a shared folder.
#[derive(Debug)]
pub struct SfTeamDeclineDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamDeclineDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamDeclineDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_DECLINE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                  "original_folder_name"];
impl SfTeamDeclineDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamDeclineDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_DECLINE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamDeclineDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamDeclineDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamDeclineDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamDeclineDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamDeclineDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamDeclineDetails", SF_TEAM_DECLINE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamDeclineDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamDeclineDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Granted access to a shared folder.
#[derive(Debug)]
pub struct SfTeamGrantAccessDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamGrantAccessDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamGrantAccessDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                       "original_folder_name"];
impl SfTeamGrantAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamGrantAccessDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamGrantAccessDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamGrantAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamGrantAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamGrantAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamGrantAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamGrantAccessDetails", SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamGrantAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamGrantAccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a team member's role in a shared folder.
#[derive(Debug)]
pub struct SfTeamInviteChangeRoleDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SfTeamInviteChangeRoleDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamInviteChangeRoleDetails {
            target_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                             "original_folder_name",
                                                                             "new_sharing_permission",
                                                                             "previous_sharing_permission"];
impl SfTeamInviteChangeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamInviteChangeRoleDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamInviteChangeRoleDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteChangeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteChangeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteChangeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteChangeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteChangeRoleDetails", SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteChangeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteChangeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited team members to a shared folder.
#[derive(Debug)]
pub struct SfTeamInviteDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamInviteDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamInviteDetails {
            target_index,
            original_folder_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                 "original_folder_name",
                                                                 "sharing_permission"];
impl SfTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamInviteDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteDetails", SF_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined a team member's shared folder.
#[derive(Debug)]
pub struct SfTeamJoinDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamJoinDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamJoinDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_JOIN_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                               "original_folder_name"];
impl SfTeamJoinDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamJoinDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamJoinDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinDetails", SF_TEAM_JOIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined a team member's shared folder from a link.
#[derive(Debug)]
pub struct SfTeamJoinFromOobLinkDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared link token key.
    pub token_key: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamJoinFromOobLinkDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamJoinFromOobLinkDetails {
            target_index,
            original_folder_name,
            token_key: None,
            sharing_permission: None,
        }
    }

    pub fn with_token_key(mut self, value: Option<String>) -> Self {
        self.token_key = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                             "original_folder_name",
                                                                             "token_key",
                                                                             "sharing_permission"];
impl SfTeamJoinFromOobLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamJoinFromOobLinkDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_token_key = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamJoinFromOobLinkDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            token_key: field_token_key,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("token_key", &self.token_key)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinFromOobLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinFromOobLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinFromOobLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinFromOobLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinFromOobLinkDetails", SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinFromOobLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinFromOobLinkDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared a folder with a team member.
#[derive(Debug)]
pub struct SfTeamUninviteDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamUninviteDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SfTeamUninviteDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_UNINVITE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                   "original_folder_name"];
impl SfTeamUninviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SfTeamUninviteDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_UNINVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamUninviteDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamUninviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamUninviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamUninviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamUninviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamUninviteDetails", SF_TEAM_UNINVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamUninviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamUninviteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent an email invitation to the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddInviteesDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SharedContentAddInviteesDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentAddInviteesDetails {
            target_index,
            original_folder_name: None,
            sharing_permission: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                              "original_folder_name",
                                                                              "sharing_permission"];
impl SharedContentAddInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentAddInviteesDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddInviteesDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddInviteesDetails", SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddInviteesDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an expiry to the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddLinkExpiryDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Expiration starting date.
    pub expiration_start_date: String,
    /// The number of days from the starting expiration date after which the link will expire.
    pub expiration_days: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentAddLinkExpiryDetails {
    pub fn new(target_index: i64, expiration_start_date: String, expiration_days: i64) -> Self {
        SharedContentAddLinkExpiryDetails {
            target_index,
            expiration_start_date,
            expiration_days,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                 "expiration_start_date",
                                                                                 "expiration_days",
                                                                                 "original_folder_name",
                                                                                 "shared_folder_type"];
impl SharedContentAddLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentAddLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_expiration_start_date = None;
        let mut field_expiration_days = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "expiration_start_date" => {
                    if field_expiration_start_date.is_some() {
                        return Err(de::Error::duplicate_field("expiration_start_date"));
                    }
                    field_expiration_start_date = Some(map.next_value()?);
                }
                "expiration_days" => {
                    if field_expiration_days.is_some() {
                        return Err(de::Error::duplicate_field("expiration_days"));
                    }
                    field_expiration_days = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddLinkExpiryDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            expiration_start_date: field_expiration_start_date.ok_or_else(|| de::Error::missing_field("expiration_start_date"))?,
            expiration_days: field_expiration_days.ok_or_else(|| de::Error::missing_field("expiration_days"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("expiration_start_date", &self.expiration_start_date)?;
        s.serialize_field("expiration_days", &self.expiration_days)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkExpiryDetails", SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkExpiryDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a password to the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddLinkPasswordDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentAddLinkPasswordDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentAddLinkPasswordDetails {
            target_index,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                   "original_folder_name",
                                                                                   "shared_folder_type"];
impl SharedContentAddLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentAddLinkPasswordDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddLinkPasswordDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkPasswordDetails", SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkPasswordDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users and/or groups to the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddMemberDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentAddMemberDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentAddMemberDetails {
            target_index,
            original_folder_name: None,
            sharing_permission: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                            "original_folder_name",
                                                                            "sharing_permission",
                                                                            "shared_folder_type"];
impl SharedContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddMemberDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            sharing_permission: field_sharing_permission,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddMemberDetails", SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddMemberDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can download the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeDownloadsPolicyDetails {
    /// Target asset index.
    pub target_index: i64,
    /// New downlaod policy.
    pub new_value: SharedContentDownloadsPolicy,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous downlaod policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedContentDownloadsPolicy>,
}

impl SharedContentChangeDownloadsPolicyDetails {
    pub fn new(target_index: i64, new_value: SharedContentDownloadsPolicy) -> Self {
        SharedContentChangeDownloadsPolicyDetails {
            target_index,
            new_value,
            original_folder_name: None,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<SharedContentDownloadsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                         "new_value",
                                                                                         "original_folder_name",
                                                                                         "shared_folder_type",
                                                                                         "previous_value"];
impl SharedContentChangeDownloadsPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeDownloadsPolicyDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_new_value = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeDownloadsPolicyDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeDownloadsPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeDownloadsPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeDownloadsPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeDownloadsPolicyDetails", SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeDownloadsPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeDownloadsPolicyDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of an invitee to a shared file or folder before the invitation was
/// claimed.
#[derive(Debug)]
pub struct SharedContentChangeInviteeRoleDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SharedContentChangeInviteeRoleDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedContentChangeInviteeRoleDetails {
            target_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                     "original_folder_name",
                                                                                     "new_sharing_permission",
                                                                                     "previous_sharing_permission"];
impl SharedContentChangeInviteeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeInviteeRoleDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeInviteeRoleDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeInviteeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeInviteeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeInviteeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeInviteeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeInviteeRoleDetails", SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeInviteeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeInviteeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the audience of the link for a shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkAudienceDetails {
    /// Target asset index.
    pub target_index: i64,
    /// New link audience value.
    pub new_value: LinkAudience,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous link audience value. Might be missing due to historical data gap.
    pub previous_value: Option<LinkAudience>,
}

impl SharedContentChangeLinkAudienceDetails {
    pub fn new(target_index: i64, new_value: LinkAudience) -> Self {
        SharedContentChangeLinkAudienceDetails {
            target_index,
            new_value,
            original_folder_name: None,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<LinkAudience>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                      "new_value",
                                                                                      "original_folder_name",
                                                                                      "shared_folder_type",
                                                                                      "previous_value"];
impl SharedContentChangeLinkAudienceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeLinkAudienceDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_new_value = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkAudienceDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkAudienceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkAudienceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkAudienceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkAudienceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkAudienceDetails", SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkAudienceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkAudienceDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the expiry of the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkExpiryDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Expiration starting date.
    pub expiration_start_date: String,
    /// The number of days from the starting expiration date after which the link will expire.
    pub expiration_days: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentChangeLinkExpiryDetails {
    pub fn new(target_index: i64, expiration_start_date: String, expiration_days: i64) -> Self {
        SharedContentChangeLinkExpiryDetails {
            target_index,
            expiration_start_date,
            expiration_days,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                    "expiration_start_date",
                                                                                    "expiration_days",
                                                                                    "original_folder_name",
                                                                                    "shared_folder_type"];
impl SharedContentChangeLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_expiration_start_date = None;
        let mut field_expiration_days = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "expiration_start_date" => {
                    if field_expiration_start_date.is_some() {
                        return Err(de::Error::duplicate_field("expiration_start_date"));
                    }
                    field_expiration_start_date = Some(map.next_value()?);
                }
                "expiration_days" => {
                    if field_expiration_days.is_some() {
                        return Err(de::Error::duplicate_field("expiration_days"));
                    }
                    field_expiration_days = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkExpiryDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            expiration_start_date: field_expiration_start_date.ok_or_else(|| de::Error::missing_field("expiration_start_date"))?,
            expiration_days: field_expiration_days.ok_or_else(|| de::Error::missing_field("expiration_days"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("expiration_start_date", &self.expiration_start_date)?;
        s.serialize_field("expiration_days", &self.expiration_days)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkExpiryDetails", SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkExpiryDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the password on the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkPasswordDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentChangeLinkPasswordDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentChangeLinkPasswordDetails {
            target_index,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                      "original_folder_name",
                                                                                      "shared_folder_type"];
impl SharedContentChangeLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeLinkPasswordDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkPasswordDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkPasswordDetails", SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkPasswordDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of a shared file or folder member.
#[derive(Debug)]
pub struct SharedContentChangeMemberRoleDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentChangeMemberRoleDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentChangeMemberRoleDetails {
            target_index,
            original_folder_name: None,
            new_sharing_permission: None,
            previous_sharing_permission: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                    "original_folder_name",
                                                                                    "new_sharing_permission",
                                                                                    "previous_sharing_permission",
                                                                                    "shared_folder_type"];
impl SharedContentChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeMemberRoleDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeMemberRoleDetails", SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeMemberRoleDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can see who viewed the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeViewerInfoPolicyDetails {
    /// Target asset index.
    pub target_index: i64,
    /// New viewer info policy.
    pub new_value: SharedContentViewerInfoPolicy,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous view info policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedContentViewerInfoPolicy>,
}

impl SharedContentChangeViewerInfoPolicyDetails {
    pub fn new(target_index: i64, new_value: SharedContentViewerInfoPolicy) -> Self {
        SharedContentChangeViewerInfoPolicyDetails {
            target_index,
            new_value,
            original_folder_name: None,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<SharedContentViewerInfoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                           "new_value",
                                                                                           "original_folder_name",
                                                                                           "shared_folder_type",
                                                                                           "previous_value"];
impl SharedContentChangeViewerInfoPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentChangeViewerInfoPolicyDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_new_value = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeViewerInfoPolicyDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeViewerInfoPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeViewerInfoPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeViewerInfoPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeViewerInfoPolicyDetails", SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeViewerInfoPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeViewerInfoPolicyDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Claimed membership to a team member's shared folder.
#[derive(Debug)]
pub struct SharedContentClaimInvitationDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedContentClaimInvitationDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentClaimInvitationDetails {
            target_index,
            original_folder_name: None,
            shared_content_link: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                  "original_folder_name",
                                                                                  "shared_content_link"];
impl SharedContentClaimInvitationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentClaimInvitationDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentClaimInvitationDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_content_link: field_shared_content_link,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentClaimInvitationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentClaimInvitationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentClaimInvitationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentClaimInvitationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentClaimInvitationDetails", SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentClaimInvitationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentClaimInvitationDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Copied the shared file or folder to own Dropbox.
#[derive(Debug)]
pub struct SharedContentCopyDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Target asset index.
    pub target_index: i64,
    /// Specifies the source and destination indices in the assets list.
    pub relocate_action_details: RelocateAssetReferencesLogInfo,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SharedContentCopyDetails {
    pub fn new(shared_content_link: String, target_index: i64, relocate_action_details: RelocateAssetReferencesLogInfo) -> Self {
        SharedContentCopyDetails {
            shared_content_link,
            target_index,
            relocate_action_details,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SHARED_CONTENT_COPY_DETAILS_FIELDS: &'static [&'static str] = &["shared_content_link",
                                                                      "target_index",
                                                                      "relocate_action_details",
                                                                      "sharing_permission"];
impl SharedContentCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentCopyDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_target_index = None;
        let mut field_relocate_action_details = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_COPY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentCopyDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentCopyDetails", SHARED_CONTENT_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentCopyDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded the shared file or folder.
#[derive(Debug)]
pub struct SharedContentDownloadDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Target asset index.
    pub target_index: i64,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SharedContentDownloadDetails {
    pub fn new(shared_content_link: String, target_index: i64) -> Self {
        SharedContentDownloadDetails {
            shared_content_link,
            target_index,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS: &'static [&'static str] = &["shared_content_link",
                                                                          "target_index",
                                                                          "sharing_permission"];
impl SharedContentDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentDownloadDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_target_index = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentDownloadDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentDownloadDetails", SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentDownloadDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared content downloads policy
#[derive(Debug)]
pub enum SharedContentDownloadsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedContentDownloadsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(SharedContentDownloadsPolicy::Disabled),
                    "enabled" => Ok(SharedContentDownloadsPolicy::Enabled),
                    _ => Ok(SharedContentDownloadsPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("SharedContentDownloadsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedContentDownloadsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("SharedContentDownloadsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            SharedContentDownloadsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("SharedContentDownloadsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            SharedContentDownloadsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Left the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRelinquishMembershipDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SharedContentRelinquishMembershipDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedContentRelinquishMembershipDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                       "original_folder_name"];
impl SharedContentRelinquishMembershipDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRelinquishMembershipDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRelinquishMembershipDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRelinquishMembershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRelinquishMembershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRelinquishMembershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRelinquishMembershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRelinquishMembershipDetails", SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRelinquishMembershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRelinquishMembershipDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed an invitee from the membership of a shared file or folder before it was claimed.
#[derive(Debug)]
pub struct SharedContentRemoveInviteeDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SharedContentRemoveInviteeDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedContentRemoveInviteeDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SHARED_CONTENT_REMOVE_INVITEE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                "original_folder_name"];
impl SharedContentRemoveInviteeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRemoveInviteeDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_INVITEE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveInviteeDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveInviteeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveInviteeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveInviteeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveInviteeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveInviteeDetails", SHARED_CONTENT_REMOVE_INVITEE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveInviteeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveInviteeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the expiry of the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkExpiryDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentRemoveLinkExpiryDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentRemoveLinkExpiryDetails {
            target_index,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                    "original_folder_name",
                                                                                    "shared_folder_type"];
impl SharedContentRemoveLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRemoveLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveLinkExpiryDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkExpiryDetails", SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkExpiryDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the password on the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkPasswordDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentRemoveLinkPasswordDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentRemoveLinkPasswordDetails {
            target_index,
            original_folder_name: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                      "original_folder_name",
                                                                                      "shared_folder_type"];
impl SharedContentRemoveLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRemoveLinkPasswordDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveLinkPasswordDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkPasswordDetails", SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkPasswordDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a user or a group from the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveMemberDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SharedContentRemoveMemberDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentRemoveMemberDetails {
            target_index,
            original_folder_name: None,
            sharing_permission: None,
            shared_folder_type: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                               "original_folder_name",
                                                                               "sharing_permission",
                                                                               "shared_folder_type"];
impl SharedContentRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRemoveMemberDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveMemberDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            sharing_permission: field_sharing_permission,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveMemberDetails", SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveMemberDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to be on the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRequestAccessDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedContentRequestAccessDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentRequestAccessDetails {
            target_index,
            original_folder_name: None,
            shared_content_link: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                "original_folder_name",
                                                                                "shared_content_link"];
impl SharedContentRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentRequestAccessDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRequestAccessDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
            shared_content_link: field_shared_content_link,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRequestAccessDetails", SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRequestAccessDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared a shared file or folder by clearing its membership and turning off its link.
#[derive(Debug)]
pub struct SharedContentUnshareDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: Option<String>,
}

impl SharedContentUnshareDetails {
    pub fn new(target_index: i64) -> Self {
        SharedContentUnshareDetails {
            target_index,
            original_folder_name: None,
        }
    }

    pub fn with_original_folder_name(mut self, value: Option<String>) -> Self {
        self.original_folder_name = value;
        self
    }

}

const SHARED_CONTENT_UNSHARE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                         "original_folder_name"];
impl SharedContentUnshareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentUnshareDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_UNSHARE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentUnshareDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentUnshareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentUnshareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentUnshareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentUnshareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentUnshareDetails", SHARED_CONTENT_UNSHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentUnshareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentUnshareDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Previewed the shared file or folder.
#[derive(Debug)]
pub struct SharedContentViewDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Target asset index.
    pub target_index: i64,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SharedContentViewDetails {
    pub fn new(shared_content_link: String, target_index: i64) -> Self {
        SharedContentViewDetails {
            shared_content_link,
            target_index,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SHARED_CONTENT_VIEW_DETAILS_FIELDS: &'static [&'static str] = &["shared_content_link",
                                                                      "target_index",
                                                                      "sharing_permission"];
impl SharedContentViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentViewDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_target_index = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_VIEW_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentViewDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentViewDetails", SHARED_CONTENT_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentViewDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared content viewer info policy
#[derive(Debug)]
pub enum SharedContentViewerInfoPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewerInfoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedContentViewerInfoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewerInfoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(SharedContentViewerInfoPolicy::Disabled),
                    "enabled" => Ok(SharedContentViewerInfoPolicy::Enabled),
                    _ => Ok(SharedContentViewerInfoPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("SharedContentViewerInfoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewerInfoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedContentViewerInfoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("SharedContentViewerInfoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            SharedContentViewerInfoPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("SharedContentViewerInfoPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            SharedContentViewerInfoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Set or unset the confidential flag on a shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeConfidentialityDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New confidentiality value.
    pub new_value: Confidentiality,
    /// Previous confidentiality value. Might be missing due to historical data gap.
    pub previous_value: Option<Confidentiality>,
}

impl SharedFolderChangeConfidentialityDetails {
    pub fn new(target_index: i64, original_folder_name: String, new_value: Confidentiality) -> Self {
        SharedFolderChangeConfidentialityDetails {
            target_index,
            original_folder_name,
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<Confidentiality>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_CONFIDENTIALITY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                       "original_folder_name",
                                                                                       "new_value",
                                                                                       "previous_value"];
impl SharedFolderChangeConfidentialityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderChangeConfidentialityDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_CONFIDENTIALITY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeConfidentialityDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeConfidentialityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeConfidentialityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeConfidentialityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeConfidentialityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeConfidentialityDetails", SHARED_FOLDER_CHANGE_CONFIDENTIALITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeConfidentialityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeConfidentialityDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can access the shared folder via a link.
#[derive(Debug)]
pub struct SharedFolderChangeLinkPolicyDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New shared folder link policy.
    pub new_value: SharedFolderLinkPolicy,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous shared folder link policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedFolderLinkPolicy>,
}

impl SharedFolderChangeLinkPolicyDetails {
    pub fn new(target_index: i64, original_folder_name: String, new_value: SharedFolderLinkPolicy) -> Self {
        SharedFolderChangeLinkPolicyDetails {
            target_index,
            original_folder_name,
            new_value,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<SharedFolderLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                   "original_folder_name",
                                                                                   "new_value",
                                                                                   "shared_folder_type",
                                                                                   "previous_value"];
impl SharedFolderChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderChangeLinkPolicyDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_value = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeLinkPolicyDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeLinkPolicyDetails", SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeLinkPolicyDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can manage the membership of a shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMemberManagementPolicyDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New membership management policy.
    pub new_value: SharedFolderMembershipManagementPolicy,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous membership management policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedFolderMembershipManagementPolicy>,
}

impl SharedFolderChangeMemberManagementPolicyDetails {
    pub fn new(target_index: i64, original_folder_name: String, new_value: SharedFolderMembershipManagementPolicy) -> Self {
        SharedFolderChangeMemberManagementPolicyDetails {
            target_index,
            original_folder_name,
            new_value,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<SharedFolderMembershipManagementPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBER_MANAGEMENT_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                                "original_folder_name",
                                                                                                "new_value",
                                                                                                "shared_folder_type",
                                                                                                "previous_value"];
impl SharedFolderChangeMemberManagementPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderChangeMemberManagementPolicyDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_value = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBER_MANAGEMENT_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeMemberManagementPolicyDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMemberManagementPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMemberManagementPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMemberManagementPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMemberManagementPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMemberManagementPolicyDetails", SHARED_FOLDER_CHANGE_MEMBER_MANAGEMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMemberManagementPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMemberManagementPolicyDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can become a member of the shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMemberPolicyDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New external invite policy.
    pub new_value: SharedFolderMemberPolicy,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedFolderMemberPolicy>,
}

impl SharedFolderChangeMemberPolicyDetails {
    pub fn new(target_index: i64, original_folder_name: String, new_value: SharedFolderMemberPolicy) -> Self {
        SharedFolderChangeMemberPolicyDetails {
            target_index,
            original_folder_name,
            new_value,
            shared_folder_type: None,
            previous_value: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<SharedFolderMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                     "original_folder_name",
                                                                                     "new_value",
                                                                                     "shared_folder_type",
                                                                                     "previous_value"];
impl SharedFolderChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderChangeMemberPolicyDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_value = None;
        let mut field_shared_folder_type = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeMemberPolicyDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            shared_folder_type: field_shared_folder_type,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMemberPolicyDetails", SHARED_FOLDER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMemberPolicyDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a shared folder.
#[derive(Debug)]
pub struct SharedFolderCreateDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Parent namespace ID. Might be missing due to historical data gap.
    pub parent_ns_id: Option<super::common::NamespaceId>,
}

impl SharedFolderCreateDetails {
    pub fn new(target_index: i64) -> Self {
        SharedFolderCreateDetails {
            target_index,
            parent_ns_id: None,
        }
    }

    pub fn with_parent_ns_id(mut self, value: Option<super::common::NamespaceId>) -> Self {
        self.parent_ns_id = value;
        self
    }

}

const SHARED_FOLDER_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                       "parent_ns_id"];
impl SharedFolderCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderCreateDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_parent_ns_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "parent_ns_id" => {
                    if field_parent_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("parent_ns_id"));
                    }
                    field_parent_ns_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderCreateDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            parent_ns_id: field_parent_ns_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("parent_ns_id", &self.parent_ns_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderCreateDetails", SHARED_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SharedFolderLinkPolicy {
    MembersOnly,
    MembersAndTeam,
    Anyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderLinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderLinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderLinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "members_only" => Ok(SharedFolderLinkPolicy::MembersOnly),
                    "members_and_team" => Ok(SharedFolderLinkPolicy::MembersAndTeam),
                    "anyone" => Ok(SharedFolderLinkPolicy::Anyone),
                    _ => Ok(SharedFolderLinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["members_only",
                                                    "members_and_team",
                                                    "anyone",
                                                    "other"];
        deserializer.deserialize_struct("SharedFolderLinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderLinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderLinkPolicy::MembersOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderLinkPolicy", 1)?;
                s.serialize_field(".tag", "members_only")?;
                s.end()
            }
            SharedFolderLinkPolicy::MembersAndTeam => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderLinkPolicy", 1)?;
                s.serialize_field(".tag", "members_and_team")?;
                s.end()
            }
            SharedFolderLinkPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderLinkPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            SharedFolderLinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling who can become a member of a shared folder
#[derive(Debug)]
pub enum SharedFolderMemberPolicy {
    TeamOnly,
    Anyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_only" => Ok(SharedFolderMemberPolicy::TeamOnly),
                    "anyone" => Ok(SharedFolderMemberPolicy::Anyone),
                    _ => Ok(SharedFolderMemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_only",
                                                    "anyone",
                                                    "other"];
        deserializer.deserialize_struct("SharedFolderMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderMemberPolicy::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMemberPolicy", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharedFolderMemberPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMemberPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            SharedFolderMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SharedFolderMembershipManagementPolicy {
    Owner,
    Editors,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMembershipManagementPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderMembershipManagementPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMembershipManagementPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "owner" => Ok(SharedFolderMembershipManagementPolicy::Owner),
                    "editors" => Ok(SharedFolderMembershipManagementPolicy::Editors),
                    _ => Ok(SharedFolderMembershipManagementPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["owner",
                                                    "editors",
                                                    "other"];
        deserializer.deserialize_struct("SharedFolderMembershipManagementPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMembershipManagementPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderMembershipManagementPolicy::Owner => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembershipManagementPolicy", 1)?;
                s.serialize_field(".tag", "owner")?;
                s.end()
            }
            SharedFolderMembershipManagementPolicy::Editors => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembershipManagementPolicy", 1)?;
                s.serialize_field(".tag", "editors")?;
                s.end()
            }
            SharedFolderMembershipManagementPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added a shared folder to own Dropbox.
#[derive(Debug)]
pub struct SharedFolderMountDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SharedFolderMountDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedFolderMountDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SHARED_FOLDER_MOUNT_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                      "original_folder_name"];
impl SharedFolderMountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderMountDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_MOUNT_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderMountDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMountDetails", SHARED_FOLDER_MOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMountDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transferred the ownership of a shared folder to another member.
#[derive(Debug)]
pub struct SharedFolderTransferOwnershipDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SharedFolderTransferOwnershipDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedFolderTransferOwnershipDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                                   "original_folder_name"];
impl SharedFolderTransferOwnershipDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderTransferOwnershipDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderTransferOwnershipDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderTransferOwnershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderTransferOwnershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderTransferOwnershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderTransferOwnershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderTransferOwnershipDetails", SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderTransferOwnershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderTransferOwnershipDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a shared folder from Dropbox.
#[derive(Debug)]
pub struct SharedFolderUnmountDetails {
    /// Target asset index.
    pub target_index: i64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SharedFolderUnmountDetails {
    pub fn new(target_index: i64, original_folder_name: String) -> Self {
        SharedFolderUnmountDetails {
            target_index,
            original_folder_name,
        }
    }

}

const SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS: &'static [&'static str] = &["target_index",
                                                                        "original_folder_name"];
impl SharedFolderUnmountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderUnmountDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderUnmountDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderUnmountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderUnmountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderUnmountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderUnmountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderUnmountDetails", SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderUnmountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderUnmountDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper document was opened.
#[derive(Debug)]
pub struct SharedNoteOpenedDetails {
}

impl Default for SharedNoteOpenedDetails {
    fn default() -> Self {
        SharedNoteOpenedDetails {
        }
    }
}

const SHARED_NOTE_OPENED_DETAILS_FIELDS: &'static [&'static str] = &[];
impl SharedNoteOpenedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedNoteOpenedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_NOTE_OPENED_DETAILS_FIELDS));
        }
        Ok(SharedNoteOpenedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedNoteOpenedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedNoteOpenedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedNoteOpenedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedNoteOpenedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedNoteOpenedDetails", SHARED_NOTE_OPENED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedNoteOpenedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedNoteOpenedDetails", 0)?.end()
    }
}

/// Changed whether team members can join shared folders owned externally (i.e. outside the team).
#[derive(Debug)]
pub struct SharingChangeFolderJoinPolicyDetails {
    /// New external join policy.
    pub new_value: SharingFolderJoinPolicy,
    /// Previous external join policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingFolderJoinPolicy>,
}

impl SharingChangeFolderJoinPolicyDetails {
    pub fn new(new_value: SharingFolderJoinPolicy) -> Self {
        SharingChangeFolderJoinPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingFolderJoinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                    "previous_value"];
impl SharingChangeFolderJoinPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharingChangeFolderJoinPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeFolderJoinPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeFolderJoinPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeFolderJoinPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeFolderJoinPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeFolderJoinPolicyDetails", SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeFolderJoinPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeFolderJoinPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share links externally (i.e. outside the team), and if so,
/// whether links should be accessible only by team members or anyone by default.
#[derive(Debug)]
pub struct SharingChangeLinkPolicyDetails {
    /// New external link accessibility policy.
    pub new_value: SharingLinkPolicy,
    /// Previous external link accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingLinkPolicy>,
}

impl SharingChangeLinkPolicyDetails {
    pub fn new(new_value: SharingLinkPolicy) -> Self {
        SharingChangeLinkPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                             "previous_value"];
impl SharingChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharingChangeLinkPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeLinkPolicyDetails", SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeLinkPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share files and folders externally (i.e. outside the team).
#[derive(Debug)]
pub struct SharingChangeMemberPolicyDetails {
    /// New external invite policy.
    pub new_value: SharingMemberPolicy,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingMemberPolicy>,
}

impl SharingChangeMemberPolicyDetails {
    pub fn new(new_value: SharingMemberPolicy) -> Self {
        SharingChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                               "previous_value"];
impl SharingChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharingChangeMemberPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeMemberPolicyDetails", SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can join shared folders owned by non team members.
#[derive(Debug)]
pub enum SharingFolderJoinPolicy {
    TeamOnly,
    Anyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingFolderJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingFolderJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingFolderJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_only" => Ok(SharingFolderJoinPolicy::TeamOnly),
                    "anyone" => Ok(SharingFolderJoinPolicy::Anyone),
                    _ => Ok(SharingFolderJoinPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_only",
                                                    "anyone",
                                                    "other"];
        deserializer.deserialize_struct("SharingFolderJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingFolderJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingFolderJoinPolicy::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharingFolderJoinPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            SharingFolderJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling if team members can share links externally
#[derive(Debug)]
pub enum SharingLinkPolicy {
    TeamOnly,
    DefaultTeamOnly,
    DefaultAnyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingLinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingLinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingLinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_only" => Ok(SharingLinkPolicy::TeamOnly),
                    "default_team_only" => Ok(SharingLinkPolicy::DefaultTeamOnly),
                    "default_anyone" => Ok(SharingLinkPolicy::DefaultAnyone),
                    _ => Ok(SharingLinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_only",
                                                    "default_team_only",
                                                    "default_anyone",
                                                    "other"];
        deserializer.deserialize_struct("SharingLinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingLinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingLinkPolicy::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharingLinkPolicy::DefaultTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_team_only")?;
                s.end()
            }
            SharingLinkPolicy::DefaultAnyone => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_anyone")?;
                s.end()
            }
            SharingLinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// External sharing policy
#[derive(Debug)]
pub enum SharingMemberPolicy {
    TeamOnly,
    Anyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_only" => Ok(SharingMemberPolicy::TeamOnly),
                    "anyone" => Ok(SharingMemberPolicy::Anyone),
                    _ => Ok(SharingMemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team_only",
                                                    "anyone",
                                                    "other"];
        deserializer.deserialize_struct("SharingMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingMemberPolicy::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharingMemberPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            SharingMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created a link to a file using an app.
#[derive(Debug)]
pub struct ShmodelAppCreateDetails {
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
    /// Shared link token key.
    pub token_key: Option<String>,
}

impl Default for ShmodelAppCreateDetails {
    fn default() -> Self {
        ShmodelAppCreateDetails {
            sharing_permission: None,
            token_key: None,
        }
    }
}

const SHMODEL_APP_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["sharing_permission",
                                                                     "token_key"];
impl ShmodelAppCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelAppCreateDetails, V::Error> {
        use serde::de;
        let mut field_sharing_permission = None;
        let mut field_token_key = None;
        while let Some(key) = map.next_key()? {
            match key {
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_APP_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(ShmodelAppCreateDetails {
            sharing_permission: field_sharing_permission,
            token_key: field_token_key,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sharing_permission", &self.sharing_permission)?;
        s.serialize_field("token_key", &self.token_key)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelAppCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelAppCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelAppCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelAppCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelAppCreateDetails", SHMODEL_APP_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelAppCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelAppCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a new link.
#[derive(Debug)]
pub struct ShmodelCreateDetails {
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
    /// Shared link token key.
    pub token_key: Option<String>,
}

impl Default for ShmodelCreateDetails {
    fn default() -> Self {
        ShmodelCreateDetails {
            sharing_permission: None,
            token_key: None,
        }
    }
}

const SHMODEL_CREATE_DETAILS_FIELDS: &'static [&'static str] = &["sharing_permission",
                                                                 "token_key"];
impl ShmodelCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelCreateDetails, V::Error> {
        use serde::de;
        let mut field_sharing_permission = None;
        let mut field_token_key = None;
        while let Some(key) = map.next_key()? {
            match key {
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(ShmodelCreateDetails {
            sharing_permission: field_sharing_permission,
            token_key: field_token_key,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sharing_permission", &self.sharing_permission)?;
        s.serialize_field("token_key", &self.token_key)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelCreateDetails", SHMODEL_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a link.
#[derive(Debug)]
pub struct ShmodelDisableDetails {
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
    /// Shared link token key.
    pub token_key: Option<String>,
}

impl Default for ShmodelDisableDetails {
    fn default() -> Self {
        ShmodelDisableDetails {
            sharing_permission: None,
            token_key: None,
        }
    }
}

const SHMODEL_DISABLE_DETAILS_FIELDS: &'static [&'static str] = &["sharing_permission",
                                                                  "token_key"];
impl ShmodelDisableDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelDisableDetails, V::Error> {
        use serde::de;
        let mut field_sharing_permission = None;
        let mut field_token_key = None;
        while let Some(key) = map.next_key()? {
            match key {
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_DISABLE_DETAILS_FIELDS))
            }
        }
        Ok(ShmodelDisableDetails {
            sharing_permission: field_sharing_permission,
            token_key: field_token_key,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sharing_permission", &self.sharing_permission)?;
        s.serialize_field("token_key", &self.token_key)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelDisableDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelDisableDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelDisableDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelDisableDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelDisableDetails", SHMODEL_DISABLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelDisableDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelDisableDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared a link with Facebook users.
#[derive(Debug)]
pub struct ShmodelFbShareDetails {
    /// Sharing non member recipients.
    pub sharing_non_member_recipients: Vec<NonTeamMemberLogInfo>,
}

impl ShmodelFbShareDetails {
    pub fn new(sharing_non_member_recipients: Vec<NonTeamMemberLogInfo>) -> Self {
        ShmodelFbShareDetails {
            sharing_non_member_recipients,
        }
    }

}

const SHMODEL_FB_SHARE_DETAILS_FIELDS: &'static [&'static str] = &["sharing_non_member_recipients"];
impl ShmodelFbShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelFbShareDetails, V::Error> {
        use serde::de;
        let mut field_sharing_non_member_recipients = None;
        while let Some(key) = map.next_key()? {
            match key {
                "sharing_non_member_recipients" => {
                    if field_sharing_non_member_recipients.is_some() {
                        return Err(de::Error::duplicate_field("sharing_non_member_recipients"));
                    }
                    field_sharing_non_member_recipients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_FB_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(ShmodelFbShareDetails {
            sharing_non_member_recipients: field_sharing_non_member_recipients.ok_or_else(|| de::Error::missing_field("sharing_non_member_recipients"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sharing_non_member_recipients", &self.sharing_non_member_recipients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelFbShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelFbShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelFbShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelFbShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelFbShareDetails", SHMODEL_FB_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelFbShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelFbShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared a link with a group.
#[derive(Debug)]
pub struct ShmodelGroupShareDetails {
}

impl Default for ShmodelGroupShareDetails {
    fn default() -> Self {
        ShmodelGroupShareDetails {
        }
    }
}

const SHMODEL_GROUP_SHARE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelGroupShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelGroupShareDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_GROUP_SHARE_DETAILS_FIELDS));
        }
        Ok(ShmodelGroupShareDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelGroupShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelGroupShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelGroupShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelGroupShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelGroupShareDetails", SHMODEL_GROUP_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelGroupShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelGroupShareDetails", 0)?.end()
    }
}

/// Removed the expiration date from a link.
#[derive(Debug)]
pub struct ShmodelRemoveExpirationDetails {
}

impl Default for ShmodelRemoveExpirationDetails {
    fn default() -> Self {
        ShmodelRemoveExpirationDetails {
        }
    }
}

const SHMODEL_REMOVE_EXPIRATION_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelRemoveExpirationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelRemoveExpirationDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_REMOVE_EXPIRATION_DETAILS_FIELDS));
        }
        Ok(ShmodelRemoveExpirationDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelRemoveExpirationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelRemoveExpirationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelRemoveExpirationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelRemoveExpirationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelRemoveExpirationDetails", SHMODEL_REMOVE_EXPIRATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelRemoveExpirationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelRemoveExpirationDetails", 0)?.end()
    }
}

/// Added an expiration date to a link.
#[derive(Debug)]
pub struct ShmodelSetExpirationDetails {
    /// Expiration starting date.
    pub expiration_start_date: String,
    /// The number of days from the starting expiration date after which the link will expire.
    pub expiration_days: i64,
}

impl ShmodelSetExpirationDetails {
    pub fn new(expiration_start_date: String, expiration_days: i64) -> Self {
        ShmodelSetExpirationDetails {
            expiration_start_date,
            expiration_days,
        }
    }

}

const SHMODEL_SET_EXPIRATION_DETAILS_FIELDS: &'static [&'static str] = &["expiration_start_date",
                                                                         "expiration_days"];
impl ShmodelSetExpirationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelSetExpirationDetails, V::Error> {
        use serde::de;
        let mut field_expiration_start_date = None;
        let mut field_expiration_days = None;
        while let Some(key) = map.next_key()? {
            match key {
                "expiration_start_date" => {
                    if field_expiration_start_date.is_some() {
                        return Err(de::Error::duplicate_field("expiration_start_date"));
                    }
                    field_expiration_start_date = Some(map.next_value()?);
                }
                "expiration_days" => {
                    if field_expiration_days.is_some() {
                        return Err(de::Error::duplicate_field("expiration_days"));
                    }
                    field_expiration_days = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_SET_EXPIRATION_DETAILS_FIELDS))
            }
        }
        Ok(ShmodelSetExpirationDetails {
            expiration_start_date: field_expiration_start_date.ok_or_else(|| de::Error::missing_field("expiration_start_date"))?,
            expiration_days: field_expiration_days.ok_or_else(|| de::Error::missing_field("expiration_days"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("expiration_start_date", &self.expiration_start_date)?;
        s.serialize_field("expiration_days", &self.expiration_days)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelSetExpirationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelSetExpirationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelSetExpirationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelSetExpirationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelSetExpirationDetails", SHMODEL_SET_EXPIRATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelSetExpirationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelSetExpirationDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a team member's file/folder to their Dropbox from a link.
#[derive(Debug)]
pub struct ShmodelTeamCopyDetails {
}

impl Default for ShmodelTeamCopyDetails {
    fn default() -> Self {
        ShmodelTeamCopyDetails {
        }
    }
}

const SHMODEL_TEAM_COPY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelTeamCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelTeamCopyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_TEAM_COPY_DETAILS_FIELDS));
        }
        Ok(ShmodelTeamCopyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelTeamCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelTeamCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelTeamCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelTeamCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelTeamCopyDetails", SHMODEL_TEAM_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelTeamCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelTeamCopyDetails", 0)?.end()
    }
}

/// Downloaded a team member's file/folder from a link.
#[derive(Debug)]
pub struct ShmodelTeamDownloadDetails {
}

impl Default for ShmodelTeamDownloadDetails {
    fn default() -> Self {
        ShmodelTeamDownloadDetails {
        }
    }
}

const SHMODEL_TEAM_DOWNLOAD_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelTeamDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelTeamDownloadDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_TEAM_DOWNLOAD_DETAILS_FIELDS));
        }
        Ok(ShmodelTeamDownloadDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelTeamDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelTeamDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelTeamDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelTeamDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelTeamDownloadDetails", SHMODEL_TEAM_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelTeamDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelTeamDownloadDetails", 0)?.end()
    }
}

/// Shared a link with team members.
#[derive(Debug)]
pub struct ShmodelTeamShareDetails {
}

impl Default for ShmodelTeamShareDetails {
    fn default() -> Self {
        ShmodelTeamShareDetails {
        }
    }
}

const SHMODEL_TEAM_SHARE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelTeamShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelTeamShareDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_TEAM_SHARE_DETAILS_FIELDS));
        }
        Ok(ShmodelTeamShareDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelTeamShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelTeamShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelTeamShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelTeamShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelTeamShareDetails", SHMODEL_TEAM_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelTeamShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelTeamShareDetails", 0)?.end()
    }
}

/// Opened a team member's link.
#[derive(Debug)]
pub struct ShmodelTeamViewDetails {
}

impl Default for ShmodelTeamViewDetails {
    fn default() -> Self {
        ShmodelTeamViewDetails {
        }
    }
}

const SHMODEL_TEAM_VIEW_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelTeamViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelTeamViewDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_TEAM_VIEW_DETAILS_FIELDS));
        }
        Ok(ShmodelTeamViewDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelTeamViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelTeamViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelTeamViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelTeamViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelTeamViewDetails", SHMODEL_TEAM_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelTeamViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelTeamViewDetails", 0)?.end()
    }
}

/// Password-protected a link.
#[derive(Debug)]
pub struct ShmodelVisibilityPasswordDetails {
}

impl Default for ShmodelVisibilityPasswordDetails {
    fn default() -> Self {
        ShmodelVisibilityPasswordDetails {
        }
    }
}

const SHMODEL_VISIBILITY_PASSWORD_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelVisibilityPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelVisibilityPasswordDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_VISIBILITY_PASSWORD_DETAILS_FIELDS));
        }
        Ok(ShmodelVisibilityPasswordDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelVisibilityPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelVisibilityPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelVisibilityPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelVisibilityPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelVisibilityPasswordDetails", SHMODEL_VISIBILITY_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelVisibilityPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelVisibilityPasswordDetails", 0)?.end()
    }
}

/// Made a file/folder visible to anyone with the link.
#[derive(Debug)]
pub struct ShmodelVisibilityPublicDetails {
}

impl Default for ShmodelVisibilityPublicDetails {
    fn default() -> Self {
        ShmodelVisibilityPublicDetails {
        }
    }
}

const SHMODEL_VISIBILITY_PUBLIC_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelVisibilityPublicDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelVisibilityPublicDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_VISIBILITY_PUBLIC_DETAILS_FIELDS));
        }
        Ok(ShmodelVisibilityPublicDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelVisibilityPublicDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelVisibilityPublicDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelVisibilityPublicDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelVisibilityPublicDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelVisibilityPublicDetails", SHMODEL_VISIBILITY_PUBLIC_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelVisibilityPublicDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelVisibilityPublicDetails", 0)?.end()
    }
}

/// Made a file/folder visible only to team members with the link.
#[derive(Debug)]
pub struct ShmodelVisibilityTeamOnlyDetails {
}

impl Default for ShmodelVisibilityTeamOnlyDetails {
    fn default() -> Self {
        ShmodelVisibilityTeamOnlyDetails {
        }
    }
}

const SHMODEL_VISIBILITY_TEAM_ONLY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl ShmodelVisibilityTeamOnlyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShmodelVisibilityTeamOnlyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_VISIBILITY_TEAM_ONLY_DETAILS_FIELDS));
        }
        Ok(ShmodelVisibilityTeamOnlyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelVisibilityTeamOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelVisibilityTeamOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelVisibilityTeamOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelVisibilityTeamOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelVisibilityTeamOnlyDetails", SHMODEL_VISIBILITY_TEAM_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelVisibilityTeamOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelVisibilityTeamOnlyDetails", 0)?.end()
    }
}

/// Ended admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionEndDetails {
}

impl Default for SignInAsSessionEndDetails {
    fn default() -> Self {
        SignInAsSessionEndDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_END_DETAILS_FIELDS: &'static [&'static str] = &[];
impl SignInAsSessionEndDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SignInAsSessionEndDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_END_DETAILS_FIELDS));
        }
        Ok(SignInAsSessionEndDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionEndDetails", SIGN_IN_AS_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionEndDetails", 0)?.end()
    }
}

/// Started admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionStartDetails {
}

impl Default for SignInAsSessionStartDetails {
    fn default() -> Self {
        SignInAsSessionStartDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_START_DETAILS_FIELDS: &'static [&'static str] = &[];
impl SignInAsSessionStartDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SignInAsSessionStartDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_START_DETAILS_FIELDS));
        }
        Ok(SignInAsSessionStartDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionStartDetails", SIGN_IN_AS_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionStartDetails", 0)?.end()
    }
}

/// Changed the default Smart Sync policy for team members.
#[derive(Debug)]
pub struct SmartSyncChangePolicyDetails {
    /// New smart sync policy.
    pub new_value: SmartSyncPolicy,
    /// Previous smart sync policy. Might be missing due to historical data gap.
    pub previous_value: Option<SmartSyncPolicy>,
}

impl SmartSyncChangePolicyDetails {
    pub fn new(new_value: SmartSyncPolicy) -> Self {
        SmartSyncChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SmartSyncPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                           "previous_value"];
impl SmartSyncChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SmartSyncChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncChangePolicyDetails", SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Smart Sync non-admin devices report created.
#[derive(Debug)]
pub struct SmartSyncCreateAdminPrivilegeReportDetails {
}

impl Default for SmartSyncCreateAdminPrivilegeReportDetails {
    fn default() -> Self {
        SmartSyncCreateAdminPrivilegeReportDetails {
        }
    }
}

const SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS: &'static [&'static str] = &[];
impl SmartSyncCreateAdminPrivilegeReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SmartSyncCreateAdminPrivilegeReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS));
        }
        Ok(SmartSyncCreateAdminPrivilegeReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncCreateAdminPrivilegeReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncCreateAdminPrivilegeReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncCreateAdminPrivilegeReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncCreateAdminPrivilegeReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", 0)?.end()
    }
}

/// Opted team into Smart Sync.
#[derive(Debug)]
pub struct SmartSyncNotOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncNotOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncNotOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                         "new_value"];
impl SmartSyncNotOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SmartSyncNotOptOutDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncNotOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncNotOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncNotOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncNotOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncNotOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncNotOptOutDetails", SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncNotOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncNotOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opted team out of Smart Sync.
#[derive(Debug)]
pub struct SmartSyncOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_OPT_OUT_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                     "new_value"];
impl SmartSyncOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SmartSyncOptOutDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_OPT_OUT_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncOptOutDetails", SMART_SYNC_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SmartSyncOptOutPolicy {
    OptedOut,
    DefaultVariant,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SmartSyncOptOutPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "opted_out" => Ok(SmartSyncOptOutPolicy::OptedOut),
                    "default" => Ok(SmartSyncOptOutPolicy::DefaultVariant),
                    _ => Ok(SmartSyncOptOutPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["opted_out",
                                                    "default",
                                                    "other"];
        deserializer.deserialize_struct("SmartSyncOptOutPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SmartSyncOptOutPolicy::OptedOut => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "opted_out")?;
                s.end()
            }
            SmartSyncOptOutPolicy::DefaultVariant => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "default")?;
                s.end()
            }
            SmartSyncOptOutPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SmartSyncPolicy {
    LocalOnly,
    Synced,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SmartSyncPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "local_only" => Ok(SmartSyncPolicy::LocalOnly),
                    "synced" => Ok(SmartSyncPolicy::Synced),
                    _ => Ok(SmartSyncPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["local_only",
                                                    "synced",
                                                    "other"];
        deserializer.deserialize_struct("SmartSyncPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SmartSyncPolicy::LocalOnly => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncPolicy", 1)?;
                s.serialize_field(".tag", "local_only")?;
                s.end()
            }
            SmartSyncPolicy::Synced => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncPolicy", 1)?;
                s.serialize_field(".tag", "synced")?;
                s.end()
            }
            SmartSyncPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SpaceLimitsLevel {
    Generous,
    Moderate,
    NoLimit,
    Strict,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceLimitsLevel {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceLimitsLevel;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceLimitsLevel structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "generous" => Ok(SpaceLimitsLevel::Generous),
                    "moderate" => Ok(SpaceLimitsLevel::Moderate),
                    "no_limit" => Ok(SpaceLimitsLevel::NoLimit),
                    "strict" => Ok(SpaceLimitsLevel::Strict),
                    _ => Ok(SpaceLimitsLevel::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["generous",
                                                    "moderate",
                                                    "no_limit",
                                                    "strict",
                                                    "other"];
        deserializer.deserialize_struct("SpaceLimitsLevel", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceLimitsLevel {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceLimitsLevel::Generous => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsLevel", 1)?;
                s.serialize_field(".tag", "generous")?;
                s.end()
            }
            SpaceLimitsLevel::Moderate => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsLevel", 1)?;
                s.serialize_field(".tag", "moderate")?;
                s.end()
            }
            SpaceLimitsLevel::NoLimit => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsLevel", 1)?;
                s.serialize_field(".tag", "no_limit")?;
                s.end()
            }
            SpaceLimitsLevel::Strict => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsLevel", 1)?;
                s.serialize_field(".tag", "strict")?;
                s.end()
            }
            SpaceLimitsLevel::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SpaceLimitsStatus {
    WithinQuota,
    NearQuota,
    OverQuota,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceLimitsStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceLimitsStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceLimitsStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "within_quota" => Ok(SpaceLimitsStatus::WithinQuota),
                    "near_quota" => Ok(SpaceLimitsStatus::NearQuota),
                    "over_quota" => Ok(SpaceLimitsStatus::OverQuota),
                    _ => Ok(SpaceLimitsStatus::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["within_quota",
                                                    "near_quota",
                                                    "over_quota",
                                                    "other"];
        deserializer.deserialize_struct("SpaceLimitsStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceLimitsStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceLimitsStatus::WithinQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "within_quota")?;
                s.end()
            }
            SpaceLimitsStatus::NearQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "near_quota")?;
                s.end()
            }
            SpaceLimitsStatus::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            SpaceLimitsStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed the X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoChangeCertDetails {
    /// SSO certificate details.
    pub certificate_details: Certificate,
}

impl SsoChangeCertDetails {
    pub fn new(certificate_details: Certificate) -> Self {
        SsoChangeCertDetails {
            certificate_details,
        }
    }

}

const SSO_CHANGE_CERT_DETAILS_FIELDS: &'static [&'static str] = &["certificate_details"];
impl SsoChangeCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoChangeCertDetails, V::Error> {
        use serde::de;
        let mut field_certificate_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "certificate_details" => {
                    if field_certificate_details.is_some() {
                        return Err(de::Error::duplicate_field("certificate_details"));
                    }
                    field_certificate_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_CERT_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeCertDetails {
            certificate_details: field_certificate_details.ok_or_else(|| de::Error::missing_field("certificate_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("certificate_details", &self.certificate_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeCertDetails", SSO_CHANGE_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeCertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLoginUrlDetails {
    /// Previous single sign-on login URL.
    pub previous_value: String,
    /// New single sign-on login URL.
    pub new_value: String,
}

impl SsoChangeLoginUrlDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        SsoChangeLoginUrlDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                       "new_value"];
impl SsoChangeLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoChangeLoginUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeLoginUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLoginUrlDetails", SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLoginUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLogoutUrlDetails {
    /// Previous single sign-on logout URL.
    pub previous_value: String,
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl SsoChangeLogoutUrlDetails {
    pub fn new(previous_value: String) -> Self {
        SsoChangeLogoutUrlDetails {
            previous_value,
            new_value: None,
        }
    }

    pub fn with_new_value(mut self, value: Option<String>) -> Self {
        self.new_value = value;
        self
    }

}

const SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                        "new_value"];
impl SsoChangeLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoChangeLogoutUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeLogoutUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLogoutUrlDetails", SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLogoutUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the single sign-on policy for the team.
#[derive(Debug)]
pub struct SsoChangePolicyDetails {
    /// New single sign-on policy.
    pub new_value: SsoPolicy,
    /// Previous single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<SsoPolicy>,
}

impl SsoChangePolicyDetails {
    pub fn new(new_value: SsoPolicy) -> Self {
        SsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SSO_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                    "previous_value"];
impl SsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangePolicyDetails", SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the SAML identity mode for SSO.
#[derive(Debug)]
pub struct SsoChangeSamlIdentityModeDetails {
    /// Previous single sign-on identity mode.
    pub previous_value: i64,
    /// New single sign-on identity mode.
    pub new_value: i64,
}

impl SsoChangeSamlIdentityModeDetails {
    pub fn new(previous_value: i64, new_value: i64) -> Self {
        SsoChangeSamlIdentityModeDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS: &'static [&'static str] = &["previous_value",
                                                                                "new_value"];
impl SsoChangeSamlIdentityModeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoChangeSamlIdentityModeDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeSamlIdentityModeDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeSamlIdentityModeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeSamlIdentityModeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeSamlIdentityModeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeSamlIdentityModeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeSamlIdentityModeDetails", SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeSamlIdentityModeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeSamlIdentityModeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in using SSO.
#[derive(Debug)]
pub struct SsoLoginFailDetails {
    /// Login failure details.
    pub error_details: FailureDetailsLogInfo,
}

impl SsoLoginFailDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        SsoLoginFailDetails {
            error_details,
        }
    }

}

const SSO_LOGIN_FAIL_DETAILS_FIELDS: &'static [&'static str] = &["error_details"];
impl SsoLoginFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SsoLoginFailDetails, V::Error> {
        use serde::de;
        let mut field_error_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_LOGIN_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(SsoLoginFailDetails {
            error_details: field_error_details.ok_or_else(|| de::Error::missing_field("error_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoLoginFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoLoginFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoLoginFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoLoginFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoLoginFailDetails", SSO_LOGIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoLoginFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoLoginFailDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// SSO policy
#[derive(Debug)]
pub enum SsoPolicy {
    Disabled,
    Optional,
    Required,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SsoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SsoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(SsoPolicy::Disabled),
                    "optional" => Ok(SsoPolicy::Optional),
                    "required" => Ok(SsoPolicy::Required),
                    _ => Ok(SsoPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "optional",
                                                    "required",
                                                    "other"];
        deserializer.deserialize_struct("SsoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SsoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SsoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("SsoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            SsoPolicy::Optional => {
                // unit
                let mut s = serializer.serialize_struct("SsoPolicy", 1)?;
                s.serialize_field(".tag", "optional")?;
                s.end()
            }
            SsoPolicy::Required => {
                // unit
                let mut s = serializer.serialize_struct("SsoPolicy", 1)?;
                s.serialize_field(".tag", "required")?;
                s.end()
            }
            SsoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created a team activity report.
#[derive(Debug)]
pub struct TeamActivityCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::Date,
    /// Report end date.
    pub end_date: super::common::Date,
}

impl TeamActivityCreateReportDetails {
    pub fn new(start_date: super::common::Date, end_date: super::common::Date) -> Self {
        TeamActivityCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS: &'static [&'static str] = &["start_date",
                                                                              "end_date"];
impl TeamActivityCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamActivityCreateReportDetails, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_end_date = None;
        while let Some(key) = map.next_key()? {
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS))
            }
        }
        Ok(TeamActivityCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| de::Error::missing_field("end_date"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportDetails", TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// An audit log event.
#[derive(Debug)]
pub struct TeamEvent {
    /// The Dropbox timestamp representing when the action was taken.
    pub timestamp: super::common::DropboxTimestamp,
    /// The category that this type of action belongs to.
    pub event_category: EventCategory,
    /// The entity who actually performed the action.
    pub actor: ActorLogInfo,
    /// True if the action involved a non team member either as the actor or as one of the affected
    /// users.
    pub involve_non_team_member: bool,
    /// The user or team on whose behalf the actor performed the action.
    pub context: ContextLogInfo,
    /// The particular type of action taken.
    pub event_type: EventType,
    /// The variable event schema applicable to this type of action, instantiated with respect to
    /// this particular action.
    pub details: EventDetails,
    /// The origin from which the actor performed the action including information about host, ip
    /// address, location, session, etc. If the action was performed programmatically via the API
    /// the origin represents the API client.
    pub origin: Option<OriginLogInfo>,
    /// Zero or more users and/or groups that are affected by the action. Note that this list
    /// doesn't include any actors or users in context.
    pub participants: Option<Vec<ParticipantLogInfo>>,
    /// Zero or more content assets involved in the action. Currently these include Dropbox files
    /// and folders but in the future we might add other asset types such as Paper documents,
    /// folders, projects, etc.
    pub assets: Option<Vec<AssetLogInfo>>,
}

impl TeamEvent {
    pub fn new(timestamp: super::common::DropboxTimestamp, event_category: EventCategory, actor: ActorLogInfo, involve_non_team_member: bool, context: ContextLogInfo, event_type: EventType, details: EventDetails) -> Self {
        TeamEvent {
            timestamp,
            event_category,
            actor,
            involve_non_team_member,
            context,
            event_type,
            details,
            origin: None,
            participants: None,
            assets: None,
        }
    }

    pub fn with_origin(mut self, value: Option<OriginLogInfo>) -> Self {
        self.origin = value;
        self
    }

    pub fn with_participants(mut self, value: Option<Vec<ParticipantLogInfo>>) -> Self {
        self.participants = value;
        self
    }

    pub fn with_assets(mut self, value: Option<Vec<AssetLogInfo>>) -> Self {
        self.assets = value;
        self
    }

}

const TEAM_EVENT_FIELDS: &'static [&'static str] = &["timestamp",
                                                     "event_category",
                                                     "actor",
                                                     "involve_non_team_member",
                                                     "context",
                                                     "event_type",
                                                     "details",
                                                     "origin",
                                                     "participants",
                                                     "assets"];
impl TeamEvent {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamEvent, V::Error> {
        use serde::de;
        let mut field_timestamp = None;
        let mut field_event_category = None;
        let mut field_actor = None;
        let mut field_involve_non_team_member = None;
        let mut field_context = None;
        let mut field_event_type = None;
        let mut field_details = None;
        let mut field_origin = None;
        let mut field_participants = None;
        let mut field_assets = None;
        while let Some(key) = map.next_key()? {
            match key {
                "timestamp" => {
                    if field_timestamp.is_some() {
                        return Err(de::Error::duplicate_field("timestamp"));
                    }
                    field_timestamp = Some(map.next_value()?);
                }
                "event_category" => {
                    if field_event_category.is_some() {
                        return Err(de::Error::duplicate_field("event_category"));
                    }
                    field_event_category = Some(map.next_value()?);
                }
                "actor" => {
                    if field_actor.is_some() {
                        return Err(de::Error::duplicate_field("actor"));
                    }
                    field_actor = Some(map.next_value()?);
                }
                "involve_non_team_member" => {
                    if field_involve_non_team_member.is_some() {
                        return Err(de::Error::duplicate_field("involve_non_team_member"));
                    }
                    field_involve_non_team_member = Some(map.next_value()?);
                }
                "context" => {
                    if field_context.is_some() {
                        return Err(de::Error::duplicate_field("context"));
                    }
                    field_context = Some(map.next_value()?);
                }
                "event_type" => {
                    if field_event_type.is_some() {
                        return Err(de::Error::duplicate_field("event_type"));
                    }
                    field_event_type = Some(map.next_value()?);
                }
                "details" => {
                    if field_details.is_some() {
                        return Err(de::Error::duplicate_field("details"));
                    }
                    field_details = Some(map.next_value()?);
                }
                "origin" => {
                    if field_origin.is_some() {
                        return Err(de::Error::duplicate_field("origin"));
                    }
                    field_origin = Some(map.next_value()?);
                }
                "participants" => {
                    if field_participants.is_some() {
                        return Err(de::Error::duplicate_field("participants"));
                    }
                    field_participants = Some(map.next_value()?);
                }
                "assets" => {
                    if field_assets.is_some() {
                        return Err(de::Error::duplicate_field("assets"));
                    }
                    field_assets = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_EVENT_FIELDS))
            }
        }
        Ok(TeamEvent {
            timestamp: field_timestamp.ok_or_else(|| de::Error::missing_field("timestamp"))?,
            event_category: field_event_category.ok_or_else(|| de::Error::missing_field("event_category"))?,
            actor: field_actor.ok_or_else(|| de::Error::missing_field("actor"))?,
            involve_non_team_member: field_involve_non_team_member.ok_or_else(|| de::Error::missing_field("involve_non_team_member"))?,
            context: field_context.ok_or_else(|| de::Error::missing_field("context"))?,
            event_type: field_event_type.ok_or_else(|| de::Error::missing_field("event_type"))?,
            details: field_details.ok_or_else(|| de::Error::missing_field("details"))?,
            origin: field_origin,
            participants: field_participants,
            assets: field_assets,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("timestamp", &self.timestamp)?;
        s.serialize_field("event_category", &self.event_category)?;
        s.serialize_field("actor", &self.actor)?;
        s.serialize_field("involve_non_team_member", &self.involve_non_team_member)?;
        s.serialize_field("context", &self.context)?;
        s.serialize_field("event_type", &self.event_type)?;
        s.serialize_field("details", &self.details)?;
        s.serialize_field("origin", &self.origin)?;
        s.serialize_field("participants", &self.participants)?;
        s.serialize_field("assets", &self.assets)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamEvent {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamEvent;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamEvent struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamEvent::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamEvent", TEAM_EVENT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamEvent {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamEvent", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the archival status of a team folder.
#[derive(Debug)]
pub struct TeamFolderChangeStatusDetails {
    /// New team folder status.
    pub new_value: TeamFolderStatus,
    /// Previous team folder status. Might be missing due to historical data gap.
    pub previous_value: Option<TeamFolderStatus>,
}

impl TeamFolderChangeStatusDetails {
    pub fn new(new_value: TeamFolderStatus) -> Self {
        TeamFolderChangeStatusDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TeamFolderStatus>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                            "previous_value"];
impl TeamFolderChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamFolderChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderChangeStatusDetails", TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a new team folder in active status.
#[derive(Debug)]
pub struct TeamFolderCreateDetails {
}

impl Default for TeamFolderCreateDetails {
    fn default() -> Self {
        TeamFolderCreateDetails {
        }
    }
}

const TEAM_FOLDER_CREATE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TeamFolderCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamFolderCreateDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_FOLDER_CREATE_DETAILS_FIELDS));
        }
        Ok(TeamFolderCreateDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateDetails", TEAM_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderCreateDetails", 0)?.end()
    }
}

/// Downgraded a team folder to a regular shared folder.
#[derive(Debug)]
pub struct TeamFolderDowngradeDetails {
    /// Target asset index.
    pub target_index: i64,
}

impl TeamFolderDowngradeDetails {
    pub fn new(target_index: i64) -> Self {
        TeamFolderDowngradeDetails {
            target_index,
        }
    }

}

const TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS: &'static [&'static str] = &["target_index"];
impl TeamFolderDowngradeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamFolderDowngradeDetails, V::Error> {
        use serde::de;
        let mut field_target_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_index" => {
                    if field_target_index.is_some() {
                        return Err(de::Error::duplicate_field("target_index"));
                    }
                    field_target_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderDowngradeDetails {
            target_index: field_target_index.ok_or_else(|| de::Error::missing_field("target_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_index", &self.target_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderDowngradeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderDowngradeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderDowngradeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderDowngradeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderDowngradeDetails", TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderDowngradeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderDowngradeDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted an archived team folder.
#[derive(Debug)]
pub struct TeamFolderPermanentlyDeleteDetails {
}

impl Default for TeamFolderPermanentlyDeleteDetails {
    fn default() -> Self {
        TeamFolderPermanentlyDeleteDetails {
        }
    }
}

const TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TeamFolderPermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamFolderPermanentlyDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS));
        }
        Ok(TeamFolderPermanentlyDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteDetails", TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderPermanentlyDeleteDetails", 0)?.end()
    }
}

/// Renamed an active or archived team folder.
#[derive(Debug)]
pub struct TeamFolderRenameDetails {
    /// Specifies the source and destination indices in the assets list.
    pub relocate_action_details: RelocateAssetReferencesLogInfo,
}

impl TeamFolderRenameDetails {
    pub fn new(relocate_action_details: RelocateAssetReferencesLogInfo) -> Self {
        TeamFolderRenameDetails {
            relocate_action_details,
        }
    }

}

const TEAM_FOLDER_RENAME_DETAILS_FIELDS: &'static [&'static str] = &["relocate_action_details"];
impl TeamFolderRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamFolderRenameDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderRenameDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameDetails", TEAM_FOLDER_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderStatus {
    Archive,
    Unarchive,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "archive" => Ok(TeamFolderStatus::Archive),
                    "unarchive" => Ok(TeamFolderStatus::Unarchive),
                    _ => Ok(TeamFolderStatus::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["archive",
                                                    "unarchive",
                                                    "other"];
        deserializer.deserialize_struct("TeamFolderStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderStatus::Archive => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderStatus", 1)?;
                s.serialize_field(".tag", "archive")?;
                s.end()
            }
            TeamFolderStatus::Unarchive => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderStatus", 1)?;
                s.serialize_field(".tag", "unarchive")?;
                s.end()
            }
            TeamFolderStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Team linked app
#[derive(Debug)]
pub struct TeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for TeamLinkedAppLogInfo {
    fn default() -> Self {
        TeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const TEAM_LINKED_APP_LOG_INFO_FIELDS: &'static [&'static str] = &["app_id",
                                                                   "display_name"];
impl TeamLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(TeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamLinkedAppLogInfo", TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team member's logged information.
#[derive(Debug)]
pub struct TeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayName>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<super::common::EmailAddress>,
    /// Team member ID. Might be missing due to historical data gap.
    pub team_member_id: Option<super::team_common::TeamMemberId>,
    /// Team member external ID.
    pub member_external_id: Option<super::team_common::MemberExternalId>,
}

impl Default for TeamMemberLogInfo {
    fn default() -> Self {
        TeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
            team_member_id: None,
            member_external_id: None,
        }
    }
}

const TEAM_MEMBER_LOG_INFO_FIELDS: &'static [&'static str] = &["account_id",
                                                               "display_name",
                                                               "email",
                                                               "team_member_id",
                                                               "member_external_id"];
impl TeamMemberLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamMemberLogInfo, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        let mut field_team_member_id = None;
        let mut field_member_external_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "member_external_id" => {
                    if field_member_external_id.is_some() {
                        return Err(de::Error::duplicate_field("member_external_id"));
                    }
                    field_member_external_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MEMBER_LOG_INFO_FIELDS))
            }
        }
        Ok(TeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
            team_member_id: field_team_member_id,
            member_external_id: field_member_external_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("member_external_id", &self.member_external_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberLogInfo", TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberLogInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamMembershipType {
    Free,
    Full,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMembershipType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "free" => Ok(TeamMembershipType::Free),
                    "full" => Ok(TeamMembershipType::Full),
                    _ => Ok(TeamMembershipType::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["free",
                                                    "full",
                                                    "other"];
        deserializer.deserialize_struct("TeamMembershipType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMembershipType::Free => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "free")?;
                s.end()
            }
            TeamMembershipType::Full => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "full")?;
                s.end()
            }
            TeamMembershipType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Merged another team into this team.
#[derive(Debug)]
pub struct TeamMergeFromDetails {
    /// The name of the team that was merged into this team.
    pub team_name: String,
}

impl TeamMergeFromDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeFromDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_FROM_DETAILS_FIELDS: &'static [&'static str] = &["team_name"];
impl TeamMergeFromDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamMergeFromDetails, V::Error> {
        use serde::de;
        let mut field_team_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_FROM_DETAILS_FIELDS))
            }
        }
        Ok(TeamMergeFromDetails {
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeFromDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeFromDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeFromDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeFromDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeFromDetails", TEAM_MERGE_FROM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeFromDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeFromDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Merged this team into another team.
#[derive(Debug)]
pub struct TeamMergeToDetails {
    /// The name of the team that this team was merged into.
    pub team_name: String,
}

impl TeamMergeToDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeToDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_TO_DETAILS_FIELDS: &'static [&'static str] = &["team_name"];
impl TeamMergeToDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamMergeToDetails, V::Error> {
        use serde::de;
        let mut field_team_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_TO_DETAILS_FIELDS))
            }
        }
        Ok(TeamMergeToDetails {
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeToDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeToDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeToDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeToDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeToDetails", TEAM_MERGE_TO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeToDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeToDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team name details
#[derive(Debug)]
pub struct TeamName {
    /// Team's display name.
    pub team_display_name: String,
    /// Team's legal name.
    pub team_legal_name: String,
}

impl TeamName {
    pub fn new(team_display_name: String, team_legal_name: String) -> Self {
        TeamName {
            team_display_name,
            team_legal_name,
        }
    }

}

const TEAM_NAME_FIELDS: &'static [&'static str] = &["team_display_name",
                                                    "team_legal_name"];
impl TeamName {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamName, V::Error> {
        use serde::de;
        let mut field_team_display_name = None;
        let mut field_team_legal_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_display_name" => {
                    if field_team_display_name.is_some() {
                        return Err(de::Error::duplicate_field("team_display_name"));
                    }
                    field_team_display_name = Some(map.next_value()?);
                }
                "team_legal_name" => {
                    if field_team_legal_name.is_some() {
                        return Err(de::Error::duplicate_field("team_legal_name"));
                    }
                    field_team_legal_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_NAME_FIELDS))
            }
        }
        Ok(TeamName {
            team_display_name: field_team_display_name.ok_or_else(|| de::Error::missing_field("team_display_name"))?,
            team_legal_name: field_team_legal_name.ok_or_else(|| de::Error::missing_field("team_legal_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_display_name", &self.team_display_name)?;
        s.serialize_field("team_legal_name", &self.team_legal_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamName {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamName;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamName struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamName::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamName", TEAM_NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamName {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamName", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileAddLogoDetails {
}

impl Default for TeamProfileAddLogoDetails {
    fn default() -> Self {
        TeamProfileAddLogoDetails {
        }
    }
}

const TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TeamProfileAddLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamProfileAddLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileAddLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileAddLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileAddLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileAddLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileAddLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileAddLogoDetails", TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileAddLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileAddLogoDetails", 0)?.end()
    }
}

/// Changed the team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileChangeLogoDetails {
}

impl Default for TeamProfileChangeLogoDetails {
    fn default() -> Self {
        TeamProfileChangeLogoDetails {
        }
    }
}

const TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TeamProfileChangeLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamProfileChangeLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileChangeLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeLogoDetails", TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileChangeLogoDetails", 0)?.end()
    }
}

/// Changed the team name.
#[derive(Debug)]
pub struct TeamProfileChangeNameDetails {
    /// New team name.
    pub new_value: TeamName,
    /// Previous teams name. Might be missing due to historical data gap.
    pub previous_value: Option<TeamName>,
}

impl TeamProfileChangeNameDetails {
    pub fn new(new_value: TeamName) -> Self {
        TeamProfileChangeNameDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TeamName>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                           "previous_value"];
impl TeamProfileChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamProfileChangeNameDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS))
            }
        }
        Ok(TeamProfileChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeNameDetails", TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileRemoveLogoDetails {
}

impl Default for TeamProfileRemoveLogoDetails {
    fn default() -> Self {
        TeamProfileRemoveLogoDetails {
        }
    }
}

const TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TeamProfileRemoveLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamProfileRemoveLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileRemoveLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileRemoveLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileRemoveLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileRemoveLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileRemoveLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileRemoveLogoDetails", TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileRemoveLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileRemoveLogoDetails", 0)?.end()
    }
}

/// Added a backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaAddBackupPhoneDetails {
}

impl Default for TfaAddBackupPhoneDetails {
    fn default() -> Self {
        TfaAddBackupPhoneDetails {
        }
    }
}

const TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaAddBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaAddBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaAddBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddBackupPhoneDetails", TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddBackupPhoneDetails", 0)?.end()
    }
}

/// Added a security key for two-step verification.
#[derive(Debug)]
pub struct TfaAddSecurityKeyDetails {
}

impl Default for TfaAddSecurityKeyDetails {
    fn default() -> Self {
        TfaAddSecurityKeyDetails {
        }
    }
}

const TFA_ADD_SECURITY_KEY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaAddSecurityKeyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaAddSecurityKeyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_ADD_SECURITY_KEY_DETAILS_FIELDS));
        }
        Ok(TfaAddSecurityKeyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddSecurityKeyDetails", TFA_ADD_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddSecurityKeyDetails", 0)?.end()
    }
}

/// Changed the backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaChangeBackupPhoneDetails {
}

impl Default for TfaChangeBackupPhoneDetails {
    fn default() -> Self {
        TfaChangeBackupPhoneDetails {
        }
    }
}

const TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaChangeBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaChangeBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaChangeBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeBackupPhoneDetails", TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaChangeBackupPhoneDetails", 0)?.end()
    }
}

/// Change two-step verification policy for the team.
#[derive(Debug)]
pub struct TfaChangePolicyDetails {
    /// New change policy.
    pub new_value: TfaPolicy,
    /// Previous change policy. Might be missing due to historical data gap.
    pub previous_value: Option<TfaPolicy>,
}

impl TfaChangePolicyDetails {
    pub fn new(new_value: TfaPolicy) -> Self {
        TfaChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TfaPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const TFA_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                    "previous_value"];
impl TfaChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(TfaChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangePolicyDetails", TFA_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled, disabled or changed the configuration for two-step verification.
#[derive(Debug)]
pub struct TfaChangeStatusDetails {
    /// The new two factor authentication configuration.
    pub new_value: TfaConfiguration,
    /// The previous two factor authentication configuration. Might be missing due to historical
    /// data gap.
    pub previous_value: Option<TfaConfiguration>,
    /// Used two factor authentication rescue code. This flag is relevant when the two factor
    /// authentication configuration is disabled.
    pub used_rescue_code: Option<bool>,
}

impl TfaChangeStatusDetails {
    pub fn new(new_value: TfaConfiguration) -> Self {
        TfaChangeStatusDetails {
            new_value,
            previous_value: None,
            used_rescue_code: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TfaConfiguration>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_used_rescue_code(mut self, value: Option<bool>) -> Self {
        self.used_rescue_code = value;
        self
    }

}

const TFA_CHANGE_STATUS_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                    "previous_value",
                                                                    "used_rescue_code"];
impl TfaChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_used_rescue_code = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "used_rescue_code" => {
                    if field_used_rescue_code.is_some() {
                        return Err(de::Error::duplicate_field("used_rescue_code"));
                    }
                    field_used_rescue_code = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(TfaChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            used_rescue_code: field_used_rescue_code,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("used_rescue_code", &self.used_rescue_code)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeStatusDetails", TFA_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Two factor authentication configuration. Note: the enabled option is deprecated.
#[derive(Debug)]
pub enum TfaConfiguration {
    Disabled,
    Enabled,
    Sms,
    Authenticator,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TfaConfiguration {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TfaConfiguration;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaConfiguration structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(TfaConfiguration::Disabled),
                    "enabled" => Ok(TfaConfiguration::Enabled),
                    "sms" => Ok(TfaConfiguration::Sms),
                    "authenticator" => Ok(TfaConfiguration::Authenticator),
                    _ => Ok(TfaConfiguration::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "sms",
                                                    "authenticator",
                                                    "other"];
        deserializer.deserialize_struct("TfaConfiguration", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TfaConfiguration {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TfaConfiguration::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TfaConfiguration::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TfaConfiguration::Sms => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "sms")?;
                s.end()
            }
            TfaConfiguration::Authenticator => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "authenticator")?;
                s.end()
            }
            TfaConfiguration::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Two factor authentication policy
#[derive(Debug)]
pub enum TfaPolicy {
    Disabled,
    Optional,
    Required,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TfaPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TfaPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(TfaPolicy::Disabled),
                    "optional" => Ok(TfaPolicy::Optional),
                    "required" => Ok(TfaPolicy::Required),
                    _ => Ok(TfaPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "optional",
                                                    "required",
                                                    "other"];
        deserializer.deserialize_struct("TfaPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TfaPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TfaPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TfaPolicy::Optional => {
                // unit
                let mut s = serializer.serialize_struct("TfaPolicy", 1)?;
                s.serialize_field(".tag", "optional")?;
                s.end()
            }
            TfaPolicy::Required => {
                // unit
                let mut s = serializer.serialize_struct("TfaPolicy", 1)?;
                s.serialize_field(".tag", "required")?;
                s.end()
            }
            TfaPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Removed the backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveBackupPhoneDetails {
}

impl Default for TfaRemoveBackupPhoneDetails {
    fn default() -> Self {
        TfaRemoveBackupPhoneDetails {
        }
    }
}

const TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaRemoveBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaRemoveBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaRemoveBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveBackupPhoneDetails", TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveBackupPhoneDetails", 0)?.end()
    }
}

/// Removed a security key for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveSecurityKeyDetails {
}

impl Default for TfaRemoveSecurityKeyDetails {
    fn default() -> Self {
        TfaRemoveSecurityKeyDetails {
        }
    }
}

const TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaRemoveSecurityKeyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaRemoveSecurityKeyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS));
        }
        Ok(TfaRemoveSecurityKeyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveSecurityKeyDetails", TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveSecurityKeyDetails", 0)?.end()
    }
}

/// Reset two-step verification for team member.
#[derive(Debug)]
pub struct TfaResetDetails {
}

impl Default for TfaResetDetails {
    fn default() -> Self {
        TfaResetDetails {
        }
    }
}

const TFA_RESET_DETAILS_FIELDS: &'static [&'static str] = &[];
impl TfaResetDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TfaResetDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_RESET_DETAILS_FIELDS));
        }
        Ok(TfaResetDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaResetDetails", TFA_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaResetDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub enum TimeUnit {
    Milliseconds,
    Seconds,
    Minutes,
    Hours,
    Days,
    Weeks,
    Months,
    Years,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TimeUnit {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TimeUnit;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TimeUnit structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "milliseconds" => Ok(TimeUnit::Milliseconds),
                    "seconds" => Ok(TimeUnit::Seconds),
                    "minutes" => Ok(TimeUnit::Minutes),
                    "hours" => Ok(TimeUnit::Hours),
                    "days" => Ok(TimeUnit::Days),
                    "weeks" => Ok(TimeUnit::Weeks),
                    "months" => Ok(TimeUnit::Months),
                    "years" => Ok(TimeUnit::Years),
                    _ => Ok(TimeUnit::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["milliseconds",
                                                    "seconds",
                                                    "minutes",
                                                    "hours",
                                                    "days",
                                                    "weeks",
                                                    "months",
                                                    "years",
                                                    "other"];
        deserializer.deserialize_struct("TimeUnit", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TimeUnit {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TimeUnit::Milliseconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "milliseconds")?;
                s.end()
            }
            TimeUnit::Seconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "seconds")?;
                s.end()
            }
            TimeUnit::Minutes => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "minutes")?;
                s.end()
            }
            TimeUnit::Hours => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "hours")?;
                s.end()
            }
            TimeUnit::Days => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "days")?;
                s.end()
            }
            TimeUnit::Weeks => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "weeks")?;
                s.end()
            }
            TimeUnit::Months => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "months")?;
                s.end()
            }
            TimeUnit::Years => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "years")?;
                s.end()
            }
            TimeUnit::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled or disabled the option for team members to link a personal Dropbox account in addition
/// to their work account to the same computer.
#[derive(Debug)]
pub struct TwoAccountChangePolicyDetails {
    /// New two account policy.
    pub new_value: TwoAccountPolicy,
    /// Previous two account policy. Might be missing due to historical data gap.
    pub previous_value: Option<TwoAccountPolicy>,
}

impl TwoAccountChangePolicyDetails {
    pub fn new(new_value: TwoAccountPolicy) -> Self {
        TwoAccountChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TwoAccountPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                            "previous_value"];
impl TwoAccountChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TwoAccountChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(TwoAccountChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TwoAccountChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TwoAccountChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TwoAccountChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TwoAccountChangePolicyDetails", TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TwoAccountChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for pairing personal account to work account
#[derive(Debug)]
pub enum TwoAccountPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TwoAccountPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TwoAccountPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(TwoAccountPolicy::Disabled),
                    "enabled" => Ok(TwoAccountPolicy::Enabled),
                    _ => Ok(TwoAccountPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disabled",
                                                    "enabled",
                                                    "other"];
        deserializer.deserialize_struct("TwoAccountPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TwoAccountPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TwoAccountPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TwoAccountPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User linked app
#[derive(Debug)]
pub struct UserLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserLinkedAppLogInfo {
    fn default() -> Self {
        UserLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_LINKED_APP_LOG_INFO_FIELDS: &'static [&'static str] = &["app_id",
                                                                   "display_name"];
impl UserLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UserLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(UserLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserLinkedAppLogInfo", USER_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User's logged information.
#[derive(Debug)]
pub enum UserLogInfo {
    TeamMember(TeamMemberLogInfo),
    NonTeamMember(NonTeamMemberLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for UserLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UserLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(UserLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(UserLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    _ => Ok(UserLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["non_team_member",
                                                    "non_team_member"];
        deserializer.deserialize_struct("UserLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UserLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            UserLogInfo::TeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 6)?;
                s.serialize_field(".tag", "team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.serialize_field("team_member_id", &x.team_member_id)?;
                s.serialize_field("member_external_id", &x.member_external_id)?;
                s.end()
            }
            UserLogInfo::NonTeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.end()
            }
            UserLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// User's name logged information
#[derive(Debug)]
pub struct UserNameLogInfo {
    /// Given name.
    pub given_name: String,
    /// Surname.
    pub surname: String,
    /// Locale. Might be missing due to historical data gap.
    pub locale: Option<String>,
}

impl UserNameLogInfo {
    pub fn new(given_name: String, surname: String) -> Self {
        UserNameLogInfo {
            given_name,
            surname,
            locale: None,
        }
    }

    pub fn with_locale(mut self, value: Option<String>) -> Self {
        self.locale = value;
        self
    }

}

const USER_NAME_LOG_INFO_FIELDS: &'static [&'static str] = &["given_name",
                                                             "surname",
                                                             "locale"];
impl UserNameLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UserNameLogInfo, V::Error> {
        use serde::de;
        let mut field_given_name = None;
        let mut field_surname = None;
        let mut field_locale = None;
        while let Some(key) = map.next_key()? {
            match key {
                "given_name" => {
                    if field_given_name.is_some() {
                        return Err(de::Error::duplicate_field("given_name"));
                    }
                    field_given_name = Some(map.next_value()?);
                }
                "surname" => {
                    if field_surname.is_some() {
                        return Err(de::Error::duplicate_field("surname"));
                    }
                    field_surname = Some(map.next_value()?);
                }
                "locale" => {
                    if field_locale.is_some() {
                        return Err(de::Error::duplicate_field("locale"));
                    }
                    field_locale = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_NAME_LOG_INFO_FIELDS))
            }
        }
        Ok(UserNameLogInfo {
            given_name: field_given_name.ok_or_else(|| de::Error::missing_field("given_name"))?,
            surname: field_surname.ok_or_else(|| de::Error::missing_field("surname"))?,
            locale: field_locale,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("given_name", &self.given_name)?;
        s.serialize_field("surname", &self.surname)?;
        s.serialize_field("locale", &self.locale)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserNameLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserNameLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserNameLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserNameLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserNameLogInfo", USER_NAME_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserNameLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserNameLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User or team linked app. Used when linked type is missing due to historical data gap.
#[derive(Debug)]
pub struct UserOrTeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserOrTeamLinkedAppLogInfo {
    fn default() -> Self {
        UserOrTeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS: &'static [&'static str] = &["app_id",
                                                                           "display_name"];
impl UserOrTeamLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UserOrTeamLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(UserOrTeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserOrTeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserOrTeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserOrTeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserOrTeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserOrTeamLinkedAppLogInfo", USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserOrTeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserOrTeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web session.
#[derive(Debug)]
pub struct WebSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for WebSessionLogInfo {
    fn default() -> Self {
        WebSessionLogInfo {
            session_id: None,
        }
    }
}

const WEB_SESSION_LOG_INFO_FIELDS: &'static [&'static str] = &["session_id"];
impl WebSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<WebSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(WebSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionLogInfo", WEB_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long team members can stay signed in to Dropbox on the web.
#[derive(Debug)]
pub struct WebSessionsChangeFixedLengthPolicyDetails {
    /// New session length policy.
    pub new_value: WebSessionsFixedLengthPolicy,
    /// Previous session length policy.
    pub previous_value: WebSessionsFixedLengthPolicy,
}

impl WebSessionsChangeFixedLengthPolicyDetails {
    pub fn new(new_value: WebSessionsFixedLengthPolicy, previous_value: WebSessionsFixedLengthPolicy) -> Self {
        WebSessionsChangeFixedLengthPolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                          "previous_value"];
impl WebSessionsChangeFixedLengthPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<WebSessionsChangeFixedLengthPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(WebSessionsChangeFixedLengthPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeFixedLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeFixedLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeFixedLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeFixedLengthPolicyDetails", WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeFixedLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeFixedLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long team members can be idle while signed in to Dropbox on the web.
#[derive(Debug)]
pub struct WebSessionsChangeIdleLengthPolicyDetails {
    /// New idle length policy.
    pub new_value: WebSessionsIdleLengthPolicy,
    /// Previous idle length policy.
    pub previous_value: WebSessionsIdleLengthPolicy,
}

impl WebSessionsChangeIdleLengthPolicyDetails {
    pub fn new(new_value: WebSessionsIdleLengthPolicy, previous_value: WebSessionsIdleLengthPolicy) -> Self {
        WebSessionsChangeIdleLengthPolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS: &'static [&'static str] = &["new_value",
                                                                                         "previous_value"];
impl WebSessionsChangeIdleLengthPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<WebSessionsChangeIdleLengthPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(WebSessionsChangeIdleLengthPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeIdleLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeIdleLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeIdleLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeIdleLengthPolicyDetails", WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeIdleLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeIdleLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web sessions fixed length policy.
#[derive(Debug)]
pub enum WebSessionsFixedLengthPolicy {
    /// Defined fixed session length.
    Defined(DurationLogInfo),
    /// Undefined fixed session length.
    Undefined,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsFixedLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsFixedLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsFixedLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsFixedLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => Ok(WebSessionsFixedLengthPolicy::Undefined),
                    _ => Ok(WebSessionsFixedLengthPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["defined",
                                                    "undefined",
                                                    "other"];
        deserializer.deserialize_struct("WebSessionsFixedLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsFixedLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsFixedLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Web sessions idle length policy.
#[derive(Debug)]
pub enum WebSessionsIdleLengthPolicy {
    /// Defined idle session length.
    Defined(DurationLogInfo),
    /// Undefined idle session length.
    Undefined,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsIdleLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsIdleLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsIdleLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsIdleLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => Ok(WebSessionsIdleLengthPolicy::Undefined),
                    _ => Ok(WebSessionsIdleLengthPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["defined",
                                                    "undefined",
                                                    "other"];
        deserializer.deserialize_struct("WebSessionsIdleLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsIdleLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsIdleLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

