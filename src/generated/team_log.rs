// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

pub type AppId = String;
pub type DeviceSessionId = String;
pub type EmailAddress = String;
pub type FilePath = String;
pub type IpAddress = String;
pub type NamespaceId = String;
pub type RequestId = String;
pub type TeamEventList = Vec<TeamEvent>;

/// Retrieves team events. Permission : Team Auditing.
pub fn get_events(
    client: &::client_trait::HttpClient,
    arg: &GetTeamEventsArg,
) -> ::Result<Result<GetTeamEventsResult, GetTeamEventsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team_log/get_events",
        arg,
        None)
}

/// Once a cursor has been retrieved from :route:`get_events`, use this to paginate through all
/// events. Permission : Team Auditing.
pub fn get_events_continue(
    client: &::client_trait::HttpClient,
    arg: &GetTeamEventsContinueArg,
) -> ::Result<Result<GetTeamEventsResult, GetTeamEventsContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team_log/get_events/continue",
        arg,
        None)
}

/// Indicates the method in which the action was performed.
#[derive(Debug)]
pub enum AccessMethodLogInfo {
    /// End user session details.
    EndUser(SessionLogInfo),
    /// Sign in as session details.
    SignInAs(WebSessionLogInfo),
    /// Content manager session details.
    ContentManager(WebSessionLogInfo),
    /// Admin console session details.
    AdminConsole(WebSessionLogInfo),
    /// Api session details.
    Api(ApiSessionLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccessMethodLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccessMethodLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccessMethodLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "end_user" => {
                        match map.next_key()? {
                            Some("end_user") => Ok(AccessMethodLogInfo::EndUser(map.next_value()?)),
                            None => Err(de::Error::missing_field("end_user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "sign_in_as" => Ok(AccessMethodLogInfo::SignInAs(WebSessionLogInfo::internal_deserialize(map)?)),
                    "content_manager" => Ok(AccessMethodLogInfo::ContentManager(WebSessionLogInfo::internal_deserialize(map)?)),
                    "admin_console" => Ok(AccessMethodLogInfo::AdminConsole(WebSessionLogInfo::internal_deserialize(map)?)),
                    "api" => Ok(AccessMethodLogInfo::Api(ApiSessionLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AccessMethodLogInfo::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["end_user",
                                    "sign_in_as",
                                    "content_manager",
                                    "admin_console",
                                    "api",
                                    "other"];
        deserializer.deserialize_struct("AccessMethodLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccessMethodLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccessMethodLogInfo::EndUser(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "end_user")?;
                s.serialize_field("end_user", x)?;
                s.end()
            }
            AccessMethodLogInfo::SignInAs(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "sign_in_as")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::ContentManager(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "content_manager")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::AdminConsole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "admin_console")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Api(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "api")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AccountCaptureAvailability {
    Unavailable,
    Available,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureAvailability {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCaptureAvailability;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureAvailability structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unavailable" => Ok(AccountCaptureAvailability::Unavailable),
                    "available" => Ok(AccountCaptureAvailability::Available),
                    _ => Ok(AccountCaptureAvailability::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["unavailable",
                                    "available",
                                    "other"];
        deserializer.deserialize_struct("AccountCaptureAvailability", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureAvailability {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCaptureAvailability::Unavailable => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "unavailable")?;
                s.end()
            }
            AccountCaptureAvailability::Available => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "available")?;
                s.end()
            }
            AccountCaptureAvailability::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Granted or revoked the option to enable account capture on domains belonging to the team.
#[derive(Debug)]
pub struct AccountCaptureChangeAvailabilityDetails {
    /// New account capture availabilty value.
    pub new_value: AccountCaptureAvailability,
    /// Previous account capture availabilty value. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCaptureAvailability>,
}

impl AccountCaptureChangeAvailabilityDetails {
    pub fn new(new_value: AccountCaptureAvailability) -> Self {
        AccountCaptureChangeAvailabilityDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCaptureAvailability>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl AccountCaptureChangeAvailabilityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureChangeAvailabilityDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureChangeAvailabilityDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangeAvailabilityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangeAvailabilityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangeAvailabilityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangeAvailabilityDetails", ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangeAvailabilityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangeAvailabilityDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureChangeAvailabilityType {
    pub description: String,
}

impl AccountCaptureChangeAvailabilityType {
    pub fn new(description: String) -> Self {
        AccountCaptureChangeAvailabilityType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureChangeAvailabilityType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureChangeAvailabilityType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_TYPE_FIELDS))
            }
        }
        Ok(AccountCaptureChangeAvailabilityType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangeAvailabilityType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangeAvailabilityType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangeAvailabilityType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangeAvailabilityType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangeAvailabilityType", ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangeAvailabilityType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangeAvailabilityType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the account capture policy on a domain belonging to the team.
#[derive(Debug)]
pub struct AccountCaptureChangePolicyDetails {
    /// New account capture policy.
    pub new_value: AccountCapturePolicy,
    /// Previous account capture policy. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCapturePolicy>,
}

impl AccountCaptureChangePolicyDetails {
    pub fn new(new_value: AccountCapturePolicy) -> Self {
        AccountCaptureChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCapturePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl AccountCaptureChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangePolicyDetails", ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureChangePolicyType {
    pub description: String,
}

impl AccountCaptureChangePolicyType {
    pub fn new(description: String) -> Self {
        AccountCaptureChangePolicyType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(AccountCaptureChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangePolicyType", ACCOUNT_CAPTURE_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Account captured user migrated their account to the team.
#[derive(Debug)]
pub struct AccountCaptureMigrateAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureMigrateAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureMigrateAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS: &[&str] = &["domain_name"];
impl AccountCaptureMigrateAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureMigrateAccountDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureMigrateAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureMigrateAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureMigrateAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureMigrateAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureMigrateAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureMigrateAccountDetails", ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureMigrateAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureMigrateAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureMigrateAccountType {
    pub description: String,
}

impl AccountCaptureMigrateAccountType {
    pub fn new(description: String) -> Self {
        AccountCaptureMigrateAccountType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureMigrateAccountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureMigrateAccountType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_TYPE_FIELDS))
            }
        }
        Ok(AccountCaptureMigrateAccountType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureMigrateAccountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureMigrateAccountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureMigrateAccountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureMigrateAccountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureMigrateAccountType", ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureMigrateAccountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureMigrateAccountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Proactive account capture email sent to all unmanaged members.
#[derive(Debug)]
pub struct AccountCaptureNotificationEmailsSentDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureNotificationEmailsSentDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureNotificationEmailsSentDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_DETAILS_FIELDS: &[&str] = &["domain_name"];
impl AccountCaptureNotificationEmailsSentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureNotificationEmailsSentDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureNotificationEmailsSentDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureNotificationEmailsSentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureNotificationEmailsSentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureNotificationEmailsSentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureNotificationEmailsSentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureNotificationEmailsSentDetails", ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureNotificationEmailsSentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureNotificationEmailsSentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureNotificationEmailsSentType {
    pub description: String,
}

impl AccountCaptureNotificationEmailsSentType {
    pub fn new(description: String) -> Self {
        AccountCaptureNotificationEmailsSentType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureNotificationEmailsSentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureNotificationEmailsSentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_TYPE_FIELDS))
            }
        }
        Ok(AccountCaptureNotificationEmailsSentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureNotificationEmailsSentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureNotificationEmailsSentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureNotificationEmailsSentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureNotificationEmailsSentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureNotificationEmailsSentType", ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureNotificationEmailsSentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureNotificationEmailsSentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AccountCapturePolicy {
    Disabled,
    InvitedUsers,
    AllUsers,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCapturePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCapturePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCapturePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(AccountCapturePolicy::Disabled),
                    "invited_users" => Ok(AccountCapturePolicy::InvitedUsers),
                    "all_users" => Ok(AccountCapturePolicy::AllUsers),
                    _ => Ok(AccountCapturePolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "invited_users",
                                    "all_users",
                                    "other"];
        deserializer.deserialize_struct("AccountCapturePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCapturePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCapturePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            AccountCapturePolicy::InvitedUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "invited_users")?;
                s.end()
            }
            AccountCapturePolicy::AllUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "all_users")?;
                s.end()
            }
            AccountCapturePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Account captured user relinquished their account by changing the email address associated with
/// it.
#[derive(Debug)]
pub struct AccountCaptureRelinquishAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureRelinquishAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureRelinquishAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS: &[&str] = &["domain_name"];
impl AccountCaptureRelinquishAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureRelinquishAccountDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS))
            }
        }
        Ok(AccountCaptureRelinquishAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureRelinquishAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureRelinquishAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureRelinquishAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureRelinquishAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureRelinquishAccountDetails", ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureRelinquishAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureRelinquishAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureRelinquishAccountType {
    pub description: String,
}

impl AccountCaptureRelinquishAccountType {
    pub fn new(description: String) -> Self {
        AccountCaptureRelinquishAccountType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureRelinquishAccountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountCaptureRelinquishAccountType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_TYPE_FIELDS))
            }
        }
        Ok(AccountCaptureRelinquishAccountType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureRelinquishAccountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureRelinquishAccountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureRelinquishAccountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureRelinquishAccountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureRelinquishAccountType", ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureRelinquishAccountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureRelinquishAccountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Additional information indicating the action taken that caused status change.
#[derive(Debug)]
pub enum ActionDetails {
    /// Additional information relevant when a new member joins the team.
    TeamJoinDetails(JoinTeamDetails),
    /// Define how the user was removed from the team.
    RemoveAction(MemberRemoveActionType),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ActionDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_join_details" => Ok(ActionDetails::TeamJoinDetails(JoinTeamDetails::internal_deserialize(map)?)),
                    "remove_action" => {
                        match map.next_key()? {
                            Some("remove_action") => Ok(ActionDetails::RemoveAction(map.next_value()?)),
                            None => Err(de::Error::missing_field("remove_action")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(ActionDetails::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["team_join_details",
                                    "remove_action",
                                    "other"];
        deserializer.deserialize_struct("ActionDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ActionDetails::TeamJoinDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActionDetails", 4)?;
                s.serialize_field(".tag", "team_join_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActionDetails::RemoveAction(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "remove_action")?;
                s.serialize_field("remove_action", x)?;
                s.end()
            }
            ActionDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The entity who performed the action.
#[derive(Debug)]
pub enum ActorLogInfo {
    /// The user who did the action.
    User(UserLogInfo),
    /// The admin who did the action.
    Admin(UserLogInfo),
    /// The application who did the action.
    App(AppLogInfo),
    /// Action done by reseller.
    Reseller(ResellerLogInfo),
    /// Action done by Dropbox.
    Dropbox,
    /// Anonymous actor.
    Anonymous,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ActorLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ActorLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ActorLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ActorLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "admin" => {
                        match map.next_key()? {
                            Some("admin") => Ok(ActorLogInfo::Admin(map.next_value()?)),
                            None => Err(de::Error::missing_field("admin")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "app" => {
                        match map.next_key()? {
                            Some("app") => Ok(ActorLogInfo::App(map.next_value()?)),
                            None => Err(de::Error::missing_field("app")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "reseller" => Ok(ActorLogInfo::Reseller(ResellerLogInfo::internal_deserialize(map)?)),
                    "dropbox" => Ok(ActorLogInfo::Dropbox),
                    "anonymous" => Ok(ActorLogInfo::Anonymous),
                    _ => Ok(ActorLogInfo::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user",
                                    "admin",
                                    "app",
                                    "reseller",
                                    "dropbox",
                                    "anonymous",
                                    "other"];
        deserializer.deserialize_struct("ActorLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ActorLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ActorLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ActorLogInfo::Admin(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "admin")?;
                s.serialize_field("admin", x)?;
                s.end()
            }
            ActorLogInfo::App(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "app")?;
                s.serialize_field("app", x)?;
                s.end()
            }
            ActorLogInfo::Reseller(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 3)?;
                s.serialize_field(".tag", "reseller")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActorLogInfo::Dropbox => {
                // unit
                let mut s = serializer.serialize_struct("ActorLogInfo", 1)?;
                s.serialize_field(".tag", "dropbox")?;
                s.end()
            }
            ActorLogInfo::Anonymous => {
                // unit
                let mut s = serializer.serialize_struct("ActorLogInfo", 1)?;
                s.serialize_field(".tag", "anonymous")?;
                s.end()
            }
            ActorLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AdminRole {
    TeamAdmin,
    UserManagementAdmin,
    SupportAdmin,
    LimitedAdmin,
    MemberOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AdminRole {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AdminRole;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AdminRole structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_admin" => Ok(AdminRole::TeamAdmin),
                    "user_management_admin" => Ok(AdminRole::UserManagementAdmin),
                    "support_admin" => Ok(AdminRole::SupportAdmin),
                    "limited_admin" => Ok(AdminRole::LimitedAdmin),
                    "member_only" => Ok(AdminRole::MemberOnly),
                    _ => Ok(AdminRole::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["team_admin",
                                    "user_management_admin",
                                    "support_admin",
                                    "limited_admin",
                                    "member_only",
                                    "other"];
        deserializer.deserialize_struct("AdminRole", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AdminRole {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AdminRole::TeamAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "team_admin")?;
                s.end()
            }
            AdminRole::UserManagementAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "user_management_admin")?;
                s.end()
            }
            AdminRole::SupportAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "support_admin")?;
                s.end()
            }
            AdminRole::LimitedAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "limited_admin")?;
                s.end()
            }
            AdminRole::MemberOnly => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "member_only")?;
                s.end()
            }
            AdminRole::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disabled allow downloads.
#[derive(Debug)]
pub struct AllowDownloadDisabledDetails {
}

impl Default for AllowDownloadDisabledDetails {
    fn default() -> Self {
        AllowDownloadDisabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS: &[&str] = &[];
impl AllowDownloadDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadDisabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS));
        }
        Ok(AllowDownloadDisabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadDisabledDetails", ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadDisabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct AllowDownloadDisabledType {
    pub description: String,
}

impl AllowDownloadDisabledType {
    pub fn new(description: String) -> Self {
        AllowDownloadDisabledType {
            description,
        }
    }

}

const ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl AllowDownloadDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadDisabledType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS))
            }
        }
        Ok(AllowDownloadDisabledType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadDisabledType", ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AllowDownloadDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled allow downloads.
#[derive(Debug)]
pub struct AllowDownloadEnabledDetails {
}

impl Default for AllowDownloadEnabledDetails {
    fn default() -> Self {
        AllowDownloadEnabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl AllowDownloadEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS));
        }
        Ok(AllowDownloadEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadEnabledDetails", ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct AllowDownloadEnabledType {
    pub description: String,
}

impl AllowDownloadEnabledType {
    pub fn new(description: String) -> Self {
        AllowDownloadEnabledType {
            description,
        }
    }

}

const ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl AllowDownloadEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadEnabledType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS))
            }
        }
        Ok(AllowDownloadEnabledType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadEnabledType", ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AllowDownloadEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Api session.
#[derive(Debug)]
pub struct ApiSessionLogInfo {
    /// Api request ID.
    pub request_id: RequestId,
}

impl ApiSessionLogInfo {
    pub fn new(request_id: RequestId) -> Self {
        ApiSessionLogInfo {
            request_id,
        }
    }

}

const API_SESSION_LOG_INFO_FIELDS: &[&str] = &["request_id"];
impl ApiSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ApiSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_request_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "request_id" => {
                    if field_request_id.is_some() {
                        return Err(de::Error::duplicate_field("request_id"));
                    }
                    field_request_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, API_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(ApiSessionLogInfo {
            request_id: field_request_id.ok_or_else(|| de::Error::missing_field("request_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_id", &self.request_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ApiSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ApiSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ApiSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ApiSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ApiSessionLogInfo", API_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ApiSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ApiSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked an app for team.
#[derive(Debug)]
pub struct AppLinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkTeamDetails {
            app_info,
        }
    }

}

const APP_LINK_TEAM_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppLinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppLinkTeamDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(AppLinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkTeamDetails", APP_LINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppLinkTeamType {
    pub description: String,
}

impl AppLinkTeamType {
    pub fn new(description: String) -> Self {
        AppLinkTeamType {
            description,
        }
    }

}

const APP_LINK_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl AppLinkTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppLinkTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_TEAM_TYPE_FIELDS))
            }
        }
        Ok(AppLinkTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkTeamType", APP_LINK_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked an app for team member.
#[derive(Debug)]
pub struct AppLinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkUserDetails {
            app_info,
        }
    }

}

const APP_LINK_USER_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppLinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppLinkUserDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_USER_DETAILS_FIELDS))
            }
        }
        Ok(AppLinkUserDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkUserDetails", APP_LINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppLinkUserType {
    pub description: String,
}

impl AppLinkUserType {
    pub fn new(description: String) -> Self {
        AppLinkUserType {
            description,
        }
    }

}

const APP_LINK_USER_TYPE_FIELDS: &[&str] = &["description"];
impl AppLinkUserType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppLinkUserType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_LINK_USER_TYPE_FIELDS))
            }
        }
        Ok(AppLinkUserType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkUserType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkUserType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLinkUserType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkUserType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkUserType", APP_LINK_USER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkUserType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkUserType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// App's logged information.
#[derive(Debug)]
pub enum AppLogInfo {
    UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo),
    UserLinkedApp(UserLinkedAppLogInfo),
    TeamLinkedApp(TeamLinkedAppLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for AppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_or_team_linked_app" => Ok(AppLogInfo::UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    "user_linked_app" => Ok(AppLogInfo::UserLinkedApp(UserLinkedAppLogInfo::internal_deserialize(map)?)),
                    "team_linked_app" => Ok(AppLogInfo::TeamLinkedApp(TeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AppLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &[&str] = &["team_linked_app",
                                    "team_linked_app",
                                    "team_linked_app"];
        deserializer.deserialize_struct("AppLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            AppLogInfo::UserOrTeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_or_team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::UserLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::TeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Unlinked an app for team.
#[derive(Debug)]
pub struct AppUnlinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkTeamDetails {
            app_info,
        }
    }

}

const APP_UNLINK_TEAM_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppUnlinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppUnlinkTeamDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(AppUnlinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkTeamDetails", APP_UNLINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppUnlinkTeamType {
    pub description: String,
}

impl AppUnlinkTeamType {
    pub fn new(description: String) -> Self {
        AppUnlinkTeamType {
            description,
        }
    }

}

const APP_UNLINK_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl AppUnlinkTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppUnlinkTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_TEAM_TYPE_FIELDS))
            }
        }
        Ok(AppUnlinkTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkTeamType", APP_UNLINK_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unlinked an app for team member.
#[derive(Debug)]
pub struct AppUnlinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkUserDetails {
            app_info,
        }
    }

}

const APP_UNLINK_USER_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppUnlinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppUnlinkUserDetails, V::Error> {
        use serde::de;
        let mut field_app_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_USER_DETAILS_FIELDS))
            }
        }
        Ok(AppUnlinkUserDetails {
            app_info: field_app_info.ok_or_else(|| de::Error::missing_field("app_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkUserDetails", APP_UNLINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppUnlinkUserType {
    pub description: String,
}

impl AppUnlinkUserType {
    pub fn new(description: String) -> Self {
        AppUnlinkUserType {
            description,
        }
    }

}

const APP_UNLINK_USER_TYPE_FIELDS: &[&str] = &["description"];
impl AppUnlinkUserType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AppUnlinkUserType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, APP_UNLINK_USER_TYPE_FIELDS))
            }
        }
        Ok(AppUnlinkUserType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkUserType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkUserType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkUserType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkUserType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkUserType", APP_UNLINK_USER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkUserType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkUserType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Asset details.
#[derive(Debug)]
pub enum AssetLogInfo {
    /// File's details.
    File(FileLogInfo),
    /// Folder's details.
    Folder(FolderLogInfo),
    /// Paper docuement's details.
    PaperDocument(PaperDocumentLogInfo),
    /// Paper folder's details.
    PaperFolder(PaperFolderLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AssetLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file" => Ok(AssetLogInfo::File(FileLogInfo::internal_deserialize(map)?)),
                    "folder" => Ok(AssetLogInfo::Folder(FolderLogInfo::internal_deserialize(map)?)),
                    "paper_document" => Ok(AssetLogInfo::PaperDocument(PaperDocumentLogInfo::internal_deserialize(map)?)),
                    "paper_folder" => Ok(AssetLogInfo::PaperFolder(PaperFolderLogInfo::internal_deserialize(map)?)),
                    _ => Ok(AssetLogInfo::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["file",
                                    "folder",
                                    "paper_document",
                                    "paper_folder",
                                    "other"];
        deserializer.deserialize_struct("AssetLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetLogInfo::File(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 4)?;
                s.serialize_field(".tag", "file")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Folder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 4)?;
                s.serialize_field(".tag", "folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperDocument(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_document")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Certificate details.
#[derive(Debug)]
pub struct Certificate {
    /// Certificate subject.
    pub subject: String,
    /// Certificate issuer.
    pub issuer: String,
    /// Certificate issue date.
    pub issue_date: String,
    /// Certificate expiration date.
    pub expiration_date: String,
    /// Certificate serial number.
    pub serial_number: String,
    /// Certificate sha1 fingerprint.
    pub sha1_fingerprint: String,
    /// Certificate common name.
    pub common_name: Option<String>,
}

impl Certificate {
    pub fn new(
        subject: String,
        issuer: String,
        issue_date: String,
        expiration_date: String,
        serial_number: String,
        sha1_fingerprint: String,
    ) -> Self {
        Certificate {
            subject,
            issuer,
            issue_date,
            expiration_date,
            serial_number,
            sha1_fingerprint,
            common_name: None,
        }
    }

    pub fn with_common_name(mut self, value: Option<String>) -> Self {
        self.common_name = value;
        self
    }

}

const CERTIFICATE_FIELDS: &[&str] = &["subject",
                                      "issuer",
                                      "issue_date",
                                      "expiration_date",
                                      "serial_number",
                                      "sha1_fingerprint",
                                      "common_name"];
impl Certificate {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<Certificate, V::Error> {
        use serde::de;
        let mut field_subject = None;
        let mut field_issuer = None;
        let mut field_issue_date = None;
        let mut field_expiration_date = None;
        let mut field_serial_number = None;
        let mut field_sha1_fingerprint = None;
        let mut field_common_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "subject" => {
                    if field_subject.is_some() {
                        return Err(de::Error::duplicate_field("subject"));
                    }
                    field_subject = Some(map.next_value()?);
                }
                "issuer" => {
                    if field_issuer.is_some() {
                        return Err(de::Error::duplicate_field("issuer"));
                    }
                    field_issuer = Some(map.next_value()?);
                }
                "issue_date" => {
                    if field_issue_date.is_some() {
                        return Err(de::Error::duplicate_field("issue_date"));
                    }
                    field_issue_date = Some(map.next_value()?);
                }
                "expiration_date" => {
                    if field_expiration_date.is_some() {
                        return Err(de::Error::duplicate_field("expiration_date"));
                    }
                    field_expiration_date = Some(map.next_value()?);
                }
                "serial_number" => {
                    if field_serial_number.is_some() {
                        return Err(de::Error::duplicate_field("serial_number"));
                    }
                    field_serial_number = Some(map.next_value()?);
                }
                "sha1_fingerprint" => {
                    if field_sha1_fingerprint.is_some() {
                        return Err(de::Error::duplicate_field("sha1_fingerprint"));
                    }
                    field_sha1_fingerprint = Some(map.next_value()?);
                }
                "common_name" => {
                    if field_common_name.is_some() {
                        return Err(de::Error::duplicate_field("common_name"));
                    }
                    field_common_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CERTIFICATE_FIELDS))
            }
        }
        Ok(Certificate {
            subject: field_subject.ok_or_else(|| de::Error::missing_field("subject"))?,
            issuer: field_issuer.ok_or_else(|| de::Error::missing_field("issuer"))?,
            issue_date: field_issue_date.ok_or_else(|| de::Error::missing_field("issue_date"))?,
            expiration_date: field_expiration_date.ok_or_else(|| de::Error::missing_field("expiration_date"))?,
            serial_number: field_serial_number.ok_or_else(|| de::Error::missing_field("serial_number"))?,
            sha1_fingerprint: field_sha1_fingerprint.ok_or_else(|| de::Error::missing_field("sha1_fingerprint"))?,
            common_name: field_common_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("subject", &self.subject)?;
        s.serialize_field("issuer", &self.issuer)?;
        s.serialize_field("issue_date", &self.issue_date)?;
        s.serialize_field("expiration_date", &self.expiration_date)?;
        s.serialize_field("serial_number", &self.serial_number)?;
        s.serialize_field("sha1_fingerprint", &self.sha1_fingerprint)?;
        s.serialize_field("common_name", &self.common_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Certificate {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Certificate;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Certificate struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Certificate::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Certificate", CERTIFICATE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Certificate {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Certificate", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared an album.
#[derive(Debug)]
pub struct CollectionShareDetails {
    /// Album name.
    pub album_name: String,
}

impl CollectionShareDetails {
    pub fn new(album_name: String) -> Self {
        CollectionShareDetails {
            album_name,
        }
    }

}

const COLLECTION_SHARE_DETAILS_FIELDS: &[&str] = &["album_name"];
impl CollectionShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<CollectionShareDetails, V::Error> {
        use serde::de;
        let mut field_album_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "album_name" => {
                    if field_album_name.is_some() {
                        return Err(de::Error::duplicate_field("album_name"));
                    }
                    field_album_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, COLLECTION_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(CollectionShareDetails {
            album_name: field_album_name.ok_or_else(|| de::Error::missing_field("album_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("album_name", &self.album_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CollectionShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionShareDetails", COLLECTION_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct CollectionShareType {
    pub description: String,
}

impl CollectionShareType {
    pub fn new(description: String) -> Self {
        CollectionShareType {
            description,
        }
    }

}

const COLLECTION_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl CollectionShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<CollectionShareType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, COLLECTION_SHARE_TYPE_FIELDS))
            }
        }
        Ok(CollectionShareType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CollectionShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionShareType", COLLECTION_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for pemanent content deletion
#[derive(Debug)]
pub enum ContentPermanentDeletePolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContentPermanentDeletePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContentPermanentDeletePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ContentPermanentDeletePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(ContentPermanentDeletePolicy::Disabled),
                    "enabled" => Ok(ContentPermanentDeletePolicy::Enabled),
                    _ => Ok(ContentPermanentDeletePolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ContentPermanentDeletePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContentPermanentDeletePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContentPermanentDeletePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The primary entity on which the action was done.
#[derive(Debug)]
pub enum ContextLogInfo {
    /// Action was done on behalf of a team member.
    TeamMember(TeamMemberLogInfo),
    /// Action was done on behalf of a non team member.
    NonTeamMember(NonTeamMemberLogInfo),
    /// Anonymous context.
    Anonymous,
    /// Action was done on behalf of the team.
    Team,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContextLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContextLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ContextLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(ContextLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(ContextLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    "anonymous" => Ok(ContextLogInfo::Anonymous),
                    "team" => Ok(ContextLogInfo::Team),
                    _ => Ok(ContextLogInfo::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["team_member",
                                    "non_team_member",
                                    "anonymous",
                                    "team",
                                    "other"];
        deserializer.deserialize_struct("ContextLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContextLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContextLogInfo::TeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 6)?;
                s.serialize_field(".tag", "team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::NonTeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::Anonymous => {
                // unit
                let mut s = serializer.serialize_struct("ContextLogInfo", 1)?;
                s.serialize_field(".tag", "anonymous")?;
                s.end()
            }
            ContextLogInfo::Team => {
                // unit
                let mut s = serializer.serialize_struct("ContextLogInfo", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            ContextLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created folders.
#[derive(Debug)]
pub struct CreateFolderDetails {
}

impl Default for CreateFolderDetails {
    fn default() -> Self {
        CreateFolderDetails {
        }
    }
}

const CREATE_FOLDER_DETAILS_FIELDS: &[&str] = &[];
impl CreateFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<CreateFolderDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, CREATE_FOLDER_DETAILS_FIELDS));
        }
        Ok(CreateFolderDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFolderDetails", CREATE_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("CreateFolderDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct CreateFolderType {
    pub description: String,
}

impl CreateFolderType {
    pub fn new(description: String) -> Self {
        CreateFolderType {
            description,
        }
    }

}

const CREATE_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl CreateFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<CreateFolderType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CREATE_FOLDER_TYPE_FIELDS))
            }
        }
        Ok(CreateFolderType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFolderType", CREATE_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set a restriction policy regarding the location of data centers where team data resides.
#[derive(Debug)]
pub struct DataPlacementRestrictionChangePolicyDetails {
    /// Previous placement restriction.
    pub previous_value: PlacementRestriction,
    /// New placement restriction.
    pub new_value: PlacementRestriction,
}

impl DataPlacementRestrictionChangePolicyDetails {
    pub fn new(previous_value: PlacementRestriction, new_value: PlacementRestriction) -> Self {
        DataPlacementRestrictionChangePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                           "new_value"];
impl DataPlacementRestrictionChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DataPlacementRestrictionChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionChangePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionChangePolicyDetails", DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DataPlacementRestrictionChangePolicyType {
    pub description: String,
}

impl DataPlacementRestrictionChangePolicyType {
    pub fn new(description: String) -> Self {
        DataPlacementRestrictionChangePolicyType {
            description,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DataPlacementRestrictionChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DataPlacementRestrictionChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionChangePolicyType", DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Satisfied a previously set restriction policy regarding the location of data centers where team
/// data resides (i.e. all data have been migrated according to the restriction placed).
#[derive(Debug)]
pub struct DataPlacementRestrictionSatisfyPolicyDetails {
    /// Placement restriction.
    pub placement_restriction: PlacementRestriction,
}

impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub fn new(placement_restriction: PlacementRestriction) -> Self {
        DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS: &[&str] = &["placement_restriction"];
impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DataPlacementRestrictionSatisfyPolicyDetails, V::Error> {
        use serde::de;
        let mut field_placement_restriction = None;
        while let Some(key) = map.next_key()? {
            match key {
                "placement_restriction" => {
                    if field_placement_restriction.is_some() {
                        return Err(de::Error::duplicate_field("placement_restriction"));
                    }
                    field_placement_restriction = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction: field_placement_restriction.ok_or_else(|| de::Error::missing_field("placement_restriction"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("placement_restriction", &self.placement_restriction)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionSatisfyPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionSatisfyPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionSatisfyPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionSatisfyPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DataPlacementRestrictionSatisfyPolicyType {
    pub description: String,
}

impl DataPlacementRestrictionSatisfyPolicyType {
    pub fn new(description: String) -> Self {
        DataPlacementRestrictionSatisfyPolicyType {
            description,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DataPlacementRestrictionSatisfyPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DataPlacementRestrictionSatisfyPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_TYPE_FIELDS))
            }
        }
        Ok(DataPlacementRestrictionSatisfyPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionSatisfyPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionSatisfyPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionSatisfyPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionSatisfyPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionSatisfyPolicyType", DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionSatisfyPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionSatisfyPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about linked Dropbox desktop client sessions
#[derive(Debug)]
pub struct DesktopDeviceSessionLogInfo {
    /// Name of the hosting desktop.
    pub host_name: String,
    /// The Dropbox desktop client type.
    pub client_type: super::team::DesktopPlatform,
    /// Information on the hosting platform.
    pub platform: String,
    /// Whether itu2019s possible to delete all of the account files upon unlinking.
    pub is_delete_on_unlink_supported: bool,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// The Dropbox client version.
    pub client_version: Option<String>,
}

impl DesktopDeviceSessionLogInfo {
    pub fn new(
        host_name: String,
        client_type: super::team::DesktopPlatform,
        platform: String,
        is_delete_on_unlink_supported: bool,
    ) -> Self {
        DesktopDeviceSessionLogInfo {
            host_name,
            client_type,
            platform,
            is_delete_on_unlink_supported,
            session_id: None,
            ip_address: None,
            created: None,
            updated: None,
            client_version: None,
        }
    }

    pub fn with_session_id(mut self, value: Option<DeviceSessionId>) -> Self {
        self.session_id = value;
        self
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_client_version(mut self, value: Option<String>) -> Self {
        self.client_version = value;
        self
    }

}

const DESKTOP_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["host_name",
                                                          "client_type",
                                                          "platform",
                                                          "is_delete_on_unlink_supported",
                                                          "session_id",
                                                          "ip_address",
                                                          "created",
                                                          "updated",
                                                          "client_version"];
impl DesktopDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DesktopDeviceSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_host_name = None;
        let mut field_client_type = None;
        let mut field_platform = None;
        let mut field_is_delete_on_unlink_supported = None;
        let mut field_session_id = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_client_version = None;
        while let Some(key) = map.next_key()? {
            match key {
                "host_name" => {
                    if field_host_name.is_some() {
                        return Err(de::Error::duplicate_field("host_name"));
                    }
                    field_host_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "is_delete_on_unlink_supported" => {
                    if field_is_delete_on_unlink_supported.is_some() {
                        return Err(de::Error::duplicate_field("is_delete_on_unlink_supported"));
                    }
                    field_is_delete_on_unlink_supported = Some(map.next_value()?);
                }
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DESKTOP_DEVICE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(DesktopDeviceSessionLogInfo {
            host_name: field_host_name.ok_or_else(|| de::Error::missing_field("host_name"))?,
            client_type: field_client_type.ok_or_else(|| de::Error::missing_field("client_type"))?,
            platform: field_platform.ok_or_else(|| de::Error::missing_field("platform"))?,
            is_delete_on_unlink_supported: field_is_delete_on_unlink_supported.ok_or_else(|| de::Error::missing_field("is_delete_on_unlink_supported"))?,
            session_id: field_session_id,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            client_version: field_client_version,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("host_name", &self.host_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("is_delete_on_unlink_supported", &self.is_delete_on_unlink_supported)?;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("client_version", &self.client_version)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DesktopDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopDeviceSessionLogInfo", DESKTOP_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopDeviceSessionLogInfo", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Desktop session.
#[derive(Debug)]
pub struct DesktopSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for DesktopSessionLogInfo {
    fn default() -> Self {
        DesktopSessionLogInfo {
            session_id: None,
        }
    }
}

const DESKTOP_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl DesktopSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DesktopSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DESKTOP_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(DesktopSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DesktopSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopSessionLogInfo", DESKTOP_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set or removed a limit on the number of computers each team member can link to their work
/// Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeDesktopPolicyDetails {
    /// New desktop device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous desktop device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeDesktopPolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl DeviceApprovalsChangeDesktopPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeDesktopPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeDesktopPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeDesktopPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeDesktopPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeDesktopPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeDesktopPolicyType {
    pub description: String,
}

impl DeviceApprovalsChangeDesktopPolicyType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeDesktopPolicyType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeDesktopPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeDesktopPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_TYPE_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeDesktopPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeDesktopPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeDesktopPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeDesktopPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeDesktopPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeDesktopPolicyType", DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeDesktopPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeDesktopPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set or removed a limit on the number of mobiles devices each team member can link to their work
/// Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeMobilePolicyDetails {
    /// New mobile device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous mobile device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeMobilePolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeMobilePolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                        "previous_value"];
impl DeviceApprovalsChangeMobilePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeMobilePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeMobilePolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeMobilePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeMobilePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeMobilePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeMobilePolicyDetails", DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeMobilePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeMobilePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeMobilePolicyType {
    pub description: String,
}

impl DeviceApprovalsChangeMobilePolicyType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeMobilePolicyType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeMobilePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeMobilePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeMobilePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeMobilePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeMobilePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeMobilePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeMobilePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeMobilePolicyType", DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeMobilePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeMobilePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the action taken when a team member is already over the limits (e.g when they join the
/// team, an admin lowers limits, etc.).
#[derive(Debug)]
pub struct DeviceApprovalsChangeOverageActionDetails {
    /// New over the limits policy. Might be missing due to historical data gap.
    pub new_value: Option<super::team_policies::RolloutMethod>,
    /// Previous over the limit policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::RolloutMethod>,
}

impl Default for DeviceApprovalsChangeOverageActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeOverageActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl DeviceApprovalsChangeOverageActionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeOverageActionDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeOverageActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeOverageActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeOverageActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeOverageActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeOverageActionDetails", DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeOverageActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeOverageActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeOverageActionType {
    pub description: String,
}

impl DeviceApprovalsChangeOverageActionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeOverageActionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeOverageActionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeOverageActionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_TYPE_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeOverageActionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeOverageActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeOverageActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeOverageActionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeOverageActionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeOverageActionType", DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeOverageActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeOverageActionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the action taken with respect to approval limits when a team member unlinks an approved
/// device.
#[derive(Debug)]
pub struct DeviceApprovalsChangeUnlinkActionDetails {
    /// New device unlink policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceUnlinkPolicy>,
    /// Previous device unlink policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceUnlinkPolicy>,
}

impl Default for DeviceApprovalsChangeUnlinkActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeUnlinkActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                        "previous_value"];
impl DeviceApprovalsChangeUnlinkActionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeUnlinkActionDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeUnlinkActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeUnlinkActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeUnlinkActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeUnlinkActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeUnlinkActionDetails", DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeUnlinkActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeUnlinkActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeUnlinkActionType {
    pub description: String,
}

impl DeviceApprovalsChangeUnlinkActionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeUnlinkActionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeUnlinkActionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeUnlinkActionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_TYPE_FIELDS))
            }
        }
        Ok(DeviceApprovalsChangeUnlinkActionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeUnlinkActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeUnlinkActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeUnlinkActionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeUnlinkActionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeUnlinkActionType", DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeUnlinkActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeUnlinkActionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceApprovalsPolicy {
    Unlimited,
    Limited,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceApprovalsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unlimited" => Ok(DeviceApprovalsPolicy::Unlimited),
                    "limited" => Ok(DeviceApprovalsPolicy::Limited),
                    _ => Ok(DeviceApprovalsPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["unlimited",
                                    "limited",
                                    "other"];
        deserializer.deserialize_struct("DeviceApprovalsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceApprovalsPolicy::Unlimited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "unlimited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Limited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "limited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// IP address associated with active desktop session changed.
#[derive(Debug)]
pub struct DeviceChangeIpDesktopDetails {
    /// Device's session logged information.
    pub device_session_info: DeviceSessionLogInfo,
}

impl DeviceChangeIpDesktopDetails {
    pub fn new(device_session_info: DeviceSessionLogInfo) -> Self {
        DeviceChangeIpDesktopDetails {
            device_session_info,
        }
    }

}

const DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceChangeIpDesktopDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpDesktopDetails, V::Error> {
        use serde::de;
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpDesktopDetails {
            device_session_info: field_device_session_info.ok_or_else(|| de::Error::missing_field("device_session_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpDesktopDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpDesktopDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpDesktopDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpDesktopDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpDesktopDetails", DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpDesktopDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpDesktopDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpDesktopType {
    pub description: String,
}

impl DeviceChangeIpDesktopType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpDesktopType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_DESKTOP_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpDesktopType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpDesktopType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_DESKTOP_TYPE_FIELDS))
            }
        }
        Ok(DeviceChangeIpDesktopType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpDesktopType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpDesktopType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpDesktopType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpDesktopType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpDesktopType", DEVICE_CHANGE_IP_DESKTOP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpDesktopType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpDesktopType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// IP address associated with active mobile session changed.
#[derive(Debug)]
pub struct DeviceChangeIpMobileDetails {
    /// Device's session logged information.
    pub device_session_info: DeviceSessionLogInfo,
}

impl DeviceChangeIpMobileDetails {
    pub fn new(device_session_info: DeviceSessionLogInfo) -> Self {
        DeviceChangeIpMobileDetails {
            device_session_info,
        }
    }

}

const DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceChangeIpMobileDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpMobileDetails, V::Error> {
        use serde::de;
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpMobileDetails {
            device_session_info: field_device_session_info.ok_or_else(|| de::Error::missing_field("device_session_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpMobileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpMobileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpMobileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpMobileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpMobileDetails", DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpMobileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpMobileDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpMobileType {
    pub description: String,
}

impl DeviceChangeIpMobileType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpMobileType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_MOBILE_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpMobileType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpMobileType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_MOBILE_TYPE_FIELDS))
            }
        }
        Ok(DeviceChangeIpMobileType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpMobileType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpMobileType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpMobileType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpMobileType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpMobileType", DEVICE_CHANGE_IP_MOBILE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpMobileType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpMobileType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// IP address associated with active Web session changed.
#[derive(Debug)]
pub struct DeviceChangeIpWebDetails {
    /// Web browser name.
    pub user_agent: String,
    /// Device's session logged information. Might be missing due to historical data gap.
    pub device_session_info: Option<DeviceSessionLogInfo>,
}

impl DeviceChangeIpWebDetails {
    pub fn new(user_agent: String) -> Self {
        DeviceChangeIpWebDetails {
            user_agent,
            device_session_info: None,
        }
    }

    pub fn with_device_session_info(mut self, value: Option<DeviceSessionLogInfo>) -> Self {
        self.device_session_info = value;
        self
    }

}

const DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS: &[&str] = &["user_agent",
                                                       "device_session_info"];
impl DeviceChangeIpWebDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpWebDetails, V::Error> {
        use serde::de;
        let mut field_user_agent = None;
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS))
            }
        }
        Ok(DeviceChangeIpWebDetails {
            user_agent: field_user_agent.ok_or_else(|| de::Error::missing_field("user_agent"))?,
            device_session_info: field_device_session_info,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_agent", &self.user_agent)?;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpWebDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpWebDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpWebDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpWebDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpWebDetails", DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpWebDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpWebDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpWebType {
    pub description: String,
}

impl DeviceChangeIpWebType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpWebType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_WEB_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpWebType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpWebType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_CHANGE_IP_WEB_TYPE_FIELDS))
            }
        }
        Ok(DeviceChangeIpWebType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpWebType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpWebType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpWebType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpWebType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpWebType", DEVICE_CHANGE_IP_WEB_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpWebType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpWebType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to delete all files from an unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkFailDetails {
    /// The number of times that remote file deletion failed.
    pub num_failures: i64,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl DeviceDeleteOnUnlinkFailDetails {
    pub fn new(num_failures: i64) -> Self {
        DeviceDeleteOnUnlinkFailDetails {
            num_failures,
            session_id: None,
            display_name: None,
        }
    }

    pub fn with_session_id(mut self, value: Option<DeviceSessionId>) -> Self {
        self.session_id = value;
        self
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

}

const DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS: &[&str] = &["num_failures",
                                                               "session_id",
                                                               "display_name"];
impl DeviceDeleteOnUnlinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceDeleteOnUnlinkFailDetails, V::Error> {
        use serde::de;
        let mut field_num_failures = None;
        let mut field_session_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "num_failures" => {
                    if field_num_failures.is_some() {
                        return Err(de::Error::duplicate_field("num_failures"));
                    }
                    field_num_failures = Some(map.next_value()?);
                }
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkFailDetails {
            num_failures: field_num_failures.ok_or_else(|| de::Error::missing_field("num_failures"))?,
            session_id: field_session_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("num_failures", &self.num_failures)?;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkFailDetails", DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkFailDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkFailType {
    pub description: String,
}

impl DeviceDeleteOnUnlinkFailType {
    pub fn new(description: String) -> Self {
        DeviceDeleteOnUnlinkFailType {
            description,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceDeleteOnUnlinkFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceDeleteOnUnlinkFailType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_FAIL_TYPE_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkFailType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkFailType", DEVICE_DELETE_ON_UNLINK_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted all files from an unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkSuccessDetails {
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for DeviceDeleteOnUnlinkSuccessDetails {
    fn default() -> Self {
        DeviceDeleteOnUnlinkSuccessDetails {
            session_id: None,
            display_name: None,
        }
    }
}

const DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS: &[&str] = &["session_id",
                                                                  "display_name"];
impl DeviceDeleteOnUnlinkSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceDeleteOnUnlinkSuccessDetails, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkSuccessDetails {
            session_id: field_session_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkSuccessDetails", DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkSuccessType {
    pub description: String,
}

impl DeviceDeleteOnUnlinkSuccessType {
    pub fn new(description: String) -> Self {
        DeviceDeleteOnUnlinkSuccessType {
            description,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceDeleteOnUnlinkSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceDeleteOnUnlinkSuccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_DELETE_ON_UNLINK_SUCCESS_TYPE_FIELDS))
            }
        }
        Ok(DeviceDeleteOnUnlinkSuccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkSuccessType", DEVICE_DELETE_ON_UNLINK_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to link a device.
#[derive(Debug)]
pub struct DeviceLinkFailDetails {
    /// A description of the device used while user approval blocked.
    pub device_type: DeviceType,
    /// IP address. Might be missing due to historical data gap.
    pub ip_address: Option<IpAddress>,
}

impl DeviceLinkFailDetails {
    pub fn new(device_type: DeviceType) -> Self {
        DeviceLinkFailDetails {
            device_type,
            ip_address: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

}

const DEVICE_LINK_FAIL_DETAILS_FIELDS: &[&str] = &["device_type",
                                                   "ip_address"];
impl DeviceLinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceLinkFailDetails, V::Error> {
        use serde::de;
        let mut field_device_type = None;
        let mut field_ip_address = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DeviceLinkFailDetails {
            device_type: field_device_type.ok_or_else(|| de::Error::missing_field("device_type"))?,
            ip_address: field_ip_address,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("ip_address", &self.ip_address)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkFailDetails", DEVICE_LINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceLinkFailType {
    pub description: String,
}

impl DeviceLinkFailType {
    pub fn new(description: String) -> Self {
        DeviceLinkFailType {
            description,
        }
    }

}

const DEVICE_LINK_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceLinkFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceLinkFailType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_FAIL_TYPE_FIELDS))
            }
        }
        Ok(DeviceLinkFailType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkFailType", DEVICE_LINK_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked a device.
#[derive(Debug)]
pub struct DeviceLinkSuccessDetails {
    /// Device's session logged information.
    pub device_session_info: DeviceSessionLogInfo,
}

impl DeviceLinkSuccessDetails {
    pub fn new(device_session_info: DeviceSessionLogInfo) -> Self {
        DeviceLinkSuccessDetails {
            device_session_info,
        }
    }

}

const DEVICE_LINK_SUCCESS_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceLinkSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceLinkSuccessDetails, V::Error> {
        use serde::de;
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DeviceLinkSuccessDetails {
            device_session_info: field_device_session_info.ok_or_else(|| de::Error::missing_field("device_session_info"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkSuccessDetails", DEVICE_LINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkSuccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceLinkSuccessType {
    pub description: String,
}

impl DeviceLinkSuccessType {
    pub fn new(description: String) -> Self {
        DeviceLinkSuccessType {
            description,
        }
    }

}

const DEVICE_LINK_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceLinkSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceLinkSuccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_LINK_SUCCESS_TYPE_FIELDS))
            }
        }
        Ok(DeviceLinkSuccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkSuccessType", DEVICE_LINK_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disable Device Management.
#[derive(Debug)]
pub struct DeviceManagementDisabledDetails {
}

impl Default for DeviceManagementDisabledDetails {
    fn default() -> Self {
        DeviceManagementDisabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS: &[&str] = &[];
impl DeviceManagementDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementDisabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS));
        }
        Ok(DeviceManagementDisabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementDisabledDetails", DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementDisabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceManagementDisabledType {
    pub description: String,
}

impl DeviceManagementDisabledType {
    pub fn new(description: String) -> Self {
        DeviceManagementDisabledType {
            description,
        }
    }

}

const DEVICE_MANAGEMENT_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceManagementDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementDisabledType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_DISABLED_TYPE_FIELDS))
            }
        }
        Ok(DeviceManagementDisabledType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementDisabledType", DEVICE_MANAGEMENT_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceManagementDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enable Device Management.
#[derive(Debug)]
pub struct DeviceManagementEnabledDetails {
}

impl Default for DeviceManagementEnabledDetails {
    fn default() -> Self {
        DeviceManagementEnabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl DeviceManagementEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS));
        }
        Ok(DeviceManagementEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementEnabledDetails", DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceManagementEnabledType {
    pub description: String,
}

impl DeviceManagementEnabledType {
    pub fn new(description: String) -> Self {
        DeviceManagementEnabledType {
            description,
        }
    }

}

const DEVICE_MANAGEMENT_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceManagementEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementEnabledType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_MANAGEMENT_ENABLED_TYPE_FIELDS))
            }
        }
        Ok(DeviceManagementEnabledType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementEnabledType", DEVICE_MANAGEMENT_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceManagementEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Device's session logged information.
#[derive(Debug)]
pub enum DeviceSessionLogInfo {
    DesktopDeviceSession(DesktopDeviceSessionLogInfo),
    MobileDeviceSession(MobileDeviceSessionLogInfo),
    WebDeviceSession(WebDeviceSessionLogInfo),
    LegacyDeviceSession(LegacyDeviceSessionLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceSessionLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "desktop_device_session" => Ok(DeviceSessionLogInfo::DesktopDeviceSession(DesktopDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "mobile_device_session" => Ok(DeviceSessionLogInfo::MobileDeviceSession(MobileDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "web_device_session" => Ok(DeviceSessionLogInfo::WebDeviceSession(WebDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "legacy_device_session" => Ok(DeviceSessionLogInfo::LegacyDeviceSession(LegacyDeviceSessionLogInfo::internal_deserialize(map)?)),
                    _ => Ok(DeviceSessionLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &[&str] = &["legacy_device_session",
                                    "legacy_device_session",
                                    "legacy_device_session",
                                    "legacy_device_session"];
        deserializer.deserialize_struct("DeviceSessionLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceSessionLogInfo::DesktopDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 10)?;
                s.serialize_field(".tag", "desktop_device_session")?;
                s.serialize_field("host_name", &x.host_name)?;
                s.serialize_field("client_type", &x.client_type)?;
                s.serialize_field("platform", &x.platform)?;
                s.serialize_field("is_delete_on_unlink_supported", &x.is_delete_on_unlink_supported)?;
                s.serialize_field("session_id", &x.session_id)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.end()
            }
            DeviceSessionLogInfo::MobileDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 10)?;
                s.serialize_field(".tag", "mobile_device_session")?;
                s.serialize_field("device_name", &x.device_name)?;
                s.serialize_field("client_type", &x.client_type)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.serialize_field("last_carrier", &x.last_carrier)?;
                s.serialize_field("session_id", &x.session_id)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("os_version", &x.os_version)?;
                s.end()
            }
            DeviceSessionLogInfo::WebDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 8)?;
                s.serialize_field(".tag", "web_device_session")?;
                s.serialize_field("user_agent", &x.user_agent)?;
                s.serialize_field("os", &x.os)?;
                s.serialize_field("browser", &x.browser)?;
                s.serialize_field("session_id", &x.session_id)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.end()
            }
            DeviceSessionLogInfo::LegacyDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 13)?;
                s.serialize_field(".tag", "legacy_device_session")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("is_emm_managed", &x.is_emm_managed)?;
                s.serialize_field("platform", &x.platform)?;
                s.serialize_field("mac_address", &x.mac_address)?;
                s.serialize_field("os_version", &x.os_version)?;
                s.serialize_field("device_type", &x.device_type)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.serialize_field("legacy_uniq_id", &x.legacy_uniq_id)?;
                s.end()
            }
            DeviceSessionLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

#[derive(Debug)]
pub enum DeviceType {
    Desktop,
    Mobile,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "desktop" => Ok(DeviceType::Desktop),
                    "mobile" => Ok(DeviceType::Mobile),
                    _ => Ok(DeviceType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["desktop",
                                    "mobile",
                                    "other"];
        deserializer.deserialize_struct("DeviceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceType::Desktop => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "desktop")?;
                s.end()
            }
            DeviceType::Mobile => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "mobile")?;
                s.end()
            }
            DeviceType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disconnected a device.
#[derive(Debug)]
pub struct DeviceUnlinkDetails {
    /// True if the user requested to delete data after device unlink, false otherwise.
    pub delete_data: bool,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl DeviceUnlinkDetails {
    pub fn new(delete_data: bool) -> Self {
        DeviceUnlinkDetails {
            delete_data,
            session_id: None,
            display_name: None,
        }
    }

    pub fn with_session_id(mut self, value: Option<DeviceSessionId>) -> Self {
        self.session_id = value;
        self
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

}

const DEVICE_UNLINK_DETAILS_FIELDS: &[&str] = &["delete_data",
                                                "session_id",
                                                "display_name"];
impl DeviceUnlinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceUnlinkDetails, V::Error> {
        use serde::de;
        let mut field_delete_data = None;
        let mut field_session_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "delete_data" => {
                    if field_delete_data.is_some() {
                        return Err(de::Error::duplicate_field("delete_data"));
                    }
                    field_delete_data = Some(map.next_value()?);
                }
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_UNLINK_DETAILS_FIELDS))
            }
        }
        Ok(DeviceUnlinkDetails {
            delete_data: field_delete_data.ok_or_else(|| de::Error::missing_field("delete_data"))?,
            session_id: field_session_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("delete_data", &self.delete_data)?;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceUnlinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceUnlinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceUnlinkDetails", DEVICE_UNLINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceUnlinkDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceUnlinkPolicy {
    Remove,
    Keep,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceUnlinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove" => Ok(DeviceUnlinkPolicy::Remove),
                    "keep" => Ok(DeviceUnlinkPolicy::Keep),
                    _ => Ok(DeviceUnlinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["remove",
                                    "keep",
                                    "other"];
        deserializer.deserialize_struct("DeviceUnlinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceUnlinkPolicy::Remove => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "remove")?;
                s.end()
            }
            DeviceUnlinkPolicy::Keep => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "keep")?;
                s.end()
            }
            DeviceUnlinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct DeviceUnlinkType {
    pub description: String,
}

impl DeviceUnlinkType {
    pub fn new(description: String) -> Self {
        DeviceUnlinkType {
            description,
        }
    }

}

const DEVICE_UNLINK_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceUnlinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceUnlinkType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_UNLINK_TYPE_FIELDS))
            }
        }
        Ok(DeviceUnlinkType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceUnlinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceUnlinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceUnlinkType", DEVICE_UNLINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceUnlinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disabled domain invites.
#[derive(Debug)]
pub struct DisabledDomainInvitesDetails {
}

impl Default for DisabledDomainInvitesDetails {
    fn default() -> Self {
        DisabledDomainInvitesDetails {
        }
    }
}

const DISABLED_DOMAIN_INVITES_DETAILS_FIELDS: &[&str] = &[];
impl DisabledDomainInvitesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DisabledDomainInvitesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DISABLED_DOMAIN_INVITES_DETAILS_FIELDS));
        }
        Ok(DisabledDomainInvitesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DisabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DisabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DisabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DisabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DisabledDomainInvitesDetails", DISABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DisabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DisabledDomainInvitesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DisabledDomainInvitesType {
    pub description: String,
}

impl DisabledDomainInvitesType {
    pub fn new(description: String) -> Self {
        DisabledDomainInvitesType {
            description,
        }
    }

}

const DISABLED_DOMAIN_INVITES_TYPE_FIELDS: &[&str] = &["description"];
impl DisabledDomainInvitesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DisabledDomainInvitesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DISABLED_DOMAIN_INVITES_TYPE_FIELDS))
            }
        }
        Ok(DisabledDomainInvitesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DisabledDomainInvitesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DisabledDomainInvitesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DisabledDomainInvitesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DisabledDomainInvitesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DisabledDomainInvitesType", DISABLED_DOMAIN_INVITES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DisabledDomainInvitesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DisabledDomainInvitesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Approved a member's request to join the team.
#[derive(Debug)]
pub struct DomainInvitesApproveRequestToJoinTeamDetails {
}

impl Default for DomainInvitesApproveRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesApproveRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesApproveRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesApproveRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesApproveRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesApproveRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesApproveRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesApproveRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesApproveRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesApproveRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesApproveRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesApproveRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesApproveRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesApproveRequestToJoinTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesApproveRequestToJoinTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesApproveRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesApproveRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesApproveRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesApproveRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesApproveRequestToJoinTeamType", DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesApproveRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesApproveRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Declined a user's request to join the team.
#[derive(Debug)]
pub struct DomainInvitesDeclineRequestToJoinTeamDetails {
}

impl Default for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesDeclineRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesDeclineRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesDeclineRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesDeclineRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesDeclineRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesDeclineRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesDeclineRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesDeclineRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesDeclineRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesDeclineRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesDeclineRequestToJoinTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesDeclineRequestToJoinTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesDeclineRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesDeclineRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesDeclineRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesDeclineRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesDeclineRequestToJoinTeamType", DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesDeclineRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesDeclineRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent domain invites to existing domain accounts.
#[derive(Debug)]
pub struct DomainInvitesEmailExistingUsersDetails {
    /// Domain names.
    pub domain_name: Vec<String>,
    /// Number of recipients.
    pub num_recipients: u64,
}

impl DomainInvitesEmailExistingUsersDetails {
    pub fn new(domain_name: Vec<String>, num_recipients: u64) -> Self {
        DomainInvitesEmailExistingUsersDetails {
            domain_name,
            num_recipients,
        }
    }

}

const DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS: &[&str] = &["domain_name",
                                                                      "num_recipients"];
impl DomainInvitesEmailExistingUsersDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesEmailExistingUsersDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        let mut field_num_recipients = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "num_recipients" => {
                    if field_num_recipients.is_some() {
                        return Err(de::Error::duplicate_field("num_recipients"));
                    }
                    field_num_recipients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS))
            }
        }
        Ok(DomainInvitesEmailExistingUsersDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
            num_recipients: field_num_recipients.ok_or_else(|| de::Error::missing_field("num_recipients"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("num_recipients", &self.num_recipients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesEmailExistingUsersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesEmailExistingUsersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesEmailExistingUsersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesEmailExistingUsersDetails", DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesEmailExistingUsersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesEmailExistingUsersDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesEmailExistingUsersType {
    pub description: String,
}

impl DomainInvitesEmailExistingUsersType {
    pub fn new(description: String) -> Self {
        DomainInvitesEmailExistingUsersType {
            description,
        }
    }

}

const DOMAIN_INVITES_EMAIL_EXISTING_USERS_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesEmailExistingUsersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesEmailExistingUsersType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_EMAIL_EXISTING_USERS_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesEmailExistingUsersType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesEmailExistingUsersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesEmailExistingUsersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesEmailExistingUsersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesEmailExistingUsersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesEmailExistingUsersType", DOMAIN_INVITES_EMAIL_EXISTING_USERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesEmailExistingUsersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesEmailExistingUsersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Asked to join the team.
#[derive(Debug)]
pub struct DomainInvitesRequestToJoinTeamDetails {
}

impl Default for DomainInvitesRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesRequestToJoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesRequestToJoinTeamDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS));
        }
        Ok(DomainInvitesRequestToJoinTeamDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesRequestToJoinTeamDetails", DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesRequestToJoinTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesRequestToJoinTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesRequestToJoinTeamType", DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Turned off u201cAutomatically invite new usersu201d.
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToNoDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToNoDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesSetInviteNewUserPrefToNoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToNoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS));
        }
        Ok(DomainInvitesSetInviteNewUserPrefToNoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToNoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToNoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToNoType {
    pub description: String,
}

impl DomainInvitesSetInviteNewUserPrefToNoType {
    pub fn new(description: String) -> Self {
        DomainInvitesSetInviteNewUserPrefToNoType {
            description,
        }
    }

}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesSetInviteNewUserPrefToNoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToNoType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesSetInviteNewUserPrefToNoType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToNoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToNoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToNoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToNoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToNoType", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToNoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToNoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Turned on u201cAutomatically invite new usersu201d.
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToYesDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToYesDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesSetInviteNewUserPrefToYesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToYesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS));
        }
        Ok(DomainInvitesSetInviteNewUserPrefToYesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToYesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToYesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToYesType {
    pub description: String,
}

impl DomainInvitesSetInviteNewUserPrefToYesType {
    pub fn new(description: String) -> Self {
        DomainInvitesSetInviteNewUserPrefToYesType {
            description,
        }
    }

}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesSetInviteNewUserPrefToYesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToYesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_TYPE_FIELDS))
            }
        }
        Ok(DomainInvitesSetInviteNewUserPrefToYesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToYesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToYesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToYesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToYesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToYesType", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToYesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToYesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to verify a domain belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationAddDomainFailDetails {
    /// Domain name.
    pub domain_name: String,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainFailDetails {
    pub fn new(domain_name: String) -> Self {
        DomainVerificationAddDomainFailDetails {
            domain_name,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS: &[&str] = &["domain_name",
                                                                      "verification_method"];
impl DomainVerificationAddDomainFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationAddDomainFailDetails, V::Error> {
        use serde::de;
        let mut field_domain_name = None;
        let mut field_verification_method = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainFailDetails {
            domain_name: field_domain_name.ok_or_else(|| de::Error::missing_field("domain_name"))?,
            verification_method: field_verification_method,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainFailDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationAddDomainFailType {
    pub description: String,
}

impl DomainVerificationAddDomainFailType {
    pub fn new(description: String) -> Self {
        DomainVerificationAddDomainFailType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationAddDomainFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationAddDomainFailType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_TYPE_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainFailType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainFailType", DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Verified a domain belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationAddDomainSuccessDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainSuccessDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationAddDomainSuccessDetails {
            domain_names,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS: &[&str] = &["domain_names",
                                                                         "verification_method"];
impl DomainVerificationAddDomainSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationAddDomainSuccessDetails, V::Error> {
        use serde::de;
        let mut field_domain_names = None;
        let mut field_verification_method = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainSuccessDetails {
            domain_names: field_domain_names.ok_or_else(|| de::Error::missing_field("domain_names"))?,
            verification_method: field_verification_method,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainSuccessDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationAddDomainSuccessType {
    pub description: String,
}

impl DomainVerificationAddDomainSuccessType {
    pub fn new(description: String) -> Self {
        DomainVerificationAddDomainSuccessType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationAddDomainSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationAddDomainSuccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_TYPE_FIELDS))
            }
        }
        Ok(DomainVerificationAddDomainSuccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainSuccessType", DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a domain from the list of verified domains belonging to the team.
#[derive(Debug)]
pub struct DomainVerificationRemoveDomainDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
}

impl DomainVerificationRemoveDomainDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationRemoveDomainDetails {
            domain_names,
        }
    }

}

const DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS: &[&str] = &["domain_names"];
impl DomainVerificationRemoveDomainDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationRemoveDomainDetails, V::Error> {
        use serde::de;
        let mut field_domain_names = None;
        while let Some(key) = map.next_key()? {
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS))
            }
        }
        Ok(DomainVerificationRemoveDomainDetails {
            domain_names: field_domain_names.ok_or_else(|| de::Error::missing_field("domain_names"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationRemoveDomainDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationRemoveDomainDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationRemoveDomainDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationRemoveDomainDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationRemoveDomainDetails", DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationRemoveDomainDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationRemoveDomainDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationRemoveDomainType {
    pub description: String,
}

impl DomainVerificationRemoveDomainType {
    pub fn new(description: String) -> Self {
        DomainVerificationRemoveDomainType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_REMOVE_DOMAIN_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationRemoveDomainType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainVerificationRemoveDomainType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DOMAIN_VERIFICATION_REMOVE_DOMAIN_TYPE_FIELDS))
            }
        }
        Ok(DomainVerificationRemoveDomainType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationRemoveDomainType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationRemoveDomainType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationRemoveDomainType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationRemoveDomainType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationRemoveDomainType", DOMAIN_VERIFICATION_REMOVE_DOMAIN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationRemoveDomainType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationRemoveDomainType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared content downloads policy
#[derive(Debug)]
pub enum DownloadPolicyType {
    Allow,
    Disallow,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DownloadPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DownloadPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DownloadPolicyType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "allow" => Ok(DownloadPolicyType::Allow),
                    "disallow" => Ok(DownloadPolicyType::Disallow),
                    _ => Ok(DownloadPolicyType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["allow",
                                    "disallow",
                                    "other"];
        deserializer.deserialize_struct("DownloadPolicyType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DownloadPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DownloadPolicyType::Allow => {
                // unit
                let mut s = serializer.serialize_struct("DownloadPolicyType", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            DownloadPolicyType::Disallow => {
                // unit
                let mut s = serializer.serialize_struct("DownloadPolicyType", 1)?;
                s.serialize_field(".tag", "disallow")?;
                s.end()
            }
            DownloadPolicyType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Represents a time duration: unit and amount
#[derive(Debug)]
pub struct DurationLogInfo {
    /// Time unit.
    pub unit: TimeUnit,
    /// Amount of time.
    pub amount: u64,
}

impl DurationLogInfo {
    pub fn new(unit: TimeUnit, amount: u64) -> Self {
        DurationLogInfo {
            unit,
            amount,
        }
    }

}

const DURATION_LOG_INFO_FIELDS: &[&str] = &["unit",
                                            "amount"];
impl DurationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DurationLogInfo, V::Error> {
        use serde::de;
        let mut field_unit = None;
        let mut field_amount = None;
        while let Some(key) = map.next_key()? {
            match key {
                "unit" => {
                    if field_unit.is_some() {
                        return Err(de::Error::duplicate_field("unit"));
                    }
                    field_unit = Some(map.next_value()?);
                }
                "amount" => {
                    if field_amount.is_some() {
                        return Err(de::Error::duplicate_field("amount"));
                    }
                    field_amount = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DURATION_LOG_INFO_FIELDS))
            }
        }
        Ok(DurationLogInfo {
            unit: field_unit.ok_or_else(|| de::Error::missing_field("unit"))?,
            amount: field_amount.ok_or_else(|| de::Error::missing_field("amount"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("unit", &self.unit)?;
        s.serialize_field("amount", &self.amount)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DurationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DurationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DurationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DurationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DurationLogInfo", DURATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DurationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DurationLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an exception for one or more team members to optionally use the regular Dropbox app when
/// EMM is enabled.
#[derive(Debug)]
pub struct EmmAddExceptionDetails {
}

impl Default for EmmAddExceptionDetails {
    fn default() -> Self {
        EmmAddExceptionDetails {
        }
    }
}

const EMM_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl EmmAddExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmAddExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_ADD_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(EmmAddExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmAddExceptionDetails", EMM_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmAddExceptionType {
    pub description: String,
}

impl EmmAddExceptionType {
    pub fn new(description: String) -> Self {
        EmmAddExceptionType {
            description,
        }
    }

}

const EMM_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl EmmAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmAddExceptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_ADD_EXCEPTION_TYPE_FIELDS))
            }
        }
        Ok(EmmAddExceptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmAddExceptionType", EMM_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled enterprise mobility management for team members.
#[derive(Debug)]
pub struct EmmChangePolicyDetails {
    /// New enterprise mobility management policy.
    pub new_value: super::team_policies::EmmState,
    /// Previous enterprise mobility management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::EmmState>,
}

impl EmmChangePolicyDetails {
    pub fn new(new_value: super::team_policies::EmmState) -> Self {
        EmmChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team_policies::EmmState>) -> Self {
        self.previous_value = value;
        self
    }

}

const EMM_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl EmmChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(EmmChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmChangePolicyDetails", EMM_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EmmChangePolicyType {
    pub description: String,
}

impl EmmChangePolicyType {
    pub fn new(description: String) -> Self {
        EmmChangePolicyType {
            description,
        }
    }

}

const EMM_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl EmmChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(EmmChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmChangePolicyType", EMM_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// EMM excluded users report created.
#[derive(Debug)]
pub struct EmmCreateExceptionsReportDetails {
}

impl Default for EmmCreateExceptionsReportDetails {
    fn default() -> Self {
        EmmCreateExceptionsReportDetails {
        }
    }
}

const EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl EmmCreateExceptionsReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateExceptionsReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS));
        }
        Ok(EmmCreateExceptionsReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateExceptionsReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateExceptionsReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateExceptionsReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateExceptionsReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateExceptionsReportDetails", EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateExceptionsReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateExceptionsReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmCreateExceptionsReportType {
    pub description: String,
}

impl EmmCreateExceptionsReportType {
    pub fn new(description: String) -> Self {
        EmmCreateExceptionsReportType {
            description,
        }
    }

}

const EMM_CREATE_EXCEPTIONS_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl EmmCreateExceptionsReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateExceptionsReportType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_CREATE_EXCEPTIONS_REPORT_TYPE_FIELDS))
            }
        }
        Ok(EmmCreateExceptionsReportType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateExceptionsReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateExceptionsReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateExceptionsReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateExceptionsReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateExceptionsReportType", EMM_CREATE_EXCEPTIONS_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateExceptionsReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmCreateExceptionsReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// EMM mobile app usage report created.
#[derive(Debug)]
pub struct EmmCreateUsageReportDetails {
}

impl Default for EmmCreateUsageReportDetails {
    fn default() -> Self {
        EmmCreateUsageReportDetails {
        }
    }
}

const EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl EmmCreateUsageReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateUsageReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS));
        }
        Ok(EmmCreateUsageReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateUsageReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateUsageReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateUsageReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateUsageReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateUsageReportDetails", EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateUsageReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateUsageReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmCreateUsageReportType {
    pub description: String,
}

impl EmmCreateUsageReportType {
    pub fn new(description: String) -> Self {
        EmmCreateUsageReportType {
            description,
        }
    }

}

const EMM_CREATE_USAGE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl EmmCreateUsageReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateUsageReportType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_CREATE_USAGE_REPORT_TYPE_FIELDS))
            }
        }
        Ok(EmmCreateUsageReportType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateUsageReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateUsageReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmCreateUsageReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateUsageReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateUsageReportType", EMM_CREATE_USAGE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateUsageReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmCreateUsageReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in via EMM.
#[derive(Debug)]
pub struct EmmErrorDetails {
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
}

impl EmmErrorDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        EmmErrorDetails {
            error_details,
        }
    }

}

const EMM_ERROR_DETAILS_FIELDS: &[&str] = &["error_details"];
impl EmmErrorDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmErrorDetails, V::Error> {
        use serde::de;
        let mut field_error_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_ERROR_DETAILS_FIELDS))
            }
        }
        Ok(EmmErrorDetails {
            error_details: field_error_details.ok_or_else(|| de::Error::missing_field("error_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmErrorDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmErrorDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmErrorDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmErrorDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmErrorDetails", EMM_ERROR_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmErrorDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmErrorDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EmmErrorType {
    pub description: String,
}

impl EmmErrorType {
    pub fn new(description: String) -> Self {
        EmmErrorType {
            description,
        }
    }

}

const EMM_ERROR_TYPE_FIELDS: &[&str] = &["description"];
impl EmmErrorType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmErrorType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_ERROR_TYPE_FIELDS))
            }
        }
        Ok(EmmErrorType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmErrorType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmErrorType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmErrorType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmErrorType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmErrorType", EMM_ERROR_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmErrorType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmErrorType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Refreshed the auth token used for setting up enterprise mobility management.
#[derive(Debug)]
pub struct EmmRefreshAuthTokenDetails {
}

impl Default for EmmRefreshAuthTokenDetails {
    fn default() -> Self {
        EmmRefreshAuthTokenDetails {
        }
    }
}

const EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS: &[&str] = &[];
impl EmmRefreshAuthTokenDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRefreshAuthTokenDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS));
        }
        Ok(EmmRefreshAuthTokenDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRefreshAuthTokenDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRefreshAuthTokenDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRefreshAuthTokenDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRefreshAuthTokenDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRefreshAuthTokenDetails", EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRefreshAuthTokenDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRefreshAuthTokenDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmRefreshAuthTokenType {
    pub description: String,
}

impl EmmRefreshAuthTokenType {
    pub fn new(description: String) -> Self {
        EmmRefreshAuthTokenType {
            description,
        }
    }

}

const EMM_REFRESH_AUTH_TOKEN_TYPE_FIELDS: &[&str] = &["description"];
impl EmmRefreshAuthTokenType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRefreshAuthTokenType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_REFRESH_AUTH_TOKEN_TYPE_FIELDS))
            }
        }
        Ok(EmmRefreshAuthTokenType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRefreshAuthTokenType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRefreshAuthTokenType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRefreshAuthTokenType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRefreshAuthTokenType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRefreshAuthTokenType", EMM_REFRESH_AUTH_TOKEN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRefreshAuthTokenType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmRefreshAuthTokenType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed an exception for one or more team members to optionally use the regular Dropbox app when
/// EMM is enabled.
#[derive(Debug)]
pub struct EmmRemoveExceptionDetails {
}

impl Default for EmmRemoveExceptionDetails {
    fn default() -> Self {
        EmmRemoveExceptionDetails {
        }
    }
}

const EMM_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl EmmRemoveExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRemoveExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EMM_REMOVE_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(EmmRemoveExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRemoveExceptionDetails", EMM_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmRemoveExceptionType {
    pub description: String,
}

impl EmmRemoveExceptionType {
    pub fn new(description: String) -> Self {
        EmmRemoveExceptionType {
            description,
        }
    }

}

const EMM_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl EmmRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRemoveExceptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EMM_REMOVE_EXCEPTION_TYPE_FIELDS))
            }
        }
        Ok(EmmRemoveExceptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EmmRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRemoveExceptionType", EMM_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled domain invites.
#[derive(Debug)]
pub struct EnabledDomainInvitesDetails {
}

impl Default for EnabledDomainInvitesDetails {
    fn default() -> Self {
        EnabledDomainInvitesDetails {
        }
    }
}

const ENABLED_DOMAIN_INVITES_DETAILS_FIELDS: &[&str] = &[];
impl EnabledDomainInvitesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EnabledDomainInvitesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, ENABLED_DOMAIN_INVITES_DETAILS_FIELDS));
        }
        Ok(EnabledDomainInvitesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EnabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnabledDomainInvitesDetails", ENABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EnabledDomainInvitesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EnabledDomainInvitesType {
    pub description: String,
}

impl EnabledDomainInvitesType {
    pub fn new(description: String) -> Self {
        EnabledDomainInvitesType {
            description,
        }
    }

}

const ENABLED_DOMAIN_INVITES_TYPE_FIELDS: &[&str] = &["description"];
impl EnabledDomainInvitesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EnabledDomainInvitesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ENABLED_DOMAIN_INVITES_TYPE_FIELDS))
            }
        }
        Ok(EnabledDomainInvitesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnabledDomainInvitesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnabledDomainInvitesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EnabledDomainInvitesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnabledDomainInvitesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnabledDomainInvitesType", ENABLED_DOMAIN_INVITES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnabledDomainInvitesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EnabledDomainInvitesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Category of events in event audit log.
#[derive(Debug)]
pub enum EventCategory {
    /// Events that apply to management of linked apps.
    Apps,
    /// Events that have to do with comments on files and Paper documents.
    Comments,
    /// Events that apply to linked devices on mobile, desktop and Web platforms.
    Devices,
    /// Events that involve domain management feature: domain verification, invite enforcement and
    /// account capture.
    Domains,
    /// Events that have to do with filesystem operations on files and folders: copy, move, delete,
    /// etc.
    FileOperations,
    /// Events that apply to the file requests feature.
    FileRequests,
    /// Events that involve group management.
    Groups,
    /// Events that involve users signing in to or out of Dropbox.
    Logins,
    /// Events that involve team member management.
    Members,
    /// Events that apply to Dropbox Paper.
    Paper,
    /// Events that involve using, changing or resetting passwords.
    Passwords,
    /// Events that concern generation of admin reports, including team activity and device usage.
    Reports,
    /// Events that apply to all types of sharing and collaboration.
    Sharing,
    /// Events that involve using or configuring single sign-on as well as administrative policies
    /// concerning single sign-on.
    Sso,
    /// Events that involve team folder management.
    TeamFolders,
    /// Events that involve a change in team-wide policies.
    TeamPolicies,
    /// Events that involve a change in the team profile.
    TeamProfile,
    /// Events that involve using or configuring two factor authentication as well as administrative
    /// policies concerning two factor authentication.
    Tfa,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventCategory {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventCategory;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventCategory structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "apps" => Ok(EventCategory::Apps),
                    "comments" => Ok(EventCategory::Comments),
                    "devices" => Ok(EventCategory::Devices),
                    "domains" => Ok(EventCategory::Domains),
                    "file_operations" => Ok(EventCategory::FileOperations),
                    "file_requests" => Ok(EventCategory::FileRequests),
                    "groups" => Ok(EventCategory::Groups),
                    "logins" => Ok(EventCategory::Logins),
                    "members" => Ok(EventCategory::Members),
                    "paper" => Ok(EventCategory::Paper),
                    "passwords" => Ok(EventCategory::Passwords),
                    "reports" => Ok(EventCategory::Reports),
                    "sharing" => Ok(EventCategory::Sharing),
                    "sso" => Ok(EventCategory::Sso),
                    "team_folders" => Ok(EventCategory::TeamFolders),
                    "team_policies" => Ok(EventCategory::TeamPolicies),
                    "team_profile" => Ok(EventCategory::TeamProfile),
                    "tfa" => Ok(EventCategory::Tfa),
                    _ => Ok(EventCategory::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["apps",
                                    "comments",
                                    "devices",
                                    "domains",
                                    "file_operations",
                                    "file_requests",
                                    "groups",
                                    "logins",
                                    "members",
                                    "paper",
                                    "passwords",
                                    "reports",
                                    "sharing",
                                    "sso",
                                    "team_folders",
                                    "team_policies",
                                    "team_profile",
                                    "tfa",
                                    "other"];
        deserializer.deserialize_struct("EventCategory", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventCategory {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventCategory::Apps => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "apps")?;
                s.end()
            }
            EventCategory::Comments => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "comments")?;
                s.end()
            }
            EventCategory::Devices => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "devices")?;
                s.end()
            }
            EventCategory::Domains => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "domains")?;
                s.end()
            }
            EventCategory::FileOperations => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_operations")?;
                s.end()
            }
            EventCategory::FileRequests => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_requests")?;
                s.end()
            }
            EventCategory::Groups => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "groups")?;
                s.end()
            }
            EventCategory::Logins => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "logins")?;
                s.end()
            }
            EventCategory::Members => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            EventCategory::Paper => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "paper")?;
                s.end()
            }
            EventCategory::Passwords => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "passwords")?;
                s.end()
            }
            EventCategory::Reports => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "reports")?;
                s.end()
            }
            EventCategory::Sharing => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sharing")?;
                s.end()
            }
            EventCategory::Sso => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sso")?;
                s.end()
            }
            EventCategory::TeamFolders => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_folders")?;
                s.end()
            }
            EventCategory::TeamPolicies => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_policies")?;
                s.end()
            }
            EventCategory::TeamProfile => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_profile")?;
                s.end()
            }
            EventCategory::Tfa => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "tfa")?;
                s.end()
            }
            EventCategory::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional fields depending on the event type.
#[derive(Debug)]
pub enum EventDetails {
    AppLinkTeamDetails(AppLinkTeamDetails),
    AppLinkUserDetails(AppLinkUserDetails),
    AppUnlinkTeamDetails(AppUnlinkTeamDetails),
    AppUnlinkUserDetails(AppUnlinkUserDetails),
    FileAddCommentDetails(FileAddCommentDetails),
    FileChangeCommentSubscriptionDetails(FileChangeCommentSubscriptionDetails),
    FileDeleteCommentDetails(FileDeleteCommentDetails),
    FileLikeCommentDetails(FileLikeCommentDetails),
    FileResolveCommentDetails(FileResolveCommentDetails),
    FileUnlikeCommentDetails(FileUnlikeCommentDetails),
    FileUnresolveCommentDetails(FileUnresolveCommentDetails),
    DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails),
    DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails),
    DeviceChangeIpWebDetails(DeviceChangeIpWebDetails),
    DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails),
    DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails),
    DeviceLinkFailDetails(DeviceLinkFailDetails),
    DeviceLinkSuccessDetails(DeviceLinkSuccessDetails),
    DeviceManagementDisabledDetails(DeviceManagementDisabledDetails),
    DeviceManagementEnabledDetails(DeviceManagementEnabledDetails),
    DeviceUnlinkDetails(DeviceUnlinkDetails),
    EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails),
    AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails),
    AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails),
    AccountCaptureNotificationEmailsSentDetails(AccountCaptureNotificationEmailsSentDetails),
    AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails),
    DisabledDomainInvitesDetails(DisabledDomainInvitesDetails),
    DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails),
    DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails),
    DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails),
    DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails),
    DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails),
    DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails),
    DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails),
    DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails),
    DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails),
    EnabledDomainInvitesDetails(EnabledDomainInvitesDetails),
    CreateFolderDetails(CreateFolderDetails),
    FileAddDetails(FileAddDetails),
    FileCopyDetails(FileCopyDetails),
    FileDeleteDetails(FileDeleteDetails),
    FileDownloadDetails(FileDownloadDetails),
    FileEditDetails(FileEditDetails),
    FileGetCopyReferenceDetails(FileGetCopyReferenceDetails),
    FileMoveDetails(FileMoveDetails),
    FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails),
    FilePreviewDetails(FilePreviewDetails),
    FileRenameDetails(FileRenameDetails),
    FileRestoreDetails(FileRestoreDetails),
    FileRevertDetails(FileRevertDetails),
    FileRollbackChangesDetails(FileRollbackChangesDetails),
    FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails),
    FileRequestChangeDetails(FileRequestChangeDetails),
    FileRequestCloseDetails(FileRequestCloseDetails),
    FileRequestCreateDetails(FileRequestCreateDetails),
    FileRequestReceiveFileDetails(FileRequestReceiveFileDetails),
    GroupAddExternalIdDetails(GroupAddExternalIdDetails),
    GroupAddMemberDetails(GroupAddMemberDetails),
    GroupChangeExternalIdDetails(GroupChangeExternalIdDetails),
    GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails),
    GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails),
    GroupCreateDetails(GroupCreateDetails),
    GroupDeleteDetails(GroupDeleteDetails),
    GroupMovedDetails(GroupMovedDetails),
    GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails),
    GroupRemoveMemberDetails(GroupRemoveMemberDetails),
    GroupRenameDetails(GroupRenameDetails),
    EmmErrorDetails(EmmErrorDetails),
    LoginFailDetails(LoginFailDetails),
    LoginSuccessDetails(LoginSuccessDetails),
    LogoutDetails(LogoutDetails),
    ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails),
    ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails),
    SignInAsSessionEndDetails(SignInAsSessionEndDetails),
    SignInAsSessionStartDetails(SignInAsSessionStartDetails),
    SsoErrorDetails(SsoErrorDetails),
    MemberAddNameDetails(MemberAddNameDetails),
    MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails),
    MemberChangeEmailDetails(MemberChangeEmailDetails),
    MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails),
    MemberChangeNameDetails(MemberChangeNameDetails),
    MemberChangeStatusDetails(MemberChangeStatusDetails),
    MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails),
    MemberSpaceLimitsAddCustomQuotaDetails(MemberSpaceLimitsAddCustomQuotaDetails),
    MemberSpaceLimitsChangeCustomQuotaDetails(MemberSpaceLimitsChangeCustomQuotaDetails),
    MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails),
    MemberSpaceLimitsRemoveCustomQuotaDetails(MemberSpaceLimitsRemoveCustomQuotaDetails),
    MemberSuggestDetails(MemberSuggestDetails),
    MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails),
    PaperContentAddMemberDetails(PaperContentAddMemberDetails),
    PaperContentAddToFolderDetails(PaperContentAddToFolderDetails),
    PaperContentArchiveDetails(PaperContentArchiveDetails),
    PaperContentCreateDetails(PaperContentCreateDetails),
    PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails),
    PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails),
    PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails),
    PaperContentRenameDetails(PaperContentRenameDetails),
    PaperContentRestoreDetails(PaperContentRestoreDetails),
    PaperDocAddCommentDetails(PaperDocAddCommentDetails),
    PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails),
    PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails),
    PaperDocChangeSubscriptionDetails(PaperDocChangeSubscriptionDetails),
    PaperDocDeletedDetails(PaperDocDeletedDetails),
    PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails),
    PaperDocDownloadDetails(PaperDocDownloadDetails),
    PaperDocEditDetails(PaperDocEditDetails),
    PaperDocEditCommentDetails(PaperDocEditCommentDetails),
    PaperDocFollowedDetails(PaperDocFollowedDetails),
    PaperDocMentionDetails(PaperDocMentionDetails),
    PaperDocRequestAccessDetails(PaperDocRequestAccessDetails),
    PaperDocResolveCommentDetails(PaperDocResolveCommentDetails),
    PaperDocRevertDetails(PaperDocRevertDetails),
    PaperDocSlackShareDetails(PaperDocSlackShareDetails),
    PaperDocTeamInviteDetails(PaperDocTeamInviteDetails),
    PaperDocTrashedDetails(PaperDocTrashedDetails),
    PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails),
    PaperDocUntrashedDetails(PaperDocUntrashedDetails),
    PaperDocViewDetails(PaperDocViewDetails),
    PaperExternalViewAllowDetails(PaperExternalViewAllowDetails),
    PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails),
    PaperExternalViewForbidDetails(PaperExternalViewForbidDetails),
    PaperFolderChangeSubscriptionDetails(PaperFolderChangeSubscriptionDetails),
    PaperFolderDeletedDetails(PaperFolderDeletedDetails),
    PaperFolderFollowedDetails(PaperFolderFollowedDetails),
    PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails),
    PasswordChangeDetails(PasswordChangeDetails),
    PasswordResetDetails(PasswordResetDetails),
    PasswordResetAllDetails(PasswordResetAllDetails),
    EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails),
    EmmCreateUsageReportDetails(EmmCreateUsageReportDetails),
    ExportMembersReportDetails(ExportMembersReportDetails),
    PaperAdminExportStartDetails(PaperAdminExportStartDetails),
    SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails),
    TeamActivityCreateReportDetails(TeamActivityCreateReportDetails),
    CollectionShareDetails(CollectionShareDetails),
    NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails),
    NoteAclLinkDetails(NoteAclLinkDetails),
    NoteAclTeamLinkDetails(NoteAclTeamLinkDetails),
    NoteSharedDetails(NoteSharedDetails),
    NoteShareReceiveDetails(NoteShareReceiveDetails),
    OpenNoteSharedDetails(OpenNoteSharedDetails),
    SfAddGroupDetails(SfAddGroupDetails),
    SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails),
    SfExternalInviteWarnDetails(SfExternalInviteWarnDetails),
    SfFbInviteDetails(SfFbInviteDetails),
    SfFbInviteChangeRoleDetails(SfFbInviteChangeRoleDetails),
    SfFbUninviteDetails(SfFbUninviteDetails),
    SfInviteGroupDetails(SfInviteGroupDetails),
    SfTeamGrantAccessDetails(SfTeamGrantAccessDetails),
    SfTeamInviteDetails(SfTeamInviteDetails),
    SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails),
    SfTeamJoinDetails(SfTeamJoinDetails),
    SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails),
    SfTeamUninviteDetails(SfTeamUninviteDetails),
    SharedContentAddInviteesDetails(SharedContentAddInviteesDetails),
    SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails),
    SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails),
    SharedContentAddMemberDetails(SharedContentAddMemberDetails),
    SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails),
    SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails),
    SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails),
    SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails),
    SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails),
    SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails),
    SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails),
    SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails),
    SharedContentCopyDetails(SharedContentCopyDetails),
    SharedContentDownloadDetails(SharedContentDownloadDetails),
    SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails),
    SharedContentRemoveInviteesDetails(SharedContentRemoveInviteesDetails),
    SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails),
    SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails),
    SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails),
    SharedContentRequestAccessDetails(SharedContentRequestAccessDetails),
    SharedContentUnshareDetails(SharedContentUnshareDetails),
    SharedContentViewDetails(SharedContentViewDetails),
    SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails),
    SharedFolderChangeMembersInheritancePolicyDetails(SharedFolderChangeMembersInheritancePolicyDetails),
    SharedFolderChangeMembersManagementPolicyDetails(SharedFolderChangeMembersManagementPolicyDetails),
    SharedFolderChangeMembersPolicyDetails(SharedFolderChangeMembersPolicyDetails),
    SharedFolderCreateDetails(SharedFolderCreateDetails),
    SharedFolderDeclineInvitationDetails(SharedFolderDeclineInvitationDetails),
    SharedFolderMountDetails(SharedFolderMountDetails),
    SharedFolderNestDetails(SharedFolderNestDetails),
    SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails),
    SharedFolderUnmountDetails(SharedFolderUnmountDetails),
    SharedLinkAddExpiryDetails(SharedLinkAddExpiryDetails),
    SharedLinkChangeExpiryDetails(SharedLinkChangeExpiryDetails),
    SharedLinkChangeVisibilityDetails(SharedLinkChangeVisibilityDetails),
    SharedLinkCopyDetails(SharedLinkCopyDetails),
    SharedLinkCreateDetails(SharedLinkCreateDetails),
    SharedLinkDisableDetails(SharedLinkDisableDetails),
    SharedLinkDownloadDetails(SharedLinkDownloadDetails),
    SharedLinkRemoveExpiryDetails(SharedLinkRemoveExpiryDetails),
    SharedLinkShareDetails(SharedLinkShareDetails),
    SharedLinkViewDetails(SharedLinkViewDetails),
    SharedNoteOpenedDetails(SharedNoteOpenedDetails),
    ShmodelGroupShareDetails(ShmodelGroupShareDetails),
    SsoAddCertDetails(SsoAddCertDetails),
    SsoAddLoginUrlDetails(SsoAddLoginUrlDetails),
    SsoAddLogoutUrlDetails(SsoAddLogoutUrlDetails),
    SsoChangeCertDetails(SsoChangeCertDetails),
    SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails),
    SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails),
    SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails),
    SsoRemoveCertDetails(SsoRemoveCertDetails),
    SsoRemoveLoginUrlDetails(SsoRemoveLoginUrlDetails),
    SsoRemoveLogoutUrlDetails(SsoRemoveLogoutUrlDetails),
    TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails),
    TeamFolderCreateDetails(TeamFolderCreateDetails),
    TeamFolderDowngradeDetails(TeamFolderDowngradeDetails),
    TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails),
    TeamFolderRenameDetails(TeamFolderRenameDetails),
    AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails),
    AllowDownloadDisabledDetails(AllowDownloadDisabledDetails),
    AllowDownloadEnabledDetails(AllowDownloadEnabledDetails),
    DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails),
    DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails),
    DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails),
    DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails),
    DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails),
    DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails),
    EmmAddExceptionDetails(EmmAddExceptionDetails),
    EmmChangePolicyDetails(EmmChangePolicyDetails),
    EmmRemoveExceptionDetails(EmmRemoveExceptionDetails),
    ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails),
    FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails),
    FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails),
    FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails),
    FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails),
    GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails),
    GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails),
    MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails),
    MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails),
    MemberSpaceLimitsChangeCapsTypePolicyDetails(MemberSpaceLimitsChangeCapsTypePolicyDetails),
    MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails),
    MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails),
    MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails),
    MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails),
    NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails),
    PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails),
    PaperChangeMemberLinkPolicyDetails(PaperChangeMemberLinkPolicyDetails),
    PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails),
    PaperChangePolicyDetails(PaperChangePolicyDetails),
    PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails),
    PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails),
    PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails),
    SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails),
    SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails),
    SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails),
    SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails),
    SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails),
    SmartSyncOptOutDetails(SmartSyncOptOutDetails),
    SsoChangePolicyDetails(SsoChangePolicyDetails),
    TfaChangePolicyDetails(TfaChangePolicyDetails),
    TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails),
    WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails),
    WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails),
    TeamMergeFromDetails(TeamMergeFromDetails),
    TeamMergeToDetails(TeamMergeToDetails),
    TeamProfileAddLogoDetails(TeamProfileAddLogoDetails),
    TeamProfileChangeDefaultLanguageDetails(TeamProfileChangeDefaultLanguageDetails),
    TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails),
    TeamProfileChangeNameDetails(TeamProfileChangeNameDetails),
    TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails),
    TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails),
    TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails),
    TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails),
    TfaChangeStatusDetails(TfaChangeStatusDetails),
    TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails),
    TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails),
    TfaResetDetails(TfaResetDetails),
    /// Hints that this event was returned with missing details due to an internal error.
    MissingDetails(MissingDetails),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_link_team_details" => Ok(EventDetails::AppLinkTeamDetails(AppLinkTeamDetails::internal_deserialize(map)?)),
                    "app_link_user_details" => Ok(EventDetails::AppLinkUserDetails(AppLinkUserDetails::internal_deserialize(map)?)),
                    "app_unlink_team_details" => Ok(EventDetails::AppUnlinkTeamDetails(AppUnlinkTeamDetails::internal_deserialize(map)?)),
                    "app_unlink_user_details" => Ok(EventDetails::AppUnlinkUserDetails(AppUnlinkUserDetails::internal_deserialize(map)?)),
                    "file_add_comment_details" => Ok(EventDetails::FileAddCommentDetails(FileAddCommentDetails::internal_deserialize(map)?)),
                    "file_change_comment_subscription_details" => Ok(EventDetails::FileChangeCommentSubscriptionDetails(FileChangeCommentSubscriptionDetails::internal_deserialize(map)?)),
                    "file_delete_comment_details" => Ok(EventDetails::FileDeleteCommentDetails(FileDeleteCommentDetails::internal_deserialize(map)?)),
                    "file_like_comment_details" => Ok(EventDetails::FileLikeCommentDetails(FileLikeCommentDetails::internal_deserialize(map)?)),
                    "file_resolve_comment_details" => Ok(EventDetails::FileResolveCommentDetails(FileResolveCommentDetails::internal_deserialize(map)?)),
                    "file_unlike_comment_details" => Ok(EventDetails::FileUnlikeCommentDetails(FileUnlikeCommentDetails::internal_deserialize(map)?)),
                    "file_unresolve_comment_details" => Ok(EventDetails::FileUnresolveCommentDetails(FileUnresolveCommentDetails::internal_deserialize(map)?)),
                    "device_change_ip_desktop_details" => Ok(EventDetails::DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails::internal_deserialize(map)?)),
                    "device_change_ip_mobile_details" => Ok(EventDetails::DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails::internal_deserialize(map)?)),
                    "device_change_ip_web_details" => Ok(EventDetails::DeviceChangeIpWebDetails(DeviceChangeIpWebDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_fail_details" => Ok(EventDetails::DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_success_details" => Ok(EventDetails::DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)?)),
                    "device_link_fail_details" => Ok(EventDetails::DeviceLinkFailDetails(DeviceLinkFailDetails::internal_deserialize(map)?)),
                    "device_link_success_details" => Ok(EventDetails::DeviceLinkSuccessDetails(DeviceLinkSuccessDetails::internal_deserialize(map)?)),
                    "device_management_disabled_details" => Ok(EventDetails::DeviceManagementDisabledDetails(DeviceManagementDisabledDetails::internal_deserialize(map)?)),
                    "device_management_enabled_details" => Ok(EventDetails::DeviceManagementEnabledDetails(DeviceManagementEnabledDetails::internal_deserialize(map)?)),
                    "device_unlink_details" => Ok(EventDetails::DeviceUnlinkDetails(DeviceUnlinkDetails::internal_deserialize(map)?)),
                    "emm_refresh_auth_token_details" => Ok(EventDetails::EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails::internal_deserialize(map)?)),
                    "account_capture_change_availability_details" => Ok(EventDetails::AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)?)),
                    "account_capture_migrate_account_details" => Ok(EventDetails::AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails::internal_deserialize(map)?)),
                    "account_capture_notification_emails_sent_details" => Ok(EventDetails::AccountCaptureNotificationEmailsSentDetails(AccountCaptureNotificationEmailsSentDetails::internal_deserialize(map)?)),
                    "account_capture_relinquish_account_details" => Ok(EventDetails::AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails::internal_deserialize(map)?)),
                    "disabled_domain_invites_details" => Ok(EventDetails::DisabledDomainInvitesDetails(DisabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "domain_invites_approve_request_to_join_team_details" => Ok(EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_decline_request_to_join_team_details" => Ok(EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_email_existing_users_details" => Ok(EventDetails::DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)?)),
                    "domain_invites_request_to_join_team_details" => Ok(EventDetails::DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_no_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_yes_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_fail_details" => Ok(EventDetails::DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_success_details" => Ok(EventDetails::DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)?)),
                    "domain_verification_remove_domain_details" => Ok(EventDetails::DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails::internal_deserialize(map)?)),
                    "enabled_domain_invites_details" => Ok(EventDetails::EnabledDomainInvitesDetails(EnabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "create_folder_details" => Ok(EventDetails::CreateFolderDetails(CreateFolderDetails::internal_deserialize(map)?)),
                    "file_add_details" => Ok(EventDetails::FileAddDetails(FileAddDetails::internal_deserialize(map)?)),
                    "file_copy_details" => Ok(EventDetails::FileCopyDetails(FileCopyDetails::internal_deserialize(map)?)),
                    "file_delete_details" => Ok(EventDetails::FileDeleteDetails(FileDeleteDetails::internal_deserialize(map)?)),
                    "file_download_details" => Ok(EventDetails::FileDownloadDetails(FileDownloadDetails::internal_deserialize(map)?)),
                    "file_edit_details" => Ok(EventDetails::FileEditDetails(FileEditDetails::internal_deserialize(map)?)),
                    "file_get_copy_reference_details" => Ok(EventDetails::FileGetCopyReferenceDetails(FileGetCopyReferenceDetails::internal_deserialize(map)?)),
                    "file_move_details" => Ok(EventDetails::FileMoveDetails(FileMoveDetails::internal_deserialize(map)?)),
                    "file_permanently_delete_details" => Ok(EventDetails::FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "file_preview_details" => Ok(EventDetails::FilePreviewDetails(FilePreviewDetails::internal_deserialize(map)?)),
                    "file_rename_details" => Ok(EventDetails::FileRenameDetails(FileRenameDetails::internal_deserialize(map)?)),
                    "file_restore_details" => Ok(EventDetails::FileRestoreDetails(FileRestoreDetails::internal_deserialize(map)?)),
                    "file_revert_details" => Ok(EventDetails::FileRevertDetails(FileRevertDetails::internal_deserialize(map)?)),
                    "file_rollback_changes_details" => Ok(EventDetails::FileRollbackChangesDetails(FileRollbackChangesDetails::internal_deserialize(map)?)),
                    "file_save_copy_reference_details" => Ok(EventDetails::FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails::internal_deserialize(map)?)),
                    "file_request_change_details" => Ok(EventDetails::FileRequestChangeDetails(FileRequestChangeDetails::internal_deserialize(map)?)),
                    "file_request_close_details" => Ok(EventDetails::FileRequestCloseDetails(FileRequestCloseDetails::internal_deserialize(map)?)),
                    "file_request_create_details" => Ok(EventDetails::FileRequestCreateDetails(FileRequestCreateDetails::internal_deserialize(map)?)),
                    "file_request_receive_file_details" => Ok(EventDetails::FileRequestReceiveFileDetails(FileRequestReceiveFileDetails::internal_deserialize(map)?)),
                    "group_add_external_id_details" => Ok(EventDetails::GroupAddExternalIdDetails(GroupAddExternalIdDetails::internal_deserialize(map)?)),
                    "group_add_member_details" => Ok(EventDetails::GroupAddMemberDetails(GroupAddMemberDetails::internal_deserialize(map)?)),
                    "group_change_external_id_details" => Ok(EventDetails::GroupChangeExternalIdDetails(GroupChangeExternalIdDetails::internal_deserialize(map)?)),
                    "group_change_management_type_details" => Ok(EventDetails::GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails::internal_deserialize(map)?)),
                    "group_change_member_role_details" => Ok(EventDetails::GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "group_create_details" => Ok(EventDetails::GroupCreateDetails(GroupCreateDetails::internal_deserialize(map)?)),
                    "group_delete_details" => Ok(EventDetails::GroupDeleteDetails(GroupDeleteDetails::internal_deserialize(map)?)),
                    "group_moved_details" => Ok(EventDetails::GroupMovedDetails(GroupMovedDetails::internal_deserialize(map)?)),
                    "group_remove_external_id_details" => Ok(EventDetails::GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails::internal_deserialize(map)?)),
                    "group_remove_member_details" => Ok(EventDetails::GroupRemoveMemberDetails(GroupRemoveMemberDetails::internal_deserialize(map)?)),
                    "group_rename_details" => Ok(EventDetails::GroupRenameDetails(GroupRenameDetails::internal_deserialize(map)?)),
                    "emm_error_details" => Ok(EventDetails::EmmErrorDetails(EmmErrorDetails::internal_deserialize(map)?)),
                    "login_fail_details" => Ok(EventDetails::LoginFailDetails(LoginFailDetails::internal_deserialize(map)?)),
                    "login_success_details" => Ok(EventDetails::LoginSuccessDetails(LoginSuccessDetails::internal_deserialize(map)?)),
                    "logout_details" => Ok(EventDetails::LogoutDetails(LogoutDetails::internal_deserialize(map)?)),
                    "reseller_support_session_end_details" => Ok(EventDetails::ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails::internal_deserialize(map)?)),
                    "reseller_support_session_start_details" => Ok(EventDetails::ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_end_details" => Ok(EventDetails::SignInAsSessionEndDetails(SignInAsSessionEndDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_start_details" => Ok(EventDetails::SignInAsSessionStartDetails(SignInAsSessionStartDetails::internal_deserialize(map)?)),
                    "sso_error_details" => Ok(EventDetails::SsoErrorDetails(SsoErrorDetails::internal_deserialize(map)?)),
                    "member_add_name_details" => Ok(EventDetails::MemberAddNameDetails(MemberAddNameDetails::internal_deserialize(map)?)),
                    "member_change_admin_role_details" => Ok(EventDetails::MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails::internal_deserialize(map)?)),
                    "member_change_email_details" => Ok(EventDetails::MemberChangeEmailDetails(MemberChangeEmailDetails::internal_deserialize(map)?)),
                    "member_change_membership_type_details" => Ok(EventDetails::MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails::internal_deserialize(map)?)),
                    "member_change_name_details" => Ok(EventDetails::MemberChangeNameDetails(MemberChangeNameDetails::internal_deserialize(map)?)),
                    "member_change_status_details" => Ok(EventDetails::MemberChangeStatusDetails(MemberChangeStatusDetails::internal_deserialize(map)?)),
                    "member_permanently_delete_account_contents_details" => Ok(EventDetails::MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)?)),
                    "member_space_limits_add_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsAddCustomQuotaDetails(MemberSpaceLimitsAddCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsChangeCustomQuotaDetails(MemberSpaceLimitsChangeCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_status_details" => Ok(EventDetails::MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)?)),
                    "member_space_limits_remove_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsRemoveCustomQuotaDetails(MemberSpaceLimitsRemoveCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_suggest_details" => Ok(EventDetails::MemberSuggestDetails(MemberSuggestDetails::internal_deserialize(map)?)),
                    "member_transfer_account_contents_details" => Ok(EventDetails::MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails::internal_deserialize(map)?)),
                    "paper_content_add_member_details" => Ok(EventDetails::PaperContentAddMemberDetails(PaperContentAddMemberDetails::internal_deserialize(map)?)),
                    "paper_content_add_to_folder_details" => Ok(EventDetails::PaperContentAddToFolderDetails(PaperContentAddToFolderDetails::internal_deserialize(map)?)),
                    "paper_content_archive_details" => Ok(EventDetails::PaperContentArchiveDetails(PaperContentArchiveDetails::internal_deserialize(map)?)),
                    "paper_content_create_details" => Ok(EventDetails::PaperContentCreateDetails(PaperContentCreateDetails::internal_deserialize(map)?)),
                    "paper_content_permanently_delete_details" => Ok(EventDetails::PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "paper_content_remove_from_folder_details" => Ok(EventDetails::PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails::internal_deserialize(map)?)),
                    "paper_content_remove_member_details" => Ok(EventDetails::PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "paper_content_rename_details" => Ok(EventDetails::PaperContentRenameDetails(PaperContentRenameDetails::internal_deserialize(map)?)),
                    "paper_content_restore_details" => Ok(EventDetails::PaperContentRestoreDetails(PaperContentRestoreDetails::internal_deserialize(map)?)),
                    "paper_doc_add_comment_details" => Ok(EventDetails::PaperDocAddCommentDetails(PaperDocAddCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_change_member_role_details" => Ok(EventDetails::PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "paper_doc_change_sharing_policy_details" => Ok(EventDetails::PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails::internal_deserialize(map)?)),
                    "paper_doc_change_subscription_details" => Ok(EventDetails::PaperDocChangeSubscriptionDetails(PaperDocChangeSubscriptionDetails::internal_deserialize(map)?)),
                    "paper_doc_deleted_details" => Ok(EventDetails::PaperDocDeletedDetails(PaperDocDeletedDetails::internal_deserialize(map)?)),
                    "paper_doc_delete_comment_details" => Ok(EventDetails::PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_download_details" => Ok(EventDetails::PaperDocDownloadDetails(PaperDocDownloadDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_details" => Ok(EventDetails::PaperDocEditDetails(PaperDocEditDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_comment_details" => Ok(EventDetails::PaperDocEditCommentDetails(PaperDocEditCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_followed_details" => Ok(EventDetails::PaperDocFollowedDetails(PaperDocFollowedDetails::internal_deserialize(map)?)),
                    "paper_doc_mention_details" => Ok(EventDetails::PaperDocMentionDetails(PaperDocMentionDetails::internal_deserialize(map)?)),
                    "paper_doc_request_access_details" => Ok(EventDetails::PaperDocRequestAccessDetails(PaperDocRequestAccessDetails::internal_deserialize(map)?)),
                    "paper_doc_resolve_comment_details" => Ok(EventDetails::PaperDocResolveCommentDetails(PaperDocResolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_revert_details" => Ok(EventDetails::PaperDocRevertDetails(PaperDocRevertDetails::internal_deserialize(map)?)),
                    "paper_doc_slack_share_details" => Ok(EventDetails::PaperDocSlackShareDetails(PaperDocSlackShareDetails::internal_deserialize(map)?)),
                    "paper_doc_team_invite_details" => Ok(EventDetails::PaperDocTeamInviteDetails(PaperDocTeamInviteDetails::internal_deserialize(map)?)),
                    "paper_doc_trashed_details" => Ok(EventDetails::PaperDocTrashedDetails(PaperDocTrashedDetails::internal_deserialize(map)?)),
                    "paper_doc_unresolve_comment_details" => Ok(EventDetails::PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_untrashed_details" => Ok(EventDetails::PaperDocUntrashedDetails(PaperDocUntrashedDetails::internal_deserialize(map)?)),
                    "paper_doc_view_details" => Ok(EventDetails::PaperDocViewDetails(PaperDocViewDetails::internal_deserialize(map)?)),
                    "paper_external_view_allow_details" => Ok(EventDetails::PaperExternalViewAllowDetails(PaperExternalViewAllowDetails::internal_deserialize(map)?)),
                    "paper_external_view_default_team_details" => Ok(EventDetails::PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails::internal_deserialize(map)?)),
                    "paper_external_view_forbid_details" => Ok(EventDetails::PaperExternalViewForbidDetails(PaperExternalViewForbidDetails::internal_deserialize(map)?)),
                    "paper_folder_change_subscription_details" => Ok(EventDetails::PaperFolderChangeSubscriptionDetails(PaperFolderChangeSubscriptionDetails::internal_deserialize(map)?)),
                    "paper_folder_deleted_details" => Ok(EventDetails::PaperFolderDeletedDetails(PaperFolderDeletedDetails::internal_deserialize(map)?)),
                    "paper_folder_followed_details" => Ok(EventDetails::PaperFolderFollowedDetails(PaperFolderFollowedDetails::internal_deserialize(map)?)),
                    "paper_folder_team_invite_details" => Ok(EventDetails::PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails::internal_deserialize(map)?)),
                    "password_change_details" => Ok(EventDetails::PasswordChangeDetails(PasswordChangeDetails::internal_deserialize(map)?)),
                    "password_reset_details" => Ok(EventDetails::PasswordResetDetails(PasswordResetDetails::internal_deserialize(map)?)),
                    "password_reset_all_details" => Ok(EventDetails::PasswordResetAllDetails(PasswordResetAllDetails::internal_deserialize(map)?)),
                    "emm_create_exceptions_report_details" => Ok(EventDetails::EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails::internal_deserialize(map)?)),
                    "emm_create_usage_report_details" => Ok(EventDetails::EmmCreateUsageReportDetails(EmmCreateUsageReportDetails::internal_deserialize(map)?)),
                    "export_members_report_details" => Ok(EventDetails::ExportMembersReportDetails(ExportMembersReportDetails::internal_deserialize(map)?)),
                    "paper_admin_export_start_details" => Ok(EventDetails::PaperAdminExportStartDetails(PaperAdminExportStartDetails::internal_deserialize(map)?)),
                    "smart_sync_create_admin_privilege_report_details" => Ok(EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)?)),
                    "team_activity_create_report_details" => Ok(EventDetails::TeamActivityCreateReportDetails(TeamActivityCreateReportDetails::internal_deserialize(map)?)),
                    "collection_share_details" => Ok(EventDetails::CollectionShareDetails(CollectionShareDetails::internal_deserialize(map)?)),
                    "note_acl_invite_only_details" => Ok(EventDetails::NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails::internal_deserialize(map)?)),
                    "note_acl_link_details" => Ok(EventDetails::NoteAclLinkDetails(NoteAclLinkDetails::internal_deserialize(map)?)),
                    "note_acl_team_link_details" => Ok(EventDetails::NoteAclTeamLinkDetails(NoteAclTeamLinkDetails::internal_deserialize(map)?)),
                    "note_shared_details" => Ok(EventDetails::NoteSharedDetails(NoteSharedDetails::internal_deserialize(map)?)),
                    "note_share_receive_details" => Ok(EventDetails::NoteShareReceiveDetails(NoteShareReceiveDetails::internal_deserialize(map)?)),
                    "open_note_shared_details" => Ok(EventDetails::OpenNoteSharedDetails(OpenNoteSharedDetails::internal_deserialize(map)?)),
                    "sf_add_group_details" => Ok(EventDetails::SfAddGroupDetails(SfAddGroupDetails::internal_deserialize(map)?)),
                    "sf_allow_non_members_to_view_shared_links_details" => Ok(EventDetails::SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)?)),
                    "sf_external_invite_warn_details" => Ok(EventDetails::SfExternalInviteWarnDetails(SfExternalInviteWarnDetails::internal_deserialize(map)?)),
                    "sf_fb_invite_details" => Ok(EventDetails::SfFbInviteDetails(SfFbInviteDetails::internal_deserialize(map)?)),
                    "sf_fb_invite_change_role_details" => Ok(EventDetails::SfFbInviteChangeRoleDetails(SfFbInviteChangeRoleDetails::internal_deserialize(map)?)),
                    "sf_fb_uninvite_details" => Ok(EventDetails::SfFbUninviteDetails(SfFbUninviteDetails::internal_deserialize(map)?)),
                    "sf_invite_group_details" => Ok(EventDetails::SfInviteGroupDetails(SfInviteGroupDetails::internal_deserialize(map)?)),
                    "sf_team_grant_access_details" => Ok(EventDetails::SfTeamGrantAccessDetails(SfTeamGrantAccessDetails::internal_deserialize(map)?)),
                    "sf_team_invite_details" => Ok(EventDetails::SfTeamInviteDetails(SfTeamInviteDetails::internal_deserialize(map)?)),
                    "sf_team_invite_change_role_details" => Ok(EventDetails::SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails::internal_deserialize(map)?)),
                    "sf_team_join_details" => Ok(EventDetails::SfTeamJoinDetails(SfTeamJoinDetails::internal_deserialize(map)?)),
                    "sf_team_join_from_oob_link_details" => Ok(EventDetails::SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails::internal_deserialize(map)?)),
                    "sf_team_uninvite_details" => Ok(EventDetails::SfTeamUninviteDetails(SfTeamUninviteDetails::internal_deserialize(map)?)),
                    "shared_content_add_invitees_details" => Ok(EventDetails::SharedContentAddInviteesDetails(SharedContentAddInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_expiry_details" => Ok(EventDetails::SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_password_details" => Ok(EventDetails::SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_add_member_details" => Ok(EventDetails::SharedContentAddMemberDetails(SharedContentAddMemberDetails::internal_deserialize(map)?)),
                    "shared_content_change_downloads_policy_details" => Ok(EventDetails::SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_change_invitee_role_details" => Ok(EventDetails::SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_audience_details" => Ok(EventDetails::SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_expiry_details" => Ok(EventDetails::SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_password_details" => Ok(EventDetails::SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_change_member_role_details" => Ok(EventDetails::SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_viewer_info_policy_details" => Ok(EventDetails::SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_claim_invitation_details" => Ok(EventDetails::SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails::internal_deserialize(map)?)),
                    "shared_content_copy_details" => Ok(EventDetails::SharedContentCopyDetails(SharedContentCopyDetails::internal_deserialize(map)?)),
                    "shared_content_download_details" => Ok(EventDetails::SharedContentDownloadDetails(SharedContentDownloadDetails::internal_deserialize(map)?)),
                    "shared_content_relinquish_membership_details" => Ok(EventDetails::SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails::internal_deserialize(map)?)),
                    "shared_content_remove_invitees_details" => Ok(EventDetails::SharedContentRemoveInviteesDetails(SharedContentRemoveInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_expiry_details" => Ok(EventDetails::SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_password_details" => Ok(EventDetails::SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_remove_member_details" => Ok(EventDetails::SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "shared_content_request_access_details" => Ok(EventDetails::SharedContentRequestAccessDetails(SharedContentRequestAccessDetails::internal_deserialize(map)?)),
                    "shared_content_unshare_details" => Ok(EventDetails::SharedContentUnshareDetails(SharedContentUnshareDetails::internal_deserialize(map)?)),
                    "shared_content_view_details" => Ok(EventDetails::SharedContentViewDetails(SharedContentViewDetails::internal_deserialize(map)?)),
                    "shared_folder_change_link_policy_details" => Ok(EventDetails::SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_inheritance_policy_details" => Ok(EventDetails::SharedFolderChangeMembersInheritancePolicyDetails(SharedFolderChangeMembersInheritancePolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_management_policy_details" => Ok(EventDetails::SharedFolderChangeMembersManagementPolicyDetails(SharedFolderChangeMembersManagementPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_policy_details" => Ok(EventDetails::SharedFolderChangeMembersPolicyDetails(SharedFolderChangeMembersPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_create_details" => Ok(EventDetails::SharedFolderCreateDetails(SharedFolderCreateDetails::internal_deserialize(map)?)),
                    "shared_folder_decline_invitation_details" => Ok(EventDetails::SharedFolderDeclineInvitationDetails(SharedFolderDeclineInvitationDetails::internal_deserialize(map)?)),
                    "shared_folder_mount_details" => Ok(EventDetails::SharedFolderMountDetails(SharedFolderMountDetails::internal_deserialize(map)?)),
                    "shared_folder_nest_details" => Ok(EventDetails::SharedFolderNestDetails(SharedFolderNestDetails::internal_deserialize(map)?)),
                    "shared_folder_transfer_ownership_details" => Ok(EventDetails::SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails::internal_deserialize(map)?)),
                    "shared_folder_unmount_details" => Ok(EventDetails::SharedFolderUnmountDetails(SharedFolderUnmountDetails::internal_deserialize(map)?)),
                    "shared_link_add_expiry_details" => Ok(EventDetails::SharedLinkAddExpiryDetails(SharedLinkAddExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_change_expiry_details" => Ok(EventDetails::SharedLinkChangeExpiryDetails(SharedLinkChangeExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_change_visibility_details" => Ok(EventDetails::SharedLinkChangeVisibilityDetails(SharedLinkChangeVisibilityDetails::internal_deserialize(map)?)),
                    "shared_link_copy_details" => Ok(EventDetails::SharedLinkCopyDetails(SharedLinkCopyDetails::internal_deserialize(map)?)),
                    "shared_link_create_details" => Ok(EventDetails::SharedLinkCreateDetails(SharedLinkCreateDetails::internal_deserialize(map)?)),
                    "shared_link_disable_details" => Ok(EventDetails::SharedLinkDisableDetails(SharedLinkDisableDetails::internal_deserialize(map)?)),
                    "shared_link_download_details" => Ok(EventDetails::SharedLinkDownloadDetails(SharedLinkDownloadDetails::internal_deserialize(map)?)),
                    "shared_link_remove_expiry_details" => Ok(EventDetails::SharedLinkRemoveExpiryDetails(SharedLinkRemoveExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_share_details" => Ok(EventDetails::SharedLinkShareDetails(SharedLinkShareDetails::internal_deserialize(map)?)),
                    "shared_link_view_details" => Ok(EventDetails::SharedLinkViewDetails(SharedLinkViewDetails::internal_deserialize(map)?)),
                    "shared_note_opened_details" => Ok(EventDetails::SharedNoteOpenedDetails(SharedNoteOpenedDetails::internal_deserialize(map)?)),
                    "shmodel_group_share_details" => Ok(EventDetails::ShmodelGroupShareDetails(ShmodelGroupShareDetails::internal_deserialize(map)?)),
                    "sso_add_cert_details" => Ok(EventDetails::SsoAddCertDetails(SsoAddCertDetails::internal_deserialize(map)?)),
                    "sso_add_login_url_details" => Ok(EventDetails::SsoAddLoginUrlDetails(SsoAddLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_add_logout_url_details" => Ok(EventDetails::SsoAddLogoutUrlDetails(SsoAddLogoutUrlDetails::internal_deserialize(map)?)),
                    "sso_change_cert_details" => Ok(EventDetails::SsoChangeCertDetails(SsoChangeCertDetails::internal_deserialize(map)?)),
                    "sso_change_login_url_details" => Ok(EventDetails::SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_change_logout_url_details" => Ok(EventDetails::SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails::internal_deserialize(map)?)),
                    "sso_change_saml_identity_mode_details" => Ok(EventDetails::SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails::internal_deserialize(map)?)),
                    "sso_remove_cert_details" => Ok(EventDetails::SsoRemoveCertDetails(SsoRemoveCertDetails::internal_deserialize(map)?)),
                    "sso_remove_login_url_details" => Ok(EventDetails::SsoRemoveLoginUrlDetails(SsoRemoveLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_remove_logout_url_details" => Ok(EventDetails::SsoRemoveLogoutUrlDetails(SsoRemoveLogoutUrlDetails::internal_deserialize(map)?)),
                    "team_folder_change_status_details" => Ok(EventDetails::TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails::internal_deserialize(map)?)),
                    "team_folder_create_details" => Ok(EventDetails::TeamFolderCreateDetails(TeamFolderCreateDetails::internal_deserialize(map)?)),
                    "team_folder_downgrade_details" => Ok(EventDetails::TeamFolderDowngradeDetails(TeamFolderDowngradeDetails::internal_deserialize(map)?)),
                    "team_folder_permanently_delete_details" => Ok(EventDetails::TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "team_folder_rename_details" => Ok(EventDetails::TeamFolderRenameDetails(TeamFolderRenameDetails::internal_deserialize(map)?)),
                    "account_capture_change_policy_details" => Ok(EventDetails::AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails::internal_deserialize(map)?)),
                    "allow_download_disabled_details" => Ok(EventDetails::AllowDownloadDisabledDetails(AllowDownloadDisabledDetails::internal_deserialize(map)?)),
                    "allow_download_enabled_details" => Ok(EventDetails::AllowDownloadEnabledDetails(AllowDownloadEnabledDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_change_policy_details" => Ok(EventDetails::DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_satisfy_policy_details" => Ok(EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_desktop_policy_details" => Ok(EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_mobile_policy_details" => Ok(EventDetails::DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_overage_action_details" => Ok(EventDetails::DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)?)),
                    "device_approvals_change_unlink_action_details" => Ok(EventDetails::DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)?)),
                    "emm_add_exception_details" => Ok(EventDetails::EmmAddExceptionDetails(EmmAddExceptionDetails::internal_deserialize(map)?)),
                    "emm_change_policy_details" => Ok(EventDetails::EmmChangePolicyDetails(EmmChangePolicyDetails::internal_deserialize(map)?)),
                    "emm_remove_exception_details" => Ok(EventDetails::EmmRemoveExceptionDetails(EmmRemoveExceptionDetails::internal_deserialize(map)?)),
                    "extended_version_history_change_policy_details" => Ok(EventDetails::ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)?)),
                    "file_comments_change_policy_details" => Ok(EventDetails::FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_requests_change_policy_details" => Ok(EventDetails::FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_requests_emails_enabled_details" => Ok(EventDetails::FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails::internal_deserialize(map)?)),
                    "file_requests_emails_restricted_to_team_only_details" => Ok(EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)?)),
                    "google_sso_change_policy_details" => Ok(EventDetails::GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails::internal_deserialize(map)?)),
                    "group_user_management_change_policy_details" => Ok(EventDetails::GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails::internal_deserialize(map)?)),
                    "member_requests_change_policy_details" => Ok(EventDetails::MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_add_exception_details" => Ok(EventDetails::MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_caps_type_policy_details" => Ok(EventDetails::MemberSpaceLimitsChangeCapsTypePolicyDetails(MemberSpaceLimitsChangeCapsTypePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_policy_details" => Ok(EventDetails::MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_remove_exception_details" => Ok(EventDetails::MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)?)),
                    "member_suggestions_change_policy_details" => Ok(EventDetails::MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails::internal_deserialize(map)?)),
                    "microsoft_office_addin_change_policy_details" => Ok(EventDetails::MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)?)),
                    "network_control_change_policy_details" => Ok(EventDetails::NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails::internal_deserialize(map)?)),
                    "paper_change_deployment_policy_details" => Ok(EventDetails::PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_member_link_policy_details" => Ok(EventDetails::PaperChangeMemberLinkPolicyDetails(PaperChangeMemberLinkPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_member_policy_details" => Ok(EventDetails::PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_policy_details" => Ok(EventDetails::PaperChangePolicyDetails(PaperChangePolicyDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_addition_details" => Ok(EventDetails::PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_removal_details" => Ok(EventDetails::PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)?)),
                    "permanent_delete_change_policy_details" => Ok(EventDetails::PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_folder_join_policy_details" => Ok(EventDetails::SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_link_policy_details" => Ok(EventDetails::SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_member_policy_details" => Ok(EventDetails::SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "smart_sync_change_policy_details" => Ok(EventDetails::SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails::internal_deserialize(map)?)),
                    "smart_sync_not_opt_out_details" => Ok(EventDetails::SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails::internal_deserialize(map)?)),
                    "smart_sync_opt_out_details" => Ok(EventDetails::SmartSyncOptOutDetails(SmartSyncOptOutDetails::internal_deserialize(map)?)),
                    "sso_change_policy_details" => Ok(EventDetails::SsoChangePolicyDetails(SsoChangePolicyDetails::internal_deserialize(map)?)),
                    "tfa_change_policy_details" => Ok(EventDetails::TfaChangePolicyDetails(TfaChangePolicyDetails::internal_deserialize(map)?)),
                    "two_account_change_policy_details" => Ok(EventDetails::TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails::internal_deserialize(map)?)),
                    "web_sessions_change_fixed_length_policy_details" => Ok(EventDetails::WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)?)),
                    "web_sessions_change_idle_length_policy_details" => Ok(EventDetails::WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)?)),
                    "team_merge_from_details" => Ok(EventDetails::TeamMergeFromDetails(TeamMergeFromDetails::internal_deserialize(map)?)),
                    "team_merge_to_details" => Ok(EventDetails::TeamMergeToDetails(TeamMergeToDetails::internal_deserialize(map)?)),
                    "team_profile_add_logo_details" => Ok(EventDetails::TeamProfileAddLogoDetails(TeamProfileAddLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_default_language_details" => Ok(EventDetails::TeamProfileChangeDefaultLanguageDetails(TeamProfileChangeDefaultLanguageDetails::internal_deserialize(map)?)),
                    "team_profile_change_logo_details" => Ok(EventDetails::TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_name_details" => Ok(EventDetails::TeamProfileChangeNameDetails(TeamProfileChangeNameDetails::internal_deserialize(map)?)),
                    "team_profile_remove_logo_details" => Ok(EventDetails::TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails::internal_deserialize(map)?)),
                    "tfa_add_backup_phone_details" => Ok(EventDetails::TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_add_security_key_details" => Ok(EventDetails::TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_change_backup_phone_details" => Ok(EventDetails::TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_change_status_details" => Ok(EventDetails::TfaChangeStatusDetails(TfaChangeStatusDetails::internal_deserialize(map)?)),
                    "tfa_remove_backup_phone_details" => Ok(EventDetails::TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_remove_security_key_details" => Ok(EventDetails::TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_reset_details" => Ok(EventDetails::TfaResetDetails(TfaResetDetails::internal_deserialize(map)?)),
                    "missing_details" => Ok(EventDetails::MissingDetails(MissingDetails::internal_deserialize(map)?)),
                    _ => Ok(EventDetails::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["app_link_team_details",
                                    "app_link_user_details",
                                    "app_unlink_team_details",
                                    "app_unlink_user_details",
                                    "file_add_comment_details",
                                    "file_change_comment_subscription_details",
                                    "file_delete_comment_details",
                                    "file_like_comment_details",
                                    "file_resolve_comment_details",
                                    "file_unlike_comment_details",
                                    "file_unresolve_comment_details",
                                    "device_change_ip_desktop_details",
                                    "device_change_ip_mobile_details",
                                    "device_change_ip_web_details",
                                    "device_delete_on_unlink_fail_details",
                                    "device_delete_on_unlink_success_details",
                                    "device_link_fail_details",
                                    "device_link_success_details",
                                    "device_management_disabled_details",
                                    "device_management_enabled_details",
                                    "device_unlink_details",
                                    "emm_refresh_auth_token_details",
                                    "account_capture_change_availability_details",
                                    "account_capture_migrate_account_details",
                                    "account_capture_notification_emails_sent_details",
                                    "account_capture_relinquish_account_details",
                                    "disabled_domain_invites_details",
                                    "domain_invites_approve_request_to_join_team_details",
                                    "domain_invites_decline_request_to_join_team_details",
                                    "domain_invites_email_existing_users_details",
                                    "domain_invites_request_to_join_team_details",
                                    "domain_invites_set_invite_new_user_pref_to_no_details",
                                    "domain_invites_set_invite_new_user_pref_to_yes_details",
                                    "domain_verification_add_domain_fail_details",
                                    "domain_verification_add_domain_success_details",
                                    "domain_verification_remove_domain_details",
                                    "enabled_domain_invites_details",
                                    "create_folder_details",
                                    "file_add_details",
                                    "file_copy_details",
                                    "file_delete_details",
                                    "file_download_details",
                                    "file_edit_details",
                                    "file_get_copy_reference_details",
                                    "file_move_details",
                                    "file_permanently_delete_details",
                                    "file_preview_details",
                                    "file_rename_details",
                                    "file_restore_details",
                                    "file_revert_details",
                                    "file_rollback_changes_details",
                                    "file_save_copy_reference_details",
                                    "file_request_change_details",
                                    "file_request_close_details",
                                    "file_request_create_details",
                                    "file_request_receive_file_details",
                                    "group_add_external_id_details",
                                    "group_add_member_details",
                                    "group_change_external_id_details",
                                    "group_change_management_type_details",
                                    "group_change_member_role_details",
                                    "group_create_details",
                                    "group_delete_details",
                                    "group_moved_details",
                                    "group_remove_external_id_details",
                                    "group_remove_member_details",
                                    "group_rename_details",
                                    "emm_error_details",
                                    "login_fail_details",
                                    "login_success_details",
                                    "logout_details",
                                    "reseller_support_session_end_details",
                                    "reseller_support_session_start_details",
                                    "sign_in_as_session_end_details",
                                    "sign_in_as_session_start_details",
                                    "sso_error_details",
                                    "member_add_name_details",
                                    "member_change_admin_role_details",
                                    "member_change_email_details",
                                    "member_change_membership_type_details",
                                    "member_change_name_details",
                                    "member_change_status_details",
                                    "member_permanently_delete_account_contents_details",
                                    "member_space_limits_add_custom_quota_details",
                                    "member_space_limits_change_custom_quota_details",
                                    "member_space_limits_change_status_details",
                                    "member_space_limits_remove_custom_quota_details",
                                    "member_suggest_details",
                                    "member_transfer_account_contents_details",
                                    "paper_content_add_member_details",
                                    "paper_content_add_to_folder_details",
                                    "paper_content_archive_details",
                                    "paper_content_create_details",
                                    "paper_content_permanently_delete_details",
                                    "paper_content_remove_from_folder_details",
                                    "paper_content_remove_member_details",
                                    "paper_content_rename_details",
                                    "paper_content_restore_details",
                                    "paper_doc_add_comment_details",
                                    "paper_doc_change_member_role_details",
                                    "paper_doc_change_sharing_policy_details",
                                    "paper_doc_change_subscription_details",
                                    "paper_doc_deleted_details",
                                    "paper_doc_delete_comment_details",
                                    "paper_doc_download_details",
                                    "paper_doc_edit_details",
                                    "paper_doc_edit_comment_details",
                                    "paper_doc_followed_details",
                                    "paper_doc_mention_details",
                                    "paper_doc_request_access_details",
                                    "paper_doc_resolve_comment_details",
                                    "paper_doc_revert_details",
                                    "paper_doc_slack_share_details",
                                    "paper_doc_team_invite_details",
                                    "paper_doc_trashed_details",
                                    "paper_doc_unresolve_comment_details",
                                    "paper_doc_untrashed_details",
                                    "paper_doc_view_details",
                                    "paper_external_view_allow_details",
                                    "paper_external_view_default_team_details",
                                    "paper_external_view_forbid_details",
                                    "paper_folder_change_subscription_details",
                                    "paper_folder_deleted_details",
                                    "paper_folder_followed_details",
                                    "paper_folder_team_invite_details",
                                    "password_change_details",
                                    "password_reset_details",
                                    "password_reset_all_details",
                                    "emm_create_exceptions_report_details",
                                    "emm_create_usage_report_details",
                                    "export_members_report_details",
                                    "paper_admin_export_start_details",
                                    "smart_sync_create_admin_privilege_report_details",
                                    "team_activity_create_report_details",
                                    "collection_share_details",
                                    "note_acl_invite_only_details",
                                    "note_acl_link_details",
                                    "note_acl_team_link_details",
                                    "note_shared_details",
                                    "note_share_receive_details",
                                    "open_note_shared_details",
                                    "sf_add_group_details",
                                    "sf_allow_non_members_to_view_shared_links_details",
                                    "sf_external_invite_warn_details",
                                    "sf_fb_invite_details",
                                    "sf_fb_invite_change_role_details",
                                    "sf_fb_uninvite_details",
                                    "sf_invite_group_details",
                                    "sf_team_grant_access_details",
                                    "sf_team_invite_details",
                                    "sf_team_invite_change_role_details",
                                    "sf_team_join_details",
                                    "sf_team_join_from_oob_link_details",
                                    "sf_team_uninvite_details",
                                    "shared_content_add_invitees_details",
                                    "shared_content_add_link_expiry_details",
                                    "shared_content_add_link_password_details",
                                    "shared_content_add_member_details",
                                    "shared_content_change_downloads_policy_details",
                                    "shared_content_change_invitee_role_details",
                                    "shared_content_change_link_audience_details",
                                    "shared_content_change_link_expiry_details",
                                    "shared_content_change_link_password_details",
                                    "shared_content_change_member_role_details",
                                    "shared_content_change_viewer_info_policy_details",
                                    "shared_content_claim_invitation_details",
                                    "shared_content_copy_details",
                                    "shared_content_download_details",
                                    "shared_content_relinquish_membership_details",
                                    "shared_content_remove_invitees_details",
                                    "shared_content_remove_link_expiry_details",
                                    "shared_content_remove_link_password_details",
                                    "shared_content_remove_member_details",
                                    "shared_content_request_access_details",
                                    "shared_content_unshare_details",
                                    "shared_content_view_details",
                                    "shared_folder_change_link_policy_details",
                                    "shared_folder_change_members_inheritance_policy_details",
                                    "shared_folder_change_members_management_policy_details",
                                    "shared_folder_change_members_policy_details",
                                    "shared_folder_create_details",
                                    "shared_folder_decline_invitation_details",
                                    "shared_folder_mount_details",
                                    "shared_folder_nest_details",
                                    "shared_folder_transfer_ownership_details",
                                    "shared_folder_unmount_details",
                                    "shared_link_add_expiry_details",
                                    "shared_link_change_expiry_details",
                                    "shared_link_change_visibility_details",
                                    "shared_link_copy_details",
                                    "shared_link_create_details",
                                    "shared_link_disable_details",
                                    "shared_link_download_details",
                                    "shared_link_remove_expiry_details",
                                    "shared_link_share_details",
                                    "shared_link_view_details",
                                    "shared_note_opened_details",
                                    "shmodel_group_share_details",
                                    "sso_add_cert_details",
                                    "sso_add_login_url_details",
                                    "sso_add_logout_url_details",
                                    "sso_change_cert_details",
                                    "sso_change_login_url_details",
                                    "sso_change_logout_url_details",
                                    "sso_change_saml_identity_mode_details",
                                    "sso_remove_cert_details",
                                    "sso_remove_login_url_details",
                                    "sso_remove_logout_url_details",
                                    "team_folder_change_status_details",
                                    "team_folder_create_details",
                                    "team_folder_downgrade_details",
                                    "team_folder_permanently_delete_details",
                                    "team_folder_rename_details",
                                    "account_capture_change_policy_details",
                                    "allow_download_disabled_details",
                                    "allow_download_enabled_details",
                                    "data_placement_restriction_change_policy_details",
                                    "data_placement_restriction_satisfy_policy_details",
                                    "device_approvals_change_desktop_policy_details",
                                    "device_approvals_change_mobile_policy_details",
                                    "device_approvals_change_overage_action_details",
                                    "device_approvals_change_unlink_action_details",
                                    "emm_add_exception_details",
                                    "emm_change_policy_details",
                                    "emm_remove_exception_details",
                                    "extended_version_history_change_policy_details",
                                    "file_comments_change_policy_details",
                                    "file_requests_change_policy_details",
                                    "file_requests_emails_enabled_details",
                                    "file_requests_emails_restricted_to_team_only_details",
                                    "google_sso_change_policy_details",
                                    "group_user_management_change_policy_details",
                                    "member_requests_change_policy_details",
                                    "member_space_limits_add_exception_details",
                                    "member_space_limits_change_caps_type_policy_details",
                                    "member_space_limits_change_policy_details",
                                    "member_space_limits_remove_exception_details",
                                    "member_suggestions_change_policy_details",
                                    "microsoft_office_addin_change_policy_details",
                                    "network_control_change_policy_details",
                                    "paper_change_deployment_policy_details",
                                    "paper_change_member_link_policy_details",
                                    "paper_change_member_policy_details",
                                    "paper_change_policy_details",
                                    "paper_enabled_users_group_addition_details",
                                    "paper_enabled_users_group_removal_details",
                                    "permanent_delete_change_policy_details",
                                    "sharing_change_folder_join_policy_details",
                                    "sharing_change_link_policy_details",
                                    "sharing_change_member_policy_details",
                                    "smart_sync_change_policy_details",
                                    "smart_sync_not_opt_out_details",
                                    "smart_sync_opt_out_details",
                                    "sso_change_policy_details",
                                    "tfa_change_policy_details",
                                    "two_account_change_policy_details",
                                    "web_sessions_change_fixed_length_policy_details",
                                    "web_sessions_change_idle_length_policy_details",
                                    "team_merge_from_details",
                                    "team_merge_to_details",
                                    "team_profile_add_logo_details",
                                    "team_profile_change_default_language_details",
                                    "team_profile_change_logo_details",
                                    "team_profile_change_name_details",
                                    "team_profile_remove_logo_details",
                                    "tfa_add_backup_phone_details",
                                    "tfa_add_security_key_details",
                                    "tfa_change_backup_phone_details",
                                    "tfa_change_status_details",
                                    "tfa_remove_backup_phone_details",
                                    "tfa_remove_security_key_details",
                                    "tfa_reset_details",
                                    "missing_details",
                                    "other"];
        deserializer.deserialize_struct("EventDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventDetails::AppLinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppLinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileChangeCommentSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_change_comment_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileLikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_like_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileUnlikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_unlike_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpDesktopDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_desktop_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpMobileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_mobile_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpWebDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_change_ip_web_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_link_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_link_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceManagementDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_disabled_details")?;
                s.end()
            }
            EventDetails::DeviceManagementEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_enabled_details")?;
                s.end()
            }
            EventDetails::DeviceUnlinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "device_unlink_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRefreshAuthTokenDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_refresh_auth_token_details")?;
                s.end()
            }
            EventDetails::AccountCaptureChangeAvailabilityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_availability_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureMigrateAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_migrate_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureNotificationEmailsSentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_notification_emails_sent_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureRelinquishAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_relinquish_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DisabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "disabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesEmailExistingUsersDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainInvitesRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes_details")?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationRemoveDomainDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "domain_verification_remove_domain_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EnabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "enabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::CreateFolderDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "create_folder_details")?;
                s.end()
            }
            EventDetails::FileAddDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_add_details")?;
                s.end()
            }
            EventDetails::FileCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_delete_details")?;
                s.end()
            }
            EventDetails::FileDownloadDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_download_details")?;
                s.end()
            }
            EventDetails::FileEditDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_edit_details")?;
                s.end()
            }
            EventDetails::FileGetCopyReferenceDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_get_copy_reference_details")?;
                s.end()
            }
            EventDetails::FileMoveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_move_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FilePermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_permanently_delete_details")?;
                s.end()
            }
            EventDetails::FilePreviewDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_preview_details")?;
                s.end()
            }
            EventDetails::FileRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRestoreDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_restore_details")?;
                s.end()
            }
            EventDetails::FileRevertDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_revert_details")?;
                s.end()
            }
            EventDetails::FileRollbackChangesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_rollback_changes_details")?;
                s.end()
            }
            EventDetails::FileSaveCopyReferenceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_save_copy_reference_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestChangeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "file_request_change_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCloseDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_close_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestReceiveFileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "file_request_receive_file_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeManagementTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_management_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupMovedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_moved_details")?;
                s.end()
            }
            EventDetails::GroupRemoveExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_remove_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupRemoveMemberDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_remove_member_details")?;
                s.end()
            }
            EventDetails::GroupRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmErrorDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "emm_error_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LoginFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "login_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LoginSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "login_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LogoutDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "logout_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_end_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_start_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_end_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_start_details")?;
                s.end()
            }
            EventDetails::SsoErrorDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_error_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberAddNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_add_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeAdminRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_admin_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeEmailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_email_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeMembershipTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_membership_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "member_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberPermanentlyDeleteAccountContentsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsAddCustomQuotaDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_custom_quota_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeCustomQuotaDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_custom_quota_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsRemoveCustomQuotaDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_custom_quota_details")?;
                s.end()
            }
            EventDetails::MemberSuggestDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_suggest_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberTransferAccountContentsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_transfer_account_contents_details")?;
                s.end()
            }
            EventDetails::PaperContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentAddToFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_content_add_to_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentArchiveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_archive_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentPermanentlyDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_permanently_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveFromFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRestoreDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_restore_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeSharingPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_change_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_edit_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_edit_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocMentionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_mention_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRevertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_revert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocSlackShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_slack_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocTrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_trashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocUntrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_untrashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewAllowDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_allow_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewDefaultTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_default_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewForbidDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_forbid_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderChangeSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_folder_change_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PasswordChangeDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_change_details")?;
                s.end()
            }
            EventDetails::PasswordResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_details")?;
                s.end()
            }
            EventDetails::PasswordResetAllDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_all_details")?;
                s.end()
            }
            EventDetails::EmmCreateExceptionsReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_exceptions_report_details")?;
                s.end()
            }
            EventDetails::EmmCreateUsageReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_usage_report_details")?;
                s.end()
            }
            EventDetails::ExportMembersReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "export_members_report_details")?;
                s.end()
            }
            EventDetails::PaperAdminExportStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_admin_export_start_details")?;
                s.end()
            }
            EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report_details")?;
                s.end()
            }
            EventDetails::TeamActivityCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_activity_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::CollectionShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "collection_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoteAclInviteOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_invite_only_details")?;
                s.end()
            }
            EventDetails::NoteAclLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_link_details")?;
                s.end()
            }
            EventDetails::NoteAclTeamLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_team_link_details")?;
                s.end()
            }
            EventDetails::NoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_shared_details")?;
                s.end()
            }
            EventDetails::NoteShareReceiveDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_share_receive_details")?;
                s.end()
            }
            EventDetails::OpenNoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "open_note_shared_details")?;
                s.end()
            }
            EventDetails::SfAddGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_add_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfAllowNonMembersToViewSharedLinksDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfExternalInviteWarnDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_external_invite_warn_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_fb_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbInviteChangeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_fb_invite_change_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbUninviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_fb_uninvite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfInviteGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sf_invite_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamGrantAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_grant_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteChangeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_invite_change_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_join_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinFromOobLinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamUninviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_uninvite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_add_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_add_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeDownloadsPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeInviteeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkAudienceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_link_audience_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_change_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeViewerInfoPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentClaimInvitationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_claim_invitation_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRelinquishMembershipDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership_details")?;
                s.end()
            }
            EventDetails::SharedContentRemoveInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_remove_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentUnshareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_unshare_details")?;
                s.end()
            }
            EventDetails::SharedContentViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersInheritancePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_inheritance_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersManagementPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_management_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_folder_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderDeclineInvitationDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_decline_invitation_details")?;
                s.end()
            }
            EventDetails::SharedFolderMountDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_mount_details")?;
                s.end()
            }
            EventDetails::SharedFolderNestDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_nest_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderTransferOwnershipDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderUnmountDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_unmount_details")?;
                s.end()
            }
            EventDetails::SharedLinkAddExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_add_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkChangeExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_change_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkChangeVisibilityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_change_visibility_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkDisableDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_disable_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkRemoveExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_remove_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedNoteOpenedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_note_opened_details")?;
                s.end()
            }
            EventDetails::ShmodelGroupShareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_group_share_details")?;
                s.end()
            }
            EventDetails::SsoAddCertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_cert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoAddLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoAddLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeCertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_cert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeSamlIdentityModeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoRemoveCertDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sso_remove_cert_details")?;
                s.end()
            }
            EventDetails::SsoRemoveLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_remove_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoRemoveLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_remove_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_folder_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderCreateDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_create_details")?;
                s.end()
            }
            EventDetails::TeamFolderDowngradeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_folder_downgrade_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderPermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_permanently_delete_details")?;
                s.end()
            }
            EventDetails::TeamFolderRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_folder_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AllowDownloadDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_disabled_details")?;
                s.end()
            }
            EventDetails::AllowDownloadEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_enabled_details")?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeMobilePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeOverageActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeUnlinkActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_add_exception_details")?;
                s.end()
            }
            EventDetails::EmmChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "emm_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_remove_exception_details")?;
                s.end()
            }
            EventDetails::ExtendedVersionHistoryChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "extended_version_history_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileCommentsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_comments_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsEmailsEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_enabled_details")?;
                s.end()
            }
            EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only_details")?;
                s.end()
            }
            EventDetails::GoogleSsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "google_sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupUserManagementChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_user_management_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_add_exception_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeCapsTypePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_caps_type_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception_details")?;
                s.end()
            }
            EventDetails::MemberSuggestionsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_suggestions_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MicrosoftOfficeAddinChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NetworkControlChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "network_control_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeDeploymentPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_deployment_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeMemberLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_change_member_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupAdditionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition_details")?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupRemovalDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal_details")?;
                s.end()
            }
            EventDetails::PermanentDeleteChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "permanent_delete_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeFolderJoinPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncNotOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "tfa_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TwoAccountChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "two_account_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeFixedLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeIdleLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeFromDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_from_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeToDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_to_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileAddLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_add_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeDefaultLanguageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_profile_change_default_language_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileChangeLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_change_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_profile_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileRemoveLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_remove_logo_details")?;
                s.end()
            }
            EventDetails::TfaAddBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaAddSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_security_key_details")?;
                s.end()
            }
            EventDetails::TfaChangeBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_change_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "tfa_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaRemoveBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaRemoveSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_security_key_details")?;
                s.end()
            }
            EventDetails::TfaResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_reset_details")?;
                s.end()
            }
            EventDetails::MissingDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "missing_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The type of the event.
#[derive(Debug)]
pub enum EventType {
    /// (apps) Linked an app for team.
    AppLinkTeam(AppLinkTeamType),
    /// (apps) Linked an app for team member.
    AppLinkUser(AppLinkUserType),
    /// (apps) Unlinked an app for team.
    AppUnlinkTeam(AppUnlinkTeamType),
    /// (apps) Unlinked an app for team member.
    AppUnlinkUser(AppUnlinkUserType),
    /// (comments) Added a file comment.
    FileAddComment(FileAddCommentType),
    /// (comments) Subscribed to or unsubscribed from comment notifications for file.
    FileChangeCommentSubscription(FileChangeCommentSubscriptionType),
    /// (comments) Deleted a file comment.
    FileDeleteComment(FileDeleteCommentType),
    /// (comments) Liked a file comment. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    FileLikeComment(FileLikeCommentType),
    /// (comments) Resolved a file comment.
    FileResolveComment(FileResolveCommentType),
    /// (comments) Unliked a file comment. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    FileUnlikeComment(FileUnlikeCommentType),
    /// (comments) Unresolved a file comment.
    FileUnresolveComment(FileUnresolveCommentType),
    /// (devices) IP address associated with active desktop session changed.
    DeviceChangeIpDesktop(DeviceChangeIpDesktopType),
    /// (devices) IP address associated with active mobile session changed.
    DeviceChangeIpMobile(DeviceChangeIpMobileType),
    /// (devices) IP address associated with active Web session changed.
    DeviceChangeIpWeb(DeviceChangeIpWebType),
    /// (devices) Failed to delete all files from an unlinked device.
    DeviceDeleteOnUnlinkFail(DeviceDeleteOnUnlinkFailType),
    /// (devices) Deleted all files from an unlinked device.
    DeviceDeleteOnUnlinkSuccess(DeviceDeleteOnUnlinkSuccessType),
    /// (devices) Failed to link a device.
    DeviceLinkFail(DeviceLinkFailType),
    /// (devices) Linked a device.
    DeviceLinkSuccess(DeviceLinkSuccessType),
    /// (devices) Disable Device Management. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    DeviceManagementDisabled(DeviceManagementDisabledType),
    /// (devices) Enable Device Management. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    DeviceManagementEnabled(DeviceManagementEnabledType),
    /// (devices) Disconnected a device.
    DeviceUnlink(DeviceUnlinkType),
    /// (devices) Refreshed the auth token used for setting up enterprise mobility management.
    EmmRefreshAuthToken(EmmRefreshAuthTokenType),
    /// (domains) Granted or revoked the option to enable account capture on domains belonging to
    /// the team.
    AccountCaptureChangeAvailability(AccountCaptureChangeAvailabilityType),
    /// (domains) Account captured user migrated their account to the team.
    AccountCaptureMigrateAccount(AccountCaptureMigrateAccountType),
    /// (domains) Proactive account capture email sent to all unmanaged members.
    AccountCaptureNotificationEmailsSent(AccountCaptureNotificationEmailsSentType),
    /// (domains) Account captured user relinquished their account by changing the email address
    /// associated with it.
    AccountCaptureRelinquishAccount(AccountCaptureRelinquishAccountType),
    /// (domains) Disabled domain invites. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    DisabledDomainInvites(DisabledDomainInvitesType),
    /// (domains) Approved a member's request to join the team.
    DomainInvitesApproveRequestToJoinTeam(DomainInvitesApproveRequestToJoinTeamType),
    /// (domains) Declined a user's request to join the team.
    DomainInvitesDeclineRequestToJoinTeam(DomainInvitesDeclineRequestToJoinTeamType),
    /// (domains) Sent domain invites to existing domain accounts.
    DomainInvitesEmailExistingUsers(DomainInvitesEmailExistingUsersType),
    /// (domains) Asked to join the team.
    DomainInvitesRequestToJoinTeam(DomainInvitesRequestToJoinTeamType),
    /// (domains) Turned off u201cAutomatically invite new usersu201d. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    DomainInvitesSetInviteNewUserPrefToNo(DomainInvitesSetInviteNewUserPrefToNoType),
    /// (domains) Turned on u201cAutomatically invite new usersu201d. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    DomainInvitesSetInviteNewUserPrefToYes(DomainInvitesSetInviteNewUserPrefToYesType),
    /// (domains) Failed to verify a domain belonging to the team.
    DomainVerificationAddDomainFail(DomainVerificationAddDomainFailType),
    /// (domains) Verified a domain belonging to the team.
    DomainVerificationAddDomainSuccess(DomainVerificationAddDomainSuccessType),
    /// (domains) Removed a domain from the list of verified domains belonging to the team.
    DomainVerificationRemoveDomain(DomainVerificationRemoveDomainType),
    /// (domains) Enabled domain invites. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    EnabledDomainInvites(EnabledDomainInvitesType),
    /// (file_operations) Created folders. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    CreateFolder(CreateFolderType),
    /// (file_operations) Added files and/or folders.
    FileAdd(FileAddType),
    /// (file_operations) Copied files and/or folders.
    FileCopy(FileCopyType),
    /// (file_operations) Deleted files and/or folders.
    FileDelete(FileDeleteType),
    /// (file_operations) Downloaded files and/or folders.
    FileDownload(FileDownloadType),
    /// (file_operations) Edited files.
    FileEdit(FileEditType),
    /// (file_operations) Create a copy reference to a file or folder.
    FileGetCopyReference(FileGetCopyReferenceType),
    /// (file_operations) Moved files and/or folders.
    FileMove(FileMoveType),
    /// (file_operations) Permanently deleted files and/or folders.
    FilePermanentlyDelete(FilePermanentlyDeleteType),
    /// (file_operations) Previewed files and/or folders.
    FilePreview(FilePreviewType),
    /// (file_operations) Renamed files and/or folders.
    FileRename(FileRenameType),
    /// (file_operations) Restored deleted files and/or folders.
    FileRestore(FileRestoreType),
    /// (file_operations) Reverted files to a previous version.
    FileRevert(FileRevertType),
    /// (file_operations) Rolled back file change location changes.
    FileRollbackChanges(FileRollbackChangesType),
    /// (file_operations) Save a file or folder using a copy reference.
    FileSaveCopyReference(FileSaveCopyReferenceType),
    /// (file_requests) Change a file request.
    FileRequestChange(FileRequestChangeType),
    /// (file_requests) Closed a file request.
    FileRequestClose(FileRequestCloseType),
    /// (file_requests) Created a file request.
    FileRequestCreate(FileRequestCreateType),
    /// (file_requests) Received files for a file request.
    FileRequestReceiveFile(FileRequestReceiveFileType),
    /// (groups) Added an external ID for group.
    GroupAddExternalId(GroupAddExternalIdType),
    /// (groups) Added team members to a group.
    GroupAddMember(GroupAddMemberType),
    /// (groups) Changed the external ID for group.
    GroupChangeExternalId(GroupChangeExternalIdType),
    /// (groups) Changed group management type.
    GroupChangeManagementType(GroupChangeManagementTypeType),
    /// (groups) Changed the manager permissions belonging to a group member.
    GroupChangeMemberRole(GroupChangeMemberRoleType),
    /// (groups) Created a group.
    GroupCreate(GroupCreateType),
    /// (groups) Deleted a group.
    GroupDelete(GroupDeleteType),
    /// (groups) Moved a group. This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    GroupMoved(GroupMovedType),
    /// (groups) Removed the external ID for group.
    GroupRemoveExternalId(GroupRemoveExternalIdType),
    /// (groups) Removed team members from a group.
    GroupRemoveMember(GroupRemoveMemberType),
    /// (groups) Renamed a group.
    GroupRename(GroupRenameType),
    /// (logins) Failed to sign in via EMM. This event is replaced by login_fail and will not be
    /// logged going forward.
    EmmError(EmmErrorType),
    /// (logins) Failed to sign in.
    LoginFail(LoginFailType),
    /// (logins) Signed in.
    LoginSuccess(LoginSuccessType),
    /// (logins) Signed out.
    Logout(LogoutType),
    /// (logins) Ended reseller support session.
    ResellerSupportSessionEnd(ResellerSupportSessionEndType),
    /// (logins) Started reseller support session.
    ResellerSupportSessionStart(ResellerSupportSessionStartType),
    /// (logins) Ended admin sign-in-as session.
    SignInAsSessionEnd(SignInAsSessionEndType),
    /// (logins) Started admin sign-in-as session.
    SignInAsSessionStart(SignInAsSessionStartType),
    /// (logins) Failed to sign in via SSO. This event is replaced by login_fail and will not be
    /// logged going forward.
    SsoError(SsoErrorType),
    /// (members) Specify team member name.
    MemberAddName(MemberAddNameType),
    /// (members) Change the admin role belonging to team member.
    MemberChangeAdminRole(MemberChangeAdminRoleType),
    /// (members) Changed team member email address.
    MemberChangeEmail(MemberChangeEmailType),
    /// (members) Changed the membership type (limited vs full) for team member. This event is
    /// deprecated and will not be logged going forward as the associated product functionality no
    /// longer exists.
    MemberChangeMembershipType(MemberChangeMembershipTypeType),
    /// (members) Changed team member name.
    MemberChangeName(MemberChangeNameType),
    /// (members) Changed the membership status of a team member.
    MemberChangeStatus(MemberChangeStatusType),
    /// (members) Permanently deleted contents of a removed team member account.
    MemberPermanentlyDeleteAccountContents(MemberPermanentlyDeleteAccountContentsType),
    /// (members) Set custom member space limit.
    MemberSpaceLimitsAddCustomQuota(MemberSpaceLimitsAddCustomQuotaType),
    /// (members) Changed custom member space limit.
    MemberSpaceLimitsChangeCustomQuota(MemberSpaceLimitsChangeCustomQuotaType),
    /// (members) Changed the status with respect to whether the team member is under or over
    /// storage quota specified by policy.
    MemberSpaceLimitsChangeStatus(MemberSpaceLimitsChangeStatusType),
    /// (members) Removed custom member space limit.
    MemberSpaceLimitsRemoveCustomQuota(MemberSpaceLimitsRemoveCustomQuotaType),
    /// (members) Suggested a new team member to be added to the team.
    MemberSuggest(MemberSuggestType),
    /// (members) Transferred contents of a removed team member account to another member.
    MemberTransferAccountContents(MemberTransferAccountContentsType),
    /// (paper) Added users to the membership of a Paper doc or folder.
    PaperContentAddMember(PaperContentAddMemberType),
    /// (paper) Added Paper doc or folder to a folder.
    PaperContentAddToFolder(PaperContentAddToFolderType),
    /// (paper) Archived Paper doc or folder.
    PaperContentArchive(PaperContentArchiveType),
    /// (paper) Created a Paper doc or folder.
    PaperContentCreate(PaperContentCreateType),
    /// (paper) Permanently deleted a Paper doc or folder.
    PaperContentPermanentlyDelete(PaperContentPermanentlyDeleteType),
    /// (paper) Removed Paper doc or folder from a folder.
    PaperContentRemoveFromFolder(PaperContentRemoveFromFolderType),
    /// (paper) Removed a user from the membership of a Paper doc or folder.
    PaperContentRemoveMember(PaperContentRemoveMemberType),
    /// (paper) Renamed Paper doc or folder.
    PaperContentRename(PaperContentRenameType),
    /// (paper) Restored an archived Paper doc or folder.
    PaperContentRestore(PaperContentRestoreType),
    /// (paper) Added a Paper doc comment.
    PaperDocAddComment(PaperDocAddCommentType),
    /// (paper) Changed the access type of a Paper doc member.
    PaperDocChangeMemberRole(PaperDocChangeMemberRoleType),
    /// (paper) Changed the sharing policy for Paper doc.
    PaperDocChangeSharingPolicy(PaperDocChangeSharingPolicyType),
    /// (paper) Followed or unfollowed a Paper doc.
    PaperDocChangeSubscription(PaperDocChangeSubscriptionType),
    /// (paper) Paper doc archived. This event is deprecated and will not be logged going forward as
    /// the associated product functionality no longer exists.
    PaperDocDeleted(PaperDocDeletedType),
    /// (paper) Deleted a Paper doc comment.
    PaperDocDeleteComment(PaperDocDeleteCommentType),
    /// (paper) Downloaded a Paper doc in a particular output format.
    PaperDocDownload(PaperDocDownloadType),
    /// (paper) Edited a Paper doc.
    PaperDocEdit(PaperDocEditType),
    /// (paper) Edited a Paper doc comment.
    PaperDocEditComment(PaperDocEditCommentType),
    /// (paper) Followed a Paper doc. This event is replaced by paper_doc_change_subscription and
    /// will not be logged going forward.
    PaperDocFollowed(PaperDocFollowedType),
    /// (paper) Mentioned a member in a Paper doc.
    PaperDocMention(PaperDocMentionType),
    /// (paper) Requested to be a member on a Paper doc.
    PaperDocRequestAccess(PaperDocRequestAccessType),
    /// (paper) Paper doc comment resolved.
    PaperDocResolveComment(PaperDocResolveCommentType),
    /// (paper) Restored a Paper doc to previous revision.
    PaperDocRevert(PaperDocRevertType),
    /// (paper) Paper doc link shared via slack.
    PaperDocSlackShare(PaperDocSlackShareType),
    /// (paper) Paper doc shared with team member. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    PaperDocTeamInvite(PaperDocTeamInviteType),
    /// (paper) Paper doc trashed.
    PaperDocTrashed(PaperDocTrashedType),
    /// (paper) Unresolved a Paper doc comment.
    PaperDocUnresolveComment(PaperDocUnresolveCommentType),
    /// (paper) Paper doc untrashed.
    PaperDocUntrashed(PaperDocUntrashedType),
    /// (paper) Viewed Paper doc.
    PaperDocView(PaperDocViewType),
    /// (paper) Paper external sharing policy changed: anyone. This event is deprecated and will not
    /// be logged going forward as the associated product functionality no longer exists.
    PaperExternalViewAllow(PaperExternalViewAllowType),
    /// (paper) Paper external sharing policy changed: default team. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    PaperExternalViewDefaultTeam(PaperExternalViewDefaultTeamType),
    /// (paper) Paper external sharing policy changed: team-only. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    PaperExternalViewForbid(PaperExternalViewForbidType),
    /// (paper) Followed or unfollowed a Paper folder.
    PaperFolderChangeSubscription(PaperFolderChangeSubscriptionType),
    /// (paper) Paper folder archived. This event is deprecated and will not be logged going forward
    /// as the associated product functionality no longer exists.
    PaperFolderDeleted(PaperFolderDeletedType),
    /// (paper) Followed a Paper folder. This event is replaced by paper_folder_change_subscription
    /// and will not be logged going forward.
    PaperFolderFollowed(PaperFolderFollowedType),
    /// (paper) Paper folder shared with team member. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    PaperFolderTeamInvite(PaperFolderTeamInviteType),
    /// (passwords) Changed password.
    PasswordChange(PasswordChangeType),
    /// (passwords) Reset password.
    PasswordReset(PasswordResetType),
    /// (passwords) Reset all team member passwords.
    PasswordResetAll(PasswordResetAllType),
    /// (reports) EMM excluded users report created.
    EmmCreateExceptionsReport(EmmCreateExceptionsReportType),
    /// (reports) EMM mobile app usage report created.
    EmmCreateUsageReport(EmmCreateUsageReportType),
    /// (reports) Member data report created.
    ExportMembersReport(ExportMembersReportType),
    /// (reports) Exported all Paper documents in the team.
    PaperAdminExportStart(PaperAdminExportStartType),
    /// (reports) Smart Sync non-admin devices report created.
    SmartSyncCreateAdminPrivilegeReport(SmartSyncCreateAdminPrivilegeReportType),
    /// (reports) Created a team activity report.
    TeamActivityCreateReport(TeamActivityCreateReportType),
    /// (sharing) Shared an album.
    CollectionShare(CollectionShareType),
    /// (sharing) Changed a Paper document to be invite-only. This event is deprecated and will not
    /// be logged going forward as the associated product functionality no longer exists.
    NoteAclInviteOnly(NoteAclInviteOnlyType),
    /// (sharing) Changed a Paper document to be link accessible. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    NoteAclLink(NoteAclLinkType),
    /// (sharing) Changed a Paper document to be link accessible for the team. This event is
    /// deprecated and will not be logged going forward as the associated product functionality no
    /// longer exists.
    NoteAclTeamLink(NoteAclTeamLinkType),
    /// (sharing) Shared a Paper doc. This event is deprecated and will not be logged going forward
    /// as the associated product functionality no longer exists.
    NoteShared(NoteSharedType),
    /// (sharing) Shared Paper document received. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    NoteShareReceive(NoteShareReceiveType),
    /// (sharing) Opened a shared Paper doc. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    OpenNoteShared(OpenNoteSharedType),
    /// (sharing) Added the team to a shared folder. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    SfAddGroup(SfAddGroupType),
    /// (sharing) Allowed non collaborators to view links to files in a shared folder. This event is
    /// deprecated and will not be logged going forward as the associated product functionality no
    /// longer exists.
    SfAllowNonMembersToViewSharedLinks(SfAllowNonMembersToViewSharedLinksType),
    /// (sharing) Admin settings: team members see a warning before sharing folders outside the team
    /// (DEPRECATED FEATURE). This event is deprecated and will not be logged going forward as the
    /// associated product functionality no longer exists.
    SfExternalInviteWarn(SfExternalInviteWarnType),
    /// (sharing) Invited Facebook users to a shared folder. This event is deprecated and will not
    /// be logged going forward as the associated product functionality no longer exists.
    SfFbInvite(SfFbInviteType),
    /// (sharing) Changed a Facebook user's role in a shared folder. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    SfFbInviteChangeRole(SfFbInviteChangeRoleType),
    /// (sharing) Uninvited a Facebook user from a shared folder. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    SfFbUninvite(SfFbUninviteType),
    /// (sharing) Invited a group to a shared folder. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    SfInviteGroup(SfInviteGroupType),
    /// (sharing) Granted access to a shared folder. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    SfTeamGrantAccess(SfTeamGrantAccessType),
    /// (sharing) Invited team members to a shared folder. This event is replaced by
    /// shared_content_add_invitees and will not be logged going forward.
    SfTeamInvite(SfTeamInviteType),
    /// (sharing) Changed a team member's role in a shared folder. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    SfTeamInviteChangeRole(SfTeamInviteChangeRoleType),
    /// (sharing) Joined a team member's shared folder. This event is deprecated and will not be
    /// logged going forward as the associated product functionality no longer exists.
    SfTeamJoin(SfTeamJoinType),
    /// (sharing) Joined a team member's shared folder from a link. This event is deprecated and
    /// will not be logged going forward as the associated product functionality no longer exists.
    SfTeamJoinFromOobLink(SfTeamJoinFromOobLinkType),
    /// (sharing) Unshared a folder with a team member. This event is replaced by
    /// shared_content_remove_invitees and will not be logged going forward.
    SfTeamUninvite(SfTeamUninviteType),
    /// (sharing) Sent an email invitation to the membership of a shared file or folder.
    SharedContentAddInvitees(SharedContentAddInviteesType),
    /// (sharing) Added an expiry to the link for the shared file or folder.
    SharedContentAddLinkExpiry(SharedContentAddLinkExpiryType),
    /// (sharing) Added a password to the link for the shared file or folder.
    SharedContentAddLinkPassword(SharedContentAddLinkPasswordType),
    /// (sharing) Added users and/or groups to the membership of a shared file or folder.
    SharedContentAddMember(SharedContentAddMemberType),
    /// (sharing) Changed whether members can download the shared file or folder.
    SharedContentChangeDownloadsPolicy(SharedContentChangeDownloadsPolicyType),
    /// (sharing) Changed the access type of an invitee to a shared file or folder before the
    /// invitation was claimed.
    SharedContentChangeInviteeRole(SharedContentChangeInviteeRoleType),
    /// (sharing) Changed the audience of the link for a shared file or folder.
    SharedContentChangeLinkAudience(SharedContentChangeLinkAudienceType),
    /// (sharing) Changed the expiry of the link for the shared file or folder.
    SharedContentChangeLinkExpiry(SharedContentChangeLinkExpiryType),
    /// (sharing) Changed the password on the link for the shared file or folder.
    SharedContentChangeLinkPassword(SharedContentChangeLinkPasswordType),
    /// (sharing) Changed the access type of a shared file or folder member.
    SharedContentChangeMemberRole(SharedContentChangeMemberRoleType),
    /// (sharing) Changed whether members can see who viewed the shared file or folder.
    SharedContentChangeViewerInfoPolicy(SharedContentChangeViewerInfoPolicyType),
    /// (sharing) Acquired membership on a shared file or folder by claiming an invitation.
    SharedContentClaimInvitation(SharedContentClaimInvitationType),
    /// (sharing) Copied the shared file or folder to own Dropbox.
    SharedContentCopy(SharedContentCopyType),
    /// (sharing) Downloaded the shared file or folder.
    SharedContentDownload(SharedContentDownloadType),
    /// (sharing) Left the membership of a shared file or folder.
    SharedContentRelinquishMembership(SharedContentRelinquishMembershipType),
    /// (sharing) Removed an invitee from the membership of a shared file or folder before it was
    /// claimed.
    SharedContentRemoveInvitees(SharedContentRemoveInviteesType),
    /// (sharing) Removed the expiry of the link for the shared file or folder.
    SharedContentRemoveLinkExpiry(SharedContentRemoveLinkExpiryType),
    /// (sharing) Removed the password on the link for the shared file or folder.
    SharedContentRemoveLinkPassword(SharedContentRemoveLinkPasswordType),
    /// (sharing) Removed a user or a group from the membership of a shared file or folder.
    SharedContentRemoveMember(SharedContentRemoveMemberType),
    /// (sharing) Requested to be on the membership of a shared file or folder.
    SharedContentRequestAccess(SharedContentRequestAccessType),
    /// (sharing) Unshared a shared file or folder by clearing its membership and turning off its
    /// link.
    SharedContentUnshare(SharedContentUnshareType),
    /// (sharing) Previewed the shared file or folder.
    SharedContentView(SharedContentViewType),
    /// (sharing) Changed who can access the shared folder via a link.
    SharedFolderChangeLinkPolicy(SharedFolderChangeLinkPolicyType),
    /// (sharing) Specify if the shared folder inherits its members from the parent folder.
    SharedFolderChangeMembersInheritancePolicy(SharedFolderChangeMembersInheritancePolicyType),
    /// (sharing) Changed who can add or remove members of a shared folder.
    SharedFolderChangeMembersManagementPolicy(SharedFolderChangeMembersManagementPolicyType),
    /// (sharing) Changed who can become a member of the shared folder.
    SharedFolderChangeMembersPolicy(SharedFolderChangeMembersPolicyType),
    /// (sharing) Created a shared folder.
    SharedFolderCreate(SharedFolderCreateType),
    /// (sharing) Declined a team member's invitation to a shared folder.
    SharedFolderDeclineInvitation(SharedFolderDeclineInvitationType),
    /// (sharing) Added a shared folder to own Dropbox.
    SharedFolderMount(SharedFolderMountType),
    /// (sharing) Changed the parent of a shared folder.
    SharedFolderNest(SharedFolderNestType),
    /// (sharing) Transferred the ownership of a shared folder to another member.
    SharedFolderTransferOwnership(SharedFolderTransferOwnershipType),
    /// (sharing) Deleted a shared folder from Dropbox.
    SharedFolderUnmount(SharedFolderUnmountType),
    /// (sharing) Added a shared link expiration date.
    SharedLinkAddExpiry(SharedLinkAddExpiryType),
    /// (sharing) Changed the shared link expiration date.
    SharedLinkChangeExpiry(SharedLinkChangeExpiryType),
    /// (sharing) Changed the visibility of a shared link.
    SharedLinkChangeVisibility(SharedLinkChangeVisibilityType),
    /// (sharing) Added a file/folder to their Dropbox from a shared link.
    SharedLinkCopy(SharedLinkCopyType),
    /// (sharing) Created a new shared link.
    SharedLinkCreate(SharedLinkCreateType),
    /// (sharing) Removed a shared link.
    SharedLinkDisable(SharedLinkDisableType),
    /// (sharing) Downloaded a file/folder from a shared link.
    SharedLinkDownload(SharedLinkDownloadType),
    /// (sharing) Removed a shared link expiration date.
    SharedLinkRemoveExpiry(SharedLinkRemoveExpiryType),
    /// (sharing) Added new members as the audience of a shared link.
    SharedLinkShare(SharedLinkShareType),
    /// (sharing) Opened a shared link.
    SharedLinkView(SharedLinkViewType),
    /// (sharing) Shared Paper document was opened. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    SharedNoteOpened(SharedNoteOpenedType),
    /// (sharing) Shared a link with a group. This event is deprecated and will not be logged going
    /// forward as the associated product functionality no longer exists.
    ShmodelGroupShare(ShmodelGroupShareType),
    /// (sso) Added the X.509 certificate for SSO.
    SsoAddCert(SsoAddCertType),
    /// (sso) Added sign-in URL for SSO.
    SsoAddLoginUrl(SsoAddLoginUrlType),
    /// (sso) Added sign-out URL for SSO.
    SsoAddLogoutUrl(SsoAddLogoutUrlType),
    /// (sso) Changed the X.509 certificate for SSO.
    SsoChangeCert(SsoChangeCertType),
    /// (sso) Changed the sign-in URL for SSO.
    SsoChangeLoginUrl(SsoChangeLoginUrlType),
    /// (sso) Changed the sign-out URL for SSO.
    SsoChangeLogoutUrl(SsoChangeLogoutUrlType),
    /// (sso) Changed the SAML identity mode for SSO.
    SsoChangeSamlIdentityMode(SsoChangeSamlIdentityModeType),
    /// (sso) Removed the X.509 certificate for SSO.
    SsoRemoveCert(SsoRemoveCertType),
    /// (sso) Removed the sign-in URL for SSO.
    SsoRemoveLoginUrl(SsoRemoveLoginUrlType),
    /// (sso) Removed single sign-on logout URL.
    SsoRemoveLogoutUrl(SsoRemoveLogoutUrlType),
    /// (team_folders) Changed the archival status of a team folder.
    TeamFolderChangeStatus(TeamFolderChangeStatusType),
    /// (team_folders) Created a new team folder in active status.
    TeamFolderCreate(TeamFolderCreateType),
    /// (team_folders) Downgraded a team folder to a regular shared folder.
    TeamFolderDowngrade(TeamFolderDowngradeType),
    /// (team_folders) Permanently deleted an archived team folder.
    TeamFolderPermanentlyDelete(TeamFolderPermanentlyDeleteType),
    /// (team_folders) Renamed an active or archived team folder.
    TeamFolderRename(TeamFolderRenameType),
    /// (team_policies) Changed the account capture policy on a domain belonging to the team.
    AccountCaptureChangePolicy(AccountCaptureChangePolicyType),
    /// (team_policies) Disabled allow downloads. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    AllowDownloadDisabled(AllowDownloadDisabledType),
    /// (team_policies) Enabled allow downloads. This event is deprecated and will not be logged
    /// going forward as the associated product functionality no longer exists.
    AllowDownloadEnabled(AllowDownloadEnabledType),
    /// (team_policies) Set a restriction policy regarding the location of data centers where team
    /// data resides.
    DataPlacementRestrictionChangePolicy(DataPlacementRestrictionChangePolicyType),
    /// (team_policies) Satisfied a previously set restriction policy regarding the location of data
    /// centers where team data resides (i.e. all data have been migrated according to the
    /// restriction placed).
    DataPlacementRestrictionSatisfyPolicy(DataPlacementRestrictionSatisfyPolicyType),
    /// (team_policies) Set or removed a limit on the number of computers each team member can link
    /// to their work Dropbox account.
    DeviceApprovalsChangeDesktopPolicy(DeviceApprovalsChangeDesktopPolicyType),
    /// (team_policies) Set or removed a limit on the number of mobiles devices each team member can
    /// link to their work Dropbox account.
    DeviceApprovalsChangeMobilePolicy(DeviceApprovalsChangeMobilePolicyType),
    /// (team_policies) Changed the action taken when a team member is already over the limits (e.g
    /// when they join the team, an admin lowers limits, etc.).
    DeviceApprovalsChangeOverageAction(DeviceApprovalsChangeOverageActionType),
    /// (team_policies) Changed the action taken with respect to approval limits when a team member
    /// unlinks an approved device.
    DeviceApprovalsChangeUnlinkAction(DeviceApprovalsChangeUnlinkActionType),
    /// (team_policies) Added an exception for one or more team members to optionally use the
    /// regular Dropbox app when EMM is enabled.
    EmmAddException(EmmAddExceptionType),
    /// (team_policies) Enabled or disabled enterprise mobility management for team members.
    EmmChangePolicy(EmmChangePolicyType),
    /// (team_policies) Removed an exception for one or more team members to optionally use the
    /// regular Dropbox app when EMM is enabled.
    EmmRemoveException(EmmRemoveExceptionType),
    /// (team_policies) Accepted or opted out of extended version history.
    ExtendedVersionHistoryChangePolicy(ExtendedVersionHistoryChangePolicyType),
    /// (team_policies) Enabled or disabled commenting on team files.
    FileCommentsChangePolicy(FileCommentsChangePolicyType),
    /// (team_policies) Enabled or disabled file requests.
    FileRequestsChangePolicy(FileRequestsChangePolicyType),
    /// (team_policies) Enabled file request emails for everyone. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    FileRequestsEmailsEnabled(FileRequestsEmailsEnabledType),
    /// (team_policies) Allowed file request emails for the team. This event is deprecated and will
    /// not be logged going forward as the associated product functionality no longer exists.
    FileRequestsEmailsRestrictedToTeamOnly(FileRequestsEmailsRestrictedToTeamOnlyType),
    /// (team_policies) Enabled or disabled Google single sign-on for the team.
    GoogleSsoChangePolicy(GoogleSsoChangePolicyType),
    /// (team_policies) Changed who can create groups.
    GroupUserManagementChangePolicy(GroupUserManagementChangePolicyType),
    /// (team_policies) Changed whether users can find the team when not invited.
    MemberRequestsChangePolicy(MemberRequestsChangePolicyType),
    /// (team_policies) Added an exception for one or more team members to bypass space limits
    /// imposed by policy.
    MemberSpaceLimitsAddException(MemberSpaceLimitsAddExceptionType),
    /// (team_policies) Change the member space limit type for the team.
    MemberSpaceLimitsChangeCapsTypePolicy(MemberSpaceLimitsChangeCapsTypePolicyType),
    /// (team_policies) Changed the team default limit level.
    MemberSpaceLimitsChangePolicy(MemberSpaceLimitsChangePolicyType),
    /// (team_policies) Removed an exception for one or more team members to bypass space limits
    /// imposed by policy.
    MemberSpaceLimitsRemoveException(MemberSpaceLimitsRemoveExceptionType),
    /// (team_policies) Enabled or disabled the option for team members to suggest new members to
    /// add to the team.
    MemberSuggestionsChangePolicy(MemberSuggestionsChangePolicyType),
    /// (team_policies) Enabled or disabled the Microsoft Office add-in, which lets team members
    /// save files to Dropbox directly from Microsoft Office.
    MicrosoftOfficeAddinChangePolicy(MicrosoftOfficeAddinChangePolicyType),
    /// (team_policies) Enabled or disabled network control.
    NetworkControlChangePolicy(NetworkControlChangePolicyType),
    /// (team_policies) Changed whether Dropbox Paper, when enabled, is deployed to all teams or to
    /// specific members of the team.
    PaperChangeDeploymentPolicy(PaperChangeDeploymentPolicyType),
    /// (team_policies) Changed whether non team members can view Paper documents using a link. This
    /// event is deprecated and will not be logged going forward as the associated product
    /// functionality no longer exists.
    PaperChangeMemberLinkPolicy(PaperChangeMemberLinkPolicyType),
    /// (team_policies) Changed whether team members can share Paper documents externally (i.e.
    /// outside the team), and if so, whether they should be accessible only by team members or
    /// anyone by default.
    PaperChangeMemberPolicy(PaperChangeMemberPolicyType),
    /// (team_policies) Enabled or disabled Dropbox Paper for the team.
    PaperChangePolicy(PaperChangePolicyType),
    /// (team_policies) Users added to Paper enabled users list.
    PaperEnabledUsersGroupAddition(PaperEnabledUsersGroupAdditionType),
    /// (team_policies) Users removed from Paper enabled users list.
    PaperEnabledUsersGroupRemoval(PaperEnabledUsersGroupRemovalType),
    /// (team_policies) Enabled or disabled the ability of team members to permanently delete
    /// content.
    PermanentDeleteChangePolicy(PermanentDeleteChangePolicyType),
    /// (team_policies) Changed whether team members can join shared folders owned externally (i.e.
    /// outside the team).
    SharingChangeFolderJoinPolicy(SharingChangeFolderJoinPolicyType),
    /// (team_policies) Changed whether team members can share links externally (i.e. outside the
    /// team), and if so, whether links should be accessible only by team members or anyone by
    /// default.
    SharingChangeLinkPolicy(SharingChangeLinkPolicyType),
    /// (team_policies) Changed whether team members can share files and folders externally (i.e.
    /// outside the team).
    SharingChangeMemberPolicy(SharingChangeMemberPolicyType),
    /// (team_policies) Changed the default Smart Sync policy for team members.
    SmartSyncChangePolicy(SmartSyncChangePolicyType),
    /// (team_policies) Opted team into Smart Sync.
    SmartSyncNotOptOut(SmartSyncNotOptOutType),
    /// (team_policies) Opted team out of Smart Sync.
    SmartSyncOptOut(SmartSyncOptOutType),
    /// (team_policies) Change the single sign-on policy for the team.
    SsoChangePolicy(SsoChangePolicyType),
    /// (team_policies) Change two-step verification policy for the team.
    TfaChangePolicy(TfaChangePolicyType),
    /// (team_policies) Enabled or disabled the option for team members to link a personal Dropbox
    /// account in addition to their work account to the same computer.
    TwoAccountChangePolicy(TwoAccountChangePolicyType),
    /// (team_policies) Changed how long team members can stay signed in to Dropbox on the web.
    WebSessionsChangeFixedLengthPolicy(WebSessionsChangeFixedLengthPolicyType),
    /// (team_policies) Changed how long team members can be idle while signed in to Dropbox on the
    /// web.
    WebSessionsChangeIdleLengthPolicy(WebSessionsChangeIdleLengthPolicyType),
    /// (team_profile) Merged another team into this team.
    TeamMergeFrom(TeamMergeFromType),
    /// (team_profile) Merged this team into another team.
    TeamMergeTo(TeamMergeToType),
    /// (team_profile) Added a team logo to be displayed on shared link headers.
    TeamProfileAddLogo(TeamProfileAddLogoType),
    /// (team_profile) Changed the default language for the team.
    TeamProfileChangeDefaultLanguage(TeamProfileChangeDefaultLanguageType),
    /// (team_profile) Changed the team logo to be displayed on shared link headers.
    TeamProfileChangeLogo(TeamProfileChangeLogoType),
    /// (team_profile) Changed the team name.
    TeamProfileChangeName(TeamProfileChangeNameType),
    /// (team_profile) Removed the team logo to be displayed on shared link headers.
    TeamProfileRemoveLogo(TeamProfileRemoveLogoType),
    /// (tfa) Added a backup phone for two-step verification.
    TfaAddBackupPhone(TfaAddBackupPhoneType),
    /// (tfa) Added a security key for two-step verification.
    TfaAddSecurityKey(TfaAddSecurityKeyType),
    /// (tfa) Changed the backup phone for two-step verification.
    TfaChangeBackupPhone(TfaChangeBackupPhoneType),
    /// (tfa) Enabled, disabled or changed the configuration for two-step verification.
    TfaChangeStatus(TfaChangeStatusType),
    /// (tfa) Removed the backup phone for two-step verification.
    TfaRemoveBackupPhone(TfaRemoveBackupPhoneType),
    /// (tfa) Removed a security key for two-step verification.
    TfaRemoveSecurityKey(TfaRemoveSecurityKeyType),
    /// (tfa) Reset two-step verification for team member.
    TfaReset(TfaResetType),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a EventType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_link_team" => Ok(EventType::AppLinkTeam(AppLinkTeamType::internal_deserialize(map)?)),
                    "app_link_user" => Ok(EventType::AppLinkUser(AppLinkUserType::internal_deserialize(map)?)),
                    "app_unlink_team" => Ok(EventType::AppUnlinkTeam(AppUnlinkTeamType::internal_deserialize(map)?)),
                    "app_unlink_user" => Ok(EventType::AppUnlinkUser(AppUnlinkUserType::internal_deserialize(map)?)),
                    "file_add_comment" => Ok(EventType::FileAddComment(FileAddCommentType::internal_deserialize(map)?)),
                    "file_change_comment_subscription" => Ok(EventType::FileChangeCommentSubscription(FileChangeCommentSubscriptionType::internal_deserialize(map)?)),
                    "file_delete_comment" => Ok(EventType::FileDeleteComment(FileDeleteCommentType::internal_deserialize(map)?)),
                    "file_like_comment" => Ok(EventType::FileLikeComment(FileLikeCommentType::internal_deserialize(map)?)),
                    "file_resolve_comment" => Ok(EventType::FileResolveComment(FileResolveCommentType::internal_deserialize(map)?)),
                    "file_unlike_comment" => Ok(EventType::FileUnlikeComment(FileUnlikeCommentType::internal_deserialize(map)?)),
                    "file_unresolve_comment" => Ok(EventType::FileUnresolveComment(FileUnresolveCommentType::internal_deserialize(map)?)),
                    "device_change_ip_desktop" => Ok(EventType::DeviceChangeIpDesktop(DeviceChangeIpDesktopType::internal_deserialize(map)?)),
                    "device_change_ip_mobile" => Ok(EventType::DeviceChangeIpMobile(DeviceChangeIpMobileType::internal_deserialize(map)?)),
                    "device_change_ip_web" => Ok(EventType::DeviceChangeIpWeb(DeviceChangeIpWebType::internal_deserialize(map)?)),
                    "device_delete_on_unlink_fail" => Ok(EventType::DeviceDeleteOnUnlinkFail(DeviceDeleteOnUnlinkFailType::internal_deserialize(map)?)),
                    "device_delete_on_unlink_success" => Ok(EventType::DeviceDeleteOnUnlinkSuccess(DeviceDeleteOnUnlinkSuccessType::internal_deserialize(map)?)),
                    "device_link_fail" => Ok(EventType::DeviceLinkFail(DeviceLinkFailType::internal_deserialize(map)?)),
                    "device_link_success" => Ok(EventType::DeviceLinkSuccess(DeviceLinkSuccessType::internal_deserialize(map)?)),
                    "device_management_disabled" => Ok(EventType::DeviceManagementDisabled(DeviceManagementDisabledType::internal_deserialize(map)?)),
                    "device_management_enabled" => Ok(EventType::DeviceManagementEnabled(DeviceManagementEnabledType::internal_deserialize(map)?)),
                    "device_unlink" => Ok(EventType::DeviceUnlink(DeviceUnlinkType::internal_deserialize(map)?)),
                    "emm_refresh_auth_token" => Ok(EventType::EmmRefreshAuthToken(EmmRefreshAuthTokenType::internal_deserialize(map)?)),
                    "account_capture_change_availability" => Ok(EventType::AccountCaptureChangeAvailability(AccountCaptureChangeAvailabilityType::internal_deserialize(map)?)),
                    "account_capture_migrate_account" => Ok(EventType::AccountCaptureMigrateAccount(AccountCaptureMigrateAccountType::internal_deserialize(map)?)),
                    "account_capture_notification_emails_sent" => Ok(EventType::AccountCaptureNotificationEmailsSent(AccountCaptureNotificationEmailsSentType::internal_deserialize(map)?)),
                    "account_capture_relinquish_account" => Ok(EventType::AccountCaptureRelinquishAccount(AccountCaptureRelinquishAccountType::internal_deserialize(map)?)),
                    "disabled_domain_invites" => Ok(EventType::DisabledDomainInvites(DisabledDomainInvitesType::internal_deserialize(map)?)),
                    "domain_invites_approve_request_to_join_team" => Ok(EventType::DomainInvitesApproveRequestToJoinTeam(DomainInvitesApproveRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_decline_request_to_join_team" => Ok(EventType::DomainInvitesDeclineRequestToJoinTeam(DomainInvitesDeclineRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_email_existing_users" => Ok(EventType::DomainInvitesEmailExistingUsers(DomainInvitesEmailExistingUsersType::internal_deserialize(map)?)),
                    "domain_invites_request_to_join_team" => Ok(EventType::DomainInvitesRequestToJoinTeam(DomainInvitesRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_no" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToNo(DomainInvitesSetInviteNewUserPrefToNoType::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_yes" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToYes(DomainInvitesSetInviteNewUserPrefToYesType::internal_deserialize(map)?)),
                    "domain_verification_add_domain_fail" => Ok(EventType::DomainVerificationAddDomainFail(DomainVerificationAddDomainFailType::internal_deserialize(map)?)),
                    "domain_verification_add_domain_success" => Ok(EventType::DomainVerificationAddDomainSuccess(DomainVerificationAddDomainSuccessType::internal_deserialize(map)?)),
                    "domain_verification_remove_domain" => Ok(EventType::DomainVerificationRemoveDomain(DomainVerificationRemoveDomainType::internal_deserialize(map)?)),
                    "enabled_domain_invites" => Ok(EventType::EnabledDomainInvites(EnabledDomainInvitesType::internal_deserialize(map)?)),
                    "create_folder" => Ok(EventType::CreateFolder(CreateFolderType::internal_deserialize(map)?)),
                    "file_add" => Ok(EventType::FileAdd(FileAddType::internal_deserialize(map)?)),
                    "file_copy" => Ok(EventType::FileCopy(FileCopyType::internal_deserialize(map)?)),
                    "file_delete" => Ok(EventType::FileDelete(FileDeleteType::internal_deserialize(map)?)),
                    "file_download" => Ok(EventType::FileDownload(FileDownloadType::internal_deserialize(map)?)),
                    "file_edit" => Ok(EventType::FileEdit(FileEditType::internal_deserialize(map)?)),
                    "file_get_copy_reference" => Ok(EventType::FileGetCopyReference(FileGetCopyReferenceType::internal_deserialize(map)?)),
                    "file_move" => Ok(EventType::FileMove(FileMoveType::internal_deserialize(map)?)),
                    "file_permanently_delete" => Ok(EventType::FilePermanentlyDelete(FilePermanentlyDeleteType::internal_deserialize(map)?)),
                    "file_preview" => Ok(EventType::FilePreview(FilePreviewType::internal_deserialize(map)?)),
                    "file_rename" => Ok(EventType::FileRename(FileRenameType::internal_deserialize(map)?)),
                    "file_restore" => Ok(EventType::FileRestore(FileRestoreType::internal_deserialize(map)?)),
                    "file_revert" => Ok(EventType::FileRevert(FileRevertType::internal_deserialize(map)?)),
                    "file_rollback_changes" => Ok(EventType::FileRollbackChanges(FileRollbackChangesType::internal_deserialize(map)?)),
                    "file_save_copy_reference" => Ok(EventType::FileSaveCopyReference(FileSaveCopyReferenceType::internal_deserialize(map)?)),
                    "file_request_change" => Ok(EventType::FileRequestChange(FileRequestChangeType::internal_deserialize(map)?)),
                    "file_request_close" => Ok(EventType::FileRequestClose(FileRequestCloseType::internal_deserialize(map)?)),
                    "file_request_create" => Ok(EventType::FileRequestCreate(FileRequestCreateType::internal_deserialize(map)?)),
                    "file_request_receive_file" => Ok(EventType::FileRequestReceiveFile(FileRequestReceiveFileType::internal_deserialize(map)?)),
                    "group_add_external_id" => Ok(EventType::GroupAddExternalId(GroupAddExternalIdType::internal_deserialize(map)?)),
                    "group_add_member" => Ok(EventType::GroupAddMember(GroupAddMemberType::internal_deserialize(map)?)),
                    "group_change_external_id" => Ok(EventType::GroupChangeExternalId(GroupChangeExternalIdType::internal_deserialize(map)?)),
                    "group_change_management_type" => Ok(EventType::GroupChangeManagementType(GroupChangeManagementTypeType::internal_deserialize(map)?)),
                    "group_change_member_role" => Ok(EventType::GroupChangeMemberRole(GroupChangeMemberRoleType::internal_deserialize(map)?)),
                    "group_create" => Ok(EventType::GroupCreate(GroupCreateType::internal_deserialize(map)?)),
                    "group_delete" => Ok(EventType::GroupDelete(GroupDeleteType::internal_deserialize(map)?)),
                    "group_moved" => Ok(EventType::GroupMoved(GroupMovedType::internal_deserialize(map)?)),
                    "group_remove_external_id" => Ok(EventType::GroupRemoveExternalId(GroupRemoveExternalIdType::internal_deserialize(map)?)),
                    "group_remove_member" => Ok(EventType::GroupRemoveMember(GroupRemoveMemberType::internal_deserialize(map)?)),
                    "group_rename" => Ok(EventType::GroupRename(GroupRenameType::internal_deserialize(map)?)),
                    "emm_error" => Ok(EventType::EmmError(EmmErrorType::internal_deserialize(map)?)),
                    "login_fail" => Ok(EventType::LoginFail(LoginFailType::internal_deserialize(map)?)),
                    "login_success" => Ok(EventType::LoginSuccess(LoginSuccessType::internal_deserialize(map)?)),
                    "logout" => Ok(EventType::Logout(LogoutType::internal_deserialize(map)?)),
                    "reseller_support_session_end" => Ok(EventType::ResellerSupportSessionEnd(ResellerSupportSessionEndType::internal_deserialize(map)?)),
                    "reseller_support_session_start" => Ok(EventType::ResellerSupportSessionStart(ResellerSupportSessionStartType::internal_deserialize(map)?)),
                    "sign_in_as_session_end" => Ok(EventType::SignInAsSessionEnd(SignInAsSessionEndType::internal_deserialize(map)?)),
                    "sign_in_as_session_start" => Ok(EventType::SignInAsSessionStart(SignInAsSessionStartType::internal_deserialize(map)?)),
                    "sso_error" => Ok(EventType::SsoError(SsoErrorType::internal_deserialize(map)?)),
                    "member_add_name" => Ok(EventType::MemberAddName(MemberAddNameType::internal_deserialize(map)?)),
                    "member_change_admin_role" => Ok(EventType::MemberChangeAdminRole(MemberChangeAdminRoleType::internal_deserialize(map)?)),
                    "member_change_email" => Ok(EventType::MemberChangeEmail(MemberChangeEmailType::internal_deserialize(map)?)),
                    "member_change_membership_type" => Ok(EventType::MemberChangeMembershipType(MemberChangeMembershipTypeType::internal_deserialize(map)?)),
                    "member_change_name" => Ok(EventType::MemberChangeName(MemberChangeNameType::internal_deserialize(map)?)),
                    "member_change_status" => Ok(EventType::MemberChangeStatus(MemberChangeStatusType::internal_deserialize(map)?)),
                    "member_permanently_delete_account_contents" => Ok(EventType::MemberPermanentlyDeleteAccountContents(MemberPermanentlyDeleteAccountContentsType::internal_deserialize(map)?)),
                    "member_space_limits_add_custom_quota" => Ok(EventType::MemberSpaceLimitsAddCustomQuota(MemberSpaceLimitsAddCustomQuotaType::internal_deserialize(map)?)),
                    "member_space_limits_change_custom_quota" => Ok(EventType::MemberSpaceLimitsChangeCustomQuota(MemberSpaceLimitsChangeCustomQuotaType::internal_deserialize(map)?)),
                    "member_space_limits_change_status" => Ok(EventType::MemberSpaceLimitsChangeStatus(MemberSpaceLimitsChangeStatusType::internal_deserialize(map)?)),
                    "member_space_limits_remove_custom_quota" => Ok(EventType::MemberSpaceLimitsRemoveCustomQuota(MemberSpaceLimitsRemoveCustomQuotaType::internal_deserialize(map)?)),
                    "member_suggest" => Ok(EventType::MemberSuggest(MemberSuggestType::internal_deserialize(map)?)),
                    "member_transfer_account_contents" => Ok(EventType::MemberTransferAccountContents(MemberTransferAccountContentsType::internal_deserialize(map)?)),
                    "paper_content_add_member" => Ok(EventType::PaperContentAddMember(PaperContentAddMemberType::internal_deserialize(map)?)),
                    "paper_content_add_to_folder" => Ok(EventType::PaperContentAddToFolder(PaperContentAddToFolderType::internal_deserialize(map)?)),
                    "paper_content_archive" => Ok(EventType::PaperContentArchive(PaperContentArchiveType::internal_deserialize(map)?)),
                    "paper_content_create" => Ok(EventType::PaperContentCreate(PaperContentCreateType::internal_deserialize(map)?)),
                    "paper_content_permanently_delete" => Ok(EventType::PaperContentPermanentlyDelete(PaperContentPermanentlyDeleteType::internal_deserialize(map)?)),
                    "paper_content_remove_from_folder" => Ok(EventType::PaperContentRemoveFromFolder(PaperContentRemoveFromFolderType::internal_deserialize(map)?)),
                    "paper_content_remove_member" => Ok(EventType::PaperContentRemoveMember(PaperContentRemoveMemberType::internal_deserialize(map)?)),
                    "paper_content_rename" => Ok(EventType::PaperContentRename(PaperContentRenameType::internal_deserialize(map)?)),
                    "paper_content_restore" => Ok(EventType::PaperContentRestore(PaperContentRestoreType::internal_deserialize(map)?)),
                    "paper_doc_add_comment" => Ok(EventType::PaperDocAddComment(PaperDocAddCommentType::internal_deserialize(map)?)),
                    "paper_doc_change_member_role" => Ok(EventType::PaperDocChangeMemberRole(PaperDocChangeMemberRoleType::internal_deserialize(map)?)),
                    "paper_doc_change_sharing_policy" => Ok(EventType::PaperDocChangeSharingPolicy(PaperDocChangeSharingPolicyType::internal_deserialize(map)?)),
                    "paper_doc_change_subscription" => Ok(EventType::PaperDocChangeSubscription(PaperDocChangeSubscriptionType::internal_deserialize(map)?)),
                    "paper_doc_deleted" => Ok(EventType::PaperDocDeleted(PaperDocDeletedType::internal_deserialize(map)?)),
                    "paper_doc_delete_comment" => Ok(EventType::PaperDocDeleteComment(PaperDocDeleteCommentType::internal_deserialize(map)?)),
                    "paper_doc_download" => Ok(EventType::PaperDocDownload(PaperDocDownloadType::internal_deserialize(map)?)),
                    "paper_doc_edit" => Ok(EventType::PaperDocEdit(PaperDocEditType::internal_deserialize(map)?)),
                    "paper_doc_edit_comment" => Ok(EventType::PaperDocEditComment(PaperDocEditCommentType::internal_deserialize(map)?)),
                    "paper_doc_followed" => Ok(EventType::PaperDocFollowed(PaperDocFollowedType::internal_deserialize(map)?)),
                    "paper_doc_mention" => Ok(EventType::PaperDocMention(PaperDocMentionType::internal_deserialize(map)?)),
                    "paper_doc_request_access" => Ok(EventType::PaperDocRequestAccess(PaperDocRequestAccessType::internal_deserialize(map)?)),
                    "paper_doc_resolve_comment" => Ok(EventType::PaperDocResolveComment(PaperDocResolveCommentType::internal_deserialize(map)?)),
                    "paper_doc_revert" => Ok(EventType::PaperDocRevert(PaperDocRevertType::internal_deserialize(map)?)),
                    "paper_doc_slack_share" => Ok(EventType::PaperDocSlackShare(PaperDocSlackShareType::internal_deserialize(map)?)),
                    "paper_doc_team_invite" => Ok(EventType::PaperDocTeamInvite(PaperDocTeamInviteType::internal_deserialize(map)?)),
                    "paper_doc_trashed" => Ok(EventType::PaperDocTrashed(PaperDocTrashedType::internal_deserialize(map)?)),
                    "paper_doc_unresolve_comment" => Ok(EventType::PaperDocUnresolveComment(PaperDocUnresolveCommentType::internal_deserialize(map)?)),
                    "paper_doc_untrashed" => Ok(EventType::PaperDocUntrashed(PaperDocUntrashedType::internal_deserialize(map)?)),
                    "paper_doc_view" => Ok(EventType::PaperDocView(PaperDocViewType::internal_deserialize(map)?)),
                    "paper_external_view_allow" => Ok(EventType::PaperExternalViewAllow(PaperExternalViewAllowType::internal_deserialize(map)?)),
                    "paper_external_view_default_team" => Ok(EventType::PaperExternalViewDefaultTeam(PaperExternalViewDefaultTeamType::internal_deserialize(map)?)),
                    "paper_external_view_forbid" => Ok(EventType::PaperExternalViewForbid(PaperExternalViewForbidType::internal_deserialize(map)?)),
                    "paper_folder_change_subscription" => Ok(EventType::PaperFolderChangeSubscription(PaperFolderChangeSubscriptionType::internal_deserialize(map)?)),
                    "paper_folder_deleted" => Ok(EventType::PaperFolderDeleted(PaperFolderDeletedType::internal_deserialize(map)?)),
                    "paper_folder_followed" => Ok(EventType::PaperFolderFollowed(PaperFolderFollowedType::internal_deserialize(map)?)),
                    "paper_folder_team_invite" => Ok(EventType::PaperFolderTeamInvite(PaperFolderTeamInviteType::internal_deserialize(map)?)),
                    "password_change" => Ok(EventType::PasswordChange(PasswordChangeType::internal_deserialize(map)?)),
                    "password_reset" => Ok(EventType::PasswordReset(PasswordResetType::internal_deserialize(map)?)),
                    "password_reset_all" => Ok(EventType::PasswordResetAll(PasswordResetAllType::internal_deserialize(map)?)),
                    "emm_create_exceptions_report" => Ok(EventType::EmmCreateExceptionsReport(EmmCreateExceptionsReportType::internal_deserialize(map)?)),
                    "emm_create_usage_report" => Ok(EventType::EmmCreateUsageReport(EmmCreateUsageReportType::internal_deserialize(map)?)),
                    "export_members_report" => Ok(EventType::ExportMembersReport(ExportMembersReportType::internal_deserialize(map)?)),
                    "paper_admin_export_start" => Ok(EventType::PaperAdminExportStart(PaperAdminExportStartType::internal_deserialize(map)?)),
                    "smart_sync_create_admin_privilege_report" => Ok(EventType::SmartSyncCreateAdminPrivilegeReport(SmartSyncCreateAdminPrivilegeReportType::internal_deserialize(map)?)),
                    "team_activity_create_report" => Ok(EventType::TeamActivityCreateReport(TeamActivityCreateReportType::internal_deserialize(map)?)),
                    "collection_share" => Ok(EventType::CollectionShare(CollectionShareType::internal_deserialize(map)?)),
                    "note_acl_invite_only" => Ok(EventType::NoteAclInviteOnly(NoteAclInviteOnlyType::internal_deserialize(map)?)),
                    "note_acl_link" => Ok(EventType::NoteAclLink(NoteAclLinkType::internal_deserialize(map)?)),
                    "note_acl_team_link" => Ok(EventType::NoteAclTeamLink(NoteAclTeamLinkType::internal_deserialize(map)?)),
                    "note_shared" => Ok(EventType::NoteShared(NoteSharedType::internal_deserialize(map)?)),
                    "note_share_receive" => Ok(EventType::NoteShareReceive(NoteShareReceiveType::internal_deserialize(map)?)),
                    "open_note_shared" => Ok(EventType::OpenNoteShared(OpenNoteSharedType::internal_deserialize(map)?)),
                    "sf_add_group" => Ok(EventType::SfAddGroup(SfAddGroupType::internal_deserialize(map)?)),
                    "sf_allow_non_members_to_view_shared_links" => Ok(EventType::SfAllowNonMembersToViewSharedLinks(SfAllowNonMembersToViewSharedLinksType::internal_deserialize(map)?)),
                    "sf_external_invite_warn" => Ok(EventType::SfExternalInviteWarn(SfExternalInviteWarnType::internal_deserialize(map)?)),
                    "sf_fb_invite" => Ok(EventType::SfFbInvite(SfFbInviteType::internal_deserialize(map)?)),
                    "sf_fb_invite_change_role" => Ok(EventType::SfFbInviteChangeRole(SfFbInviteChangeRoleType::internal_deserialize(map)?)),
                    "sf_fb_uninvite" => Ok(EventType::SfFbUninvite(SfFbUninviteType::internal_deserialize(map)?)),
                    "sf_invite_group" => Ok(EventType::SfInviteGroup(SfInviteGroupType::internal_deserialize(map)?)),
                    "sf_team_grant_access" => Ok(EventType::SfTeamGrantAccess(SfTeamGrantAccessType::internal_deserialize(map)?)),
                    "sf_team_invite" => Ok(EventType::SfTeamInvite(SfTeamInviteType::internal_deserialize(map)?)),
                    "sf_team_invite_change_role" => Ok(EventType::SfTeamInviteChangeRole(SfTeamInviteChangeRoleType::internal_deserialize(map)?)),
                    "sf_team_join" => Ok(EventType::SfTeamJoin(SfTeamJoinType::internal_deserialize(map)?)),
                    "sf_team_join_from_oob_link" => Ok(EventType::SfTeamJoinFromOobLink(SfTeamJoinFromOobLinkType::internal_deserialize(map)?)),
                    "sf_team_uninvite" => Ok(EventType::SfTeamUninvite(SfTeamUninviteType::internal_deserialize(map)?)),
                    "shared_content_add_invitees" => Ok(EventType::SharedContentAddInvitees(SharedContentAddInviteesType::internal_deserialize(map)?)),
                    "shared_content_add_link_expiry" => Ok(EventType::SharedContentAddLinkExpiry(SharedContentAddLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_add_link_password" => Ok(EventType::SharedContentAddLinkPassword(SharedContentAddLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_add_member" => Ok(EventType::SharedContentAddMember(SharedContentAddMemberType::internal_deserialize(map)?)),
                    "shared_content_change_downloads_policy" => Ok(EventType::SharedContentChangeDownloadsPolicy(SharedContentChangeDownloadsPolicyType::internal_deserialize(map)?)),
                    "shared_content_change_invitee_role" => Ok(EventType::SharedContentChangeInviteeRole(SharedContentChangeInviteeRoleType::internal_deserialize(map)?)),
                    "shared_content_change_link_audience" => Ok(EventType::SharedContentChangeLinkAudience(SharedContentChangeLinkAudienceType::internal_deserialize(map)?)),
                    "shared_content_change_link_expiry" => Ok(EventType::SharedContentChangeLinkExpiry(SharedContentChangeLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_change_link_password" => Ok(EventType::SharedContentChangeLinkPassword(SharedContentChangeLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_change_member_role" => Ok(EventType::SharedContentChangeMemberRole(SharedContentChangeMemberRoleType::internal_deserialize(map)?)),
                    "shared_content_change_viewer_info_policy" => Ok(EventType::SharedContentChangeViewerInfoPolicy(SharedContentChangeViewerInfoPolicyType::internal_deserialize(map)?)),
                    "shared_content_claim_invitation" => Ok(EventType::SharedContentClaimInvitation(SharedContentClaimInvitationType::internal_deserialize(map)?)),
                    "shared_content_copy" => Ok(EventType::SharedContentCopy(SharedContentCopyType::internal_deserialize(map)?)),
                    "shared_content_download" => Ok(EventType::SharedContentDownload(SharedContentDownloadType::internal_deserialize(map)?)),
                    "shared_content_relinquish_membership" => Ok(EventType::SharedContentRelinquishMembership(SharedContentRelinquishMembershipType::internal_deserialize(map)?)),
                    "shared_content_remove_invitees" => Ok(EventType::SharedContentRemoveInvitees(SharedContentRemoveInviteesType::internal_deserialize(map)?)),
                    "shared_content_remove_link_expiry" => Ok(EventType::SharedContentRemoveLinkExpiry(SharedContentRemoveLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_remove_link_password" => Ok(EventType::SharedContentRemoveLinkPassword(SharedContentRemoveLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_remove_member" => Ok(EventType::SharedContentRemoveMember(SharedContentRemoveMemberType::internal_deserialize(map)?)),
                    "shared_content_request_access" => Ok(EventType::SharedContentRequestAccess(SharedContentRequestAccessType::internal_deserialize(map)?)),
                    "shared_content_unshare" => Ok(EventType::SharedContentUnshare(SharedContentUnshareType::internal_deserialize(map)?)),
                    "shared_content_view" => Ok(EventType::SharedContentView(SharedContentViewType::internal_deserialize(map)?)),
                    "shared_folder_change_link_policy" => Ok(EventType::SharedFolderChangeLinkPolicy(SharedFolderChangeLinkPolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_inheritance_policy" => Ok(EventType::SharedFolderChangeMembersInheritancePolicy(SharedFolderChangeMembersInheritancePolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_management_policy" => Ok(EventType::SharedFolderChangeMembersManagementPolicy(SharedFolderChangeMembersManagementPolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_policy" => Ok(EventType::SharedFolderChangeMembersPolicy(SharedFolderChangeMembersPolicyType::internal_deserialize(map)?)),
                    "shared_folder_create" => Ok(EventType::SharedFolderCreate(SharedFolderCreateType::internal_deserialize(map)?)),
                    "shared_folder_decline_invitation" => Ok(EventType::SharedFolderDeclineInvitation(SharedFolderDeclineInvitationType::internal_deserialize(map)?)),
                    "shared_folder_mount" => Ok(EventType::SharedFolderMount(SharedFolderMountType::internal_deserialize(map)?)),
                    "shared_folder_nest" => Ok(EventType::SharedFolderNest(SharedFolderNestType::internal_deserialize(map)?)),
                    "shared_folder_transfer_ownership" => Ok(EventType::SharedFolderTransferOwnership(SharedFolderTransferOwnershipType::internal_deserialize(map)?)),
                    "shared_folder_unmount" => Ok(EventType::SharedFolderUnmount(SharedFolderUnmountType::internal_deserialize(map)?)),
                    "shared_link_add_expiry" => Ok(EventType::SharedLinkAddExpiry(SharedLinkAddExpiryType::internal_deserialize(map)?)),
                    "shared_link_change_expiry" => Ok(EventType::SharedLinkChangeExpiry(SharedLinkChangeExpiryType::internal_deserialize(map)?)),
                    "shared_link_change_visibility" => Ok(EventType::SharedLinkChangeVisibility(SharedLinkChangeVisibilityType::internal_deserialize(map)?)),
                    "shared_link_copy" => Ok(EventType::SharedLinkCopy(SharedLinkCopyType::internal_deserialize(map)?)),
                    "shared_link_create" => Ok(EventType::SharedLinkCreate(SharedLinkCreateType::internal_deserialize(map)?)),
                    "shared_link_disable" => Ok(EventType::SharedLinkDisable(SharedLinkDisableType::internal_deserialize(map)?)),
                    "shared_link_download" => Ok(EventType::SharedLinkDownload(SharedLinkDownloadType::internal_deserialize(map)?)),
                    "shared_link_remove_expiry" => Ok(EventType::SharedLinkRemoveExpiry(SharedLinkRemoveExpiryType::internal_deserialize(map)?)),
                    "shared_link_share" => Ok(EventType::SharedLinkShare(SharedLinkShareType::internal_deserialize(map)?)),
                    "shared_link_view" => Ok(EventType::SharedLinkView(SharedLinkViewType::internal_deserialize(map)?)),
                    "shared_note_opened" => Ok(EventType::SharedNoteOpened(SharedNoteOpenedType::internal_deserialize(map)?)),
                    "shmodel_group_share" => Ok(EventType::ShmodelGroupShare(ShmodelGroupShareType::internal_deserialize(map)?)),
                    "sso_add_cert" => Ok(EventType::SsoAddCert(SsoAddCertType::internal_deserialize(map)?)),
                    "sso_add_login_url" => Ok(EventType::SsoAddLoginUrl(SsoAddLoginUrlType::internal_deserialize(map)?)),
                    "sso_add_logout_url" => Ok(EventType::SsoAddLogoutUrl(SsoAddLogoutUrlType::internal_deserialize(map)?)),
                    "sso_change_cert" => Ok(EventType::SsoChangeCert(SsoChangeCertType::internal_deserialize(map)?)),
                    "sso_change_login_url" => Ok(EventType::SsoChangeLoginUrl(SsoChangeLoginUrlType::internal_deserialize(map)?)),
                    "sso_change_logout_url" => Ok(EventType::SsoChangeLogoutUrl(SsoChangeLogoutUrlType::internal_deserialize(map)?)),
                    "sso_change_saml_identity_mode" => Ok(EventType::SsoChangeSamlIdentityMode(SsoChangeSamlIdentityModeType::internal_deserialize(map)?)),
                    "sso_remove_cert" => Ok(EventType::SsoRemoveCert(SsoRemoveCertType::internal_deserialize(map)?)),
                    "sso_remove_login_url" => Ok(EventType::SsoRemoveLoginUrl(SsoRemoveLoginUrlType::internal_deserialize(map)?)),
                    "sso_remove_logout_url" => Ok(EventType::SsoRemoveLogoutUrl(SsoRemoveLogoutUrlType::internal_deserialize(map)?)),
                    "team_folder_change_status" => Ok(EventType::TeamFolderChangeStatus(TeamFolderChangeStatusType::internal_deserialize(map)?)),
                    "team_folder_create" => Ok(EventType::TeamFolderCreate(TeamFolderCreateType::internal_deserialize(map)?)),
                    "team_folder_downgrade" => Ok(EventType::TeamFolderDowngrade(TeamFolderDowngradeType::internal_deserialize(map)?)),
                    "team_folder_permanently_delete" => Ok(EventType::TeamFolderPermanentlyDelete(TeamFolderPermanentlyDeleteType::internal_deserialize(map)?)),
                    "team_folder_rename" => Ok(EventType::TeamFolderRename(TeamFolderRenameType::internal_deserialize(map)?)),
                    "account_capture_change_policy" => Ok(EventType::AccountCaptureChangePolicy(AccountCaptureChangePolicyType::internal_deserialize(map)?)),
                    "allow_download_disabled" => Ok(EventType::AllowDownloadDisabled(AllowDownloadDisabledType::internal_deserialize(map)?)),
                    "allow_download_enabled" => Ok(EventType::AllowDownloadEnabled(AllowDownloadEnabledType::internal_deserialize(map)?)),
                    "data_placement_restriction_change_policy" => Ok(EventType::DataPlacementRestrictionChangePolicy(DataPlacementRestrictionChangePolicyType::internal_deserialize(map)?)),
                    "data_placement_restriction_satisfy_policy" => Ok(EventType::DataPlacementRestrictionSatisfyPolicy(DataPlacementRestrictionSatisfyPolicyType::internal_deserialize(map)?)),
                    "device_approvals_change_desktop_policy" => Ok(EventType::DeviceApprovalsChangeDesktopPolicy(DeviceApprovalsChangeDesktopPolicyType::internal_deserialize(map)?)),
                    "device_approvals_change_mobile_policy" => Ok(EventType::DeviceApprovalsChangeMobilePolicy(DeviceApprovalsChangeMobilePolicyType::internal_deserialize(map)?)),
                    "device_approvals_change_overage_action" => Ok(EventType::DeviceApprovalsChangeOverageAction(DeviceApprovalsChangeOverageActionType::internal_deserialize(map)?)),
                    "device_approvals_change_unlink_action" => Ok(EventType::DeviceApprovalsChangeUnlinkAction(DeviceApprovalsChangeUnlinkActionType::internal_deserialize(map)?)),
                    "emm_add_exception" => Ok(EventType::EmmAddException(EmmAddExceptionType::internal_deserialize(map)?)),
                    "emm_change_policy" => Ok(EventType::EmmChangePolicy(EmmChangePolicyType::internal_deserialize(map)?)),
                    "emm_remove_exception" => Ok(EventType::EmmRemoveException(EmmRemoveExceptionType::internal_deserialize(map)?)),
                    "extended_version_history_change_policy" => Ok(EventType::ExtendedVersionHistoryChangePolicy(ExtendedVersionHistoryChangePolicyType::internal_deserialize(map)?)),
                    "file_comments_change_policy" => Ok(EventType::FileCommentsChangePolicy(FileCommentsChangePolicyType::internal_deserialize(map)?)),
                    "file_requests_change_policy" => Ok(EventType::FileRequestsChangePolicy(FileRequestsChangePolicyType::internal_deserialize(map)?)),
                    "file_requests_emails_enabled" => Ok(EventType::FileRequestsEmailsEnabled(FileRequestsEmailsEnabledType::internal_deserialize(map)?)),
                    "file_requests_emails_restricted_to_team_only" => Ok(EventType::FileRequestsEmailsRestrictedToTeamOnly(FileRequestsEmailsRestrictedToTeamOnlyType::internal_deserialize(map)?)),
                    "google_sso_change_policy" => Ok(EventType::GoogleSsoChangePolicy(GoogleSsoChangePolicyType::internal_deserialize(map)?)),
                    "group_user_management_change_policy" => Ok(EventType::GroupUserManagementChangePolicy(GroupUserManagementChangePolicyType::internal_deserialize(map)?)),
                    "member_requests_change_policy" => Ok(EventType::MemberRequestsChangePolicy(MemberRequestsChangePolicyType::internal_deserialize(map)?)),
                    "member_space_limits_add_exception" => Ok(EventType::MemberSpaceLimitsAddException(MemberSpaceLimitsAddExceptionType::internal_deserialize(map)?)),
                    "member_space_limits_change_caps_type_policy" => Ok(EventType::MemberSpaceLimitsChangeCapsTypePolicy(MemberSpaceLimitsChangeCapsTypePolicyType::internal_deserialize(map)?)),
                    "member_space_limits_change_policy" => Ok(EventType::MemberSpaceLimitsChangePolicy(MemberSpaceLimitsChangePolicyType::internal_deserialize(map)?)),
                    "member_space_limits_remove_exception" => Ok(EventType::MemberSpaceLimitsRemoveException(MemberSpaceLimitsRemoveExceptionType::internal_deserialize(map)?)),
                    "member_suggestions_change_policy" => Ok(EventType::MemberSuggestionsChangePolicy(MemberSuggestionsChangePolicyType::internal_deserialize(map)?)),
                    "microsoft_office_addin_change_policy" => Ok(EventType::MicrosoftOfficeAddinChangePolicy(MicrosoftOfficeAddinChangePolicyType::internal_deserialize(map)?)),
                    "network_control_change_policy" => Ok(EventType::NetworkControlChangePolicy(NetworkControlChangePolicyType::internal_deserialize(map)?)),
                    "paper_change_deployment_policy" => Ok(EventType::PaperChangeDeploymentPolicy(PaperChangeDeploymentPolicyType::internal_deserialize(map)?)),
                    "paper_change_member_link_policy" => Ok(EventType::PaperChangeMemberLinkPolicy(PaperChangeMemberLinkPolicyType::internal_deserialize(map)?)),
                    "paper_change_member_policy" => Ok(EventType::PaperChangeMemberPolicy(PaperChangeMemberPolicyType::internal_deserialize(map)?)),
                    "paper_change_policy" => Ok(EventType::PaperChangePolicy(PaperChangePolicyType::internal_deserialize(map)?)),
                    "paper_enabled_users_group_addition" => Ok(EventType::PaperEnabledUsersGroupAddition(PaperEnabledUsersGroupAdditionType::internal_deserialize(map)?)),
                    "paper_enabled_users_group_removal" => Ok(EventType::PaperEnabledUsersGroupRemoval(PaperEnabledUsersGroupRemovalType::internal_deserialize(map)?)),
                    "permanent_delete_change_policy" => Ok(EventType::PermanentDeleteChangePolicy(PermanentDeleteChangePolicyType::internal_deserialize(map)?)),
                    "sharing_change_folder_join_policy" => Ok(EventType::SharingChangeFolderJoinPolicy(SharingChangeFolderJoinPolicyType::internal_deserialize(map)?)),
                    "sharing_change_link_policy" => Ok(EventType::SharingChangeLinkPolicy(SharingChangeLinkPolicyType::internal_deserialize(map)?)),
                    "sharing_change_member_policy" => Ok(EventType::SharingChangeMemberPolicy(SharingChangeMemberPolicyType::internal_deserialize(map)?)),
                    "smart_sync_change_policy" => Ok(EventType::SmartSyncChangePolicy(SmartSyncChangePolicyType::internal_deserialize(map)?)),
                    "smart_sync_not_opt_out" => Ok(EventType::SmartSyncNotOptOut(SmartSyncNotOptOutType::internal_deserialize(map)?)),
                    "smart_sync_opt_out" => Ok(EventType::SmartSyncOptOut(SmartSyncOptOutType::internal_deserialize(map)?)),
                    "sso_change_policy" => Ok(EventType::SsoChangePolicy(SsoChangePolicyType::internal_deserialize(map)?)),
                    "tfa_change_policy" => Ok(EventType::TfaChangePolicy(TfaChangePolicyType::internal_deserialize(map)?)),
                    "two_account_change_policy" => Ok(EventType::TwoAccountChangePolicy(TwoAccountChangePolicyType::internal_deserialize(map)?)),
                    "web_sessions_change_fixed_length_policy" => Ok(EventType::WebSessionsChangeFixedLengthPolicy(WebSessionsChangeFixedLengthPolicyType::internal_deserialize(map)?)),
                    "web_sessions_change_idle_length_policy" => Ok(EventType::WebSessionsChangeIdleLengthPolicy(WebSessionsChangeIdleLengthPolicyType::internal_deserialize(map)?)),
                    "team_merge_from" => Ok(EventType::TeamMergeFrom(TeamMergeFromType::internal_deserialize(map)?)),
                    "team_merge_to" => Ok(EventType::TeamMergeTo(TeamMergeToType::internal_deserialize(map)?)),
                    "team_profile_add_logo" => Ok(EventType::TeamProfileAddLogo(TeamProfileAddLogoType::internal_deserialize(map)?)),
                    "team_profile_change_default_language" => Ok(EventType::TeamProfileChangeDefaultLanguage(TeamProfileChangeDefaultLanguageType::internal_deserialize(map)?)),
                    "team_profile_change_logo" => Ok(EventType::TeamProfileChangeLogo(TeamProfileChangeLogoType::internal_deserialize(map)?)),
                    "team_profile_change_name" => Ok(EventType::TeamProfileChangeName(TeamProfileChangeNameType::internal_deserialize(map)?)),
                    "team_profile_remove_logo" => Ok(EventType::TeamProfileRemoveLogo(TeamProfileRemoveLogoType::internal_deserialize(map)?)),
                    "tfa_add_backup_phone" => Ok(EventType::TfaAddBackupPhone(TfaAddBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_add_security_key" => Ok(EventType::TfaAddSecurityKey(TfaAddSecurityKeyType::internal_deserialize(map)?)),
                    "tfa_change_backup_phone" => Ok(EventType::TfaChangeBackupPhone(TfaChangeBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_change_status" => Ok(EventType::TfaChangeStatus(TfaChangeStatusType::internal_deserialize(map)?)),
                    "tfa_remove_backup_phone" => Ok(EventType::TfaRemoveBackupPhone(TfaRemoveBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_remove_security_key" => Ok(EventType::TfaRemoveSecurityKey(TfaRemoveSecurityKeyType::internal_deserialize(map)?)),
                    "tfa_reset" => Ok(EventType::TfaReset(TfaResetType::internal_deserialize(map)?)),
                    _ => Ok(EventType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["app_link_team",
                                    "app_link_user",
                                    "app_unlink_team",
                                    "app_unlink_user",
                                    "file_add_comment",
                                    "file_change_comment_subscription",
                                    "file_delete_comment",
                                    "file_like_comment",
                                    "file_resolve_comment",
                                    "file_unlike_comment",
                                    "file_unresolve_comment",
                                    "device_change_ip_desktop",
                                    "device_change_ip_mobile",
                                    "device_change_ip_web",
                                    "device_delete_on_unlink_fail",
                                    "device_delete_on_unlink_success",
                                    "device_link_fail",
                                    "device_link_success",
                                    "device_management_disabled",
                                    "device_management_enabled",
                                    "device_unlink",
                                    "emm_refresh_auth_token",
                                    "account_capture_change_availability",
                                    "account_capture_migrate_account",
                                    "account_capture_notification_emails_sent",
                                    "account_capture_relinquish_account",
                                    "disabled_domain_invites",
                                    "domain_invites_approve_request_to_join_team",
                                    "domain_invites_decline_request_to_join_team",
                                    "domain_invites_email_existing_users",
                                    "domain_invites_request_to_join_team",
                                    "domain_invites_set_invite_new_user_pref_to_no",
                                    "domain_invites_set_invite_new_user_pref_to_yes",
                                    "domain_verification_add_domain_fail",
                                    "domain_verification_add_domain_success",
                                    "domain_verification_remove_domain",
                                    "enabled_domain_invites",
                                    "create_folder",
                                    "file_add",
                                    "file_copy",
                                    "file_delete",
                                    "file_download",
                                    "file_edit",
                                    "file_get_copy_reference",
                                    "file_move",
                                    "file_permanently_delete",
                                    "file_preview",
                                    "file_rename",
                                    "file_restore",
                                    "file_revert",
                                    "file_rollback_changes",
                                    "file_save_copy_reference",
                                    "file_request_change",
                                    "file_request_close",
                                    "file_request_create",
                                    "file_request_receive_file",
                                    "group_add_external_id",
                                    "group_add_member",
                                    "group_change_external_id",
                                    "group_change_management_type",
                                    "group_change_member_role",
                                    "group_create",
                                    "group_delete",
                                    "group_moved",
                                    "group_remove_external_id",
                                    "group_remove_member",
                                    "group_rename",
                                    "emm_error",
                                    "login_fail",
                                    "login_success",
                                    "logout",
                                    "reseller_support_session_end",
                                    "reseller_support_session_start",
                                    "sign_in_as_session_end",
                                    "sign_in_as_session_start",
                                    "sso_error",
                                    "member_add_name",
                                    "member_change_admin_role",
                                    "member_change_email",
                                    "member_change_membership_type",
                                    "member_change_name",
                                    "member_change_status",
                                    "member_permanently_delete_account_contents",
                                    "member_space_limits_add_custom_quota",
                                    "member_space_limits_change_custom_quota",
                                    "member_space_limits_change_status",
                                    "member_space_limits_remove_custom_quota",
                                    "member_suggest",
                                    "member_transfer_account_contents",
                                    "paper_content_add_member",
                                    "paper_content_add_to_folder",
                                    "paper_content_archive",
                                    "paper_content_create",
                                    "paper_content_permanently_delete",
                                    "paper_content_remove_from_folder",
                                    "paper_content_remove_member",
                                    "paper_content_rename",
                                    "paper_content_restore",
                                    "paper_doc_add_comment",
                                    "paper_doc_change_member_role",
                                    "paper_doc_change_sharing_policy",
                                    "paper_doc_change_subscription",
                                    "paper_doc_deleted",
                                    "paper_doc_delete_comment",
                                    "paper_doc_download",
                                    "paper_doc_edit",
                                    "paper_doc_edit_comment",
                                    "paper_doc_followed",
                                    "paper_doc_mention",
                                    "paper_doc_request_access",
                                    "paper_doc_resolve_comment",
                                    "paper_doc_revert",
                                    "paper_doc_slack_share",
                                    "paper_doc_team_invite",
                                    "paper_doc_trashed",
                                    "paper_doc_unresolve_comment",
                                    "paper_doc_untrashed",
                                    "paper_doc_view",
                                    "paper_external_view_allow",
                                    "paper_external_view_default_team",
                                    "paper_external_view_forbid",
                                    "paper_folder_change_subscription",
                                    "paper_folder_deleted",
                                    "paper_folder_followed",
                                    "paper_folder_team_invite",
                                    "password_change",
                                    "password_reset",
                                    "password_reset_all",
                                    "emm_create_exceptions_report",
                                    "emm_create_usage_report",
                                    "export_members_report",
                                    "paper_admin_export_start",
                                    "smart_sync_create_admin_privilege_report",
                                    "team_activity_create_report",
                                    "collection_share",
                                    "note_acl_invite_only",
                                    "note_acl_link",
                                    "note_acl_team_link",
                                    "note_shared",
                                    "note_share_receive",
                                    "open_note_shared",
                                    "sf_add_group",
                                    "sf_allow_non_members_to_view_shared_links",
                                    "sf_external_invite_warn",
                                    "sf_fb_invite",
                                    "sf_fb_invite_change_role",
                                    "sf_fb_uninvite",
                                    "sf_invite_group",
                                    "sf_team_grant_access",
                                    "sf_team_invite",
                                    "sf_team_invite_change_role",
                                    "sf_team_join",
                                    "sf_team_join_from_oob_link",
                                    "sf_team_uninvite",
                                    "shared_content_add_invitees",
                                    "shared_content_add_link_expiry",
                                    "shared_content_add_link_password",
                                    "shared_content_add_member",
                                    "shared_content_change_downloads_policy",
                                    "shared_content_change_invitee_role",
                                    "shared_content_change_link_audience",
                                    "shared_content_change_link_expiry",
                                    "shared_content_change_link_password",
                                    "shared_content_change_member_role",
                                    "shared_content_change_viewer_info_policy",
                                    "shared_content_claim_invitation",
                                    "shared_content_copy",
                                    "shared_content_download",
                                    "shared_content_relinquish_membership",
                                    "shared_content_remove_invitees",
                                    "shared_content_remove_link_expiry",
                                    "shared_content_remove_link_password",
                                    "shared_content_remove_member",
                                    "shared_content_request_access",
                                    "shared_content_unshare",
                                    "shared_content_view",
                                    "shared_folder_change_link_policy",
                                    "shared_folder_change_members_inheritance_policy",
                                    "shared_folder_change_members_management_policy",
                                    "shared_folder_change_members_policy",
                                    "shared_folder_create",
                                    "shared_folder_decline_invitation",
                                    "shared_folder_mount",
                                    "shared_folder_nest",
                                    "shared_folder_transfer_ownership",
                                    "shared_folder_unmount",
                                    "shared_link_add_expiry",
                                    "shared_link_change_expiry",
                                    "shared_link_change_visibility",
                                    "shared_link_copy",
                                    "shared_link_create",
                                    "shared_link_disable",
                                    "shared_link_download",
                                    "shared_link_remove_expiry",
                                    "shared_link_share",
                                    "shared_link_view",
                                    "shared_note_opened",
                                    "shmodel_group_share",
                                    "sso_add_cert",
                                    "sso_add_login_url",
                                    "sso_add_logout_url",
                                    "sso_change_cert",
                                    "sso_change_login_url",
                                    "sso_change_logout_url",
                                    "sso_change_saml_identity_mode",
                                    "sso_remove_cert",
                                    "sso_remove_login_url",
                                    "sso_remove_logout_url",
                                    "team_folder_change_status",
                                    "team_folder_create",
                                    "team_folder_downgrade",
                                    "team_folder_permanently_delete",
                                    "team_folder_rename",
                                    "account_capture_change_policy",
                                    "allow_download_disabled",
                                    "allow_download_enabled",
                                    "data_placement_restriction_change_policy",
                                    "data_placement_restriction_satisfy_policy",
                                    "device_approvals_change_desktop_policy",
                                    "device_approvals_change_mobile_policy",
                                    "device_approvals_change_overage_action",
                                    "device_approvals_change_unlink_action",
                                    "emm_add_exception",
                                    "emm_change_policy",
                                    "emm_remove_exception",
                                    "extended_version_history_change_policy",
                                    "file_comments_change_policy",
                                    "file_requests_change_policy",
                                    "file_requests_emails_enabled",
                                    "file_requests_emails_restricted_to_team_only",
                                    "google_sso_change_policy",
                                    "group_user_management_change_policy",
                                    "member_requests_change_policy",
                                    "member_space_limits_add_exception",
                                    "member_space_limits_change_caps_type_policy",
                                    "member_space_limits_change_policy",
                                    "member_space_limits_remove_exception",
                                    "member_suggestions_change_policy",
                                    "microsoft_office_addin_change_policy",
                                    "network_control_change_policy",
                                    "paper_change_deployment_policy",
                                    "paper_change_member_link_policy",
                                    "paper_change_member_policy",
                                    "paper_change_policy",
                                    "paper_enabled_users_group_addition",
                                    "paper_enabled_users_group_removal",
                                    "permanent_delete_change_policy",
                                    "sharing_change_folder_join_policy",
                                    "sharing_change_link_policy",
                                    "sharing_change_member_policy",
                                    "smart_sync_change_policy",
                                    "smart_sync_not_opt_out",
                                    "smart_sync_opt_out",
                                    "sso_change_policy",
                                    "tfa_change_policy",
                                    "two_account_change_policy",
                                    "web_sessions_change_fixed_length_policy",
                                    "web_sessions_change_idle_length_policy",
                                    "team_merge_from",
                                    "team_merge_to",
                                    "team_profile_add_logo",
                                    "team_profile_change_default_language",
                                    "team_profile_change_logo",
                                    "team_profile_change_name",
                                    "team_profile_remove_logo",
                                    "tfa_add_backup_phone",
                                    "tfa_add_security_key",
                                    "tfa_change_backup_phone",
                                    "tfa_change_status",
                                    "tfa_remove_backup_phone",
                                    "tfa_remove_security_key",
                                    "tfa_reset",
                                    "other"];
        deserializer.deserialize_struct("EventType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventType::AppLinkTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_link_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppLinkUser(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_link_user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppUnlinkTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_unlink_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppUnlinkUser(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_unlink_user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileAddComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_add_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileChangeCommentSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_change_comment_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDeleteComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_delete_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileLikeComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_like_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileResolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_resolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileUnlikeComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_unlike_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileUnresolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_unresolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpDesktop(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_desktop")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpMobile(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_mobile")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpWeb(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_web")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceLinkFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_link_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceLinkSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_link_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceManagementDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_management_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceManagementEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_management_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceUnlink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_unlink")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmRefreshAuthToken(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_refresh_auth_token")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureChangeAvailability(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_change_availability")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureMigrateAccount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_migrate_account")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureNotificationEmailsSent(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_notification_emails_sent")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureRelinquishAccount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_relinquish_account")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DisabledDomainInvites(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "disabled_domain_invites")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesApproveRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesDeclineRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesEmailExistingUsers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToNo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToYes(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationAddDomainFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationAddDomainSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationRemoveDomain(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_remove_domain")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EnabledDomainInvites(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "enabled_domain_invites")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CreateFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "create_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileAdd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_add")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileEdit(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_edit")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileGetCopyReference(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_get_copy_reference")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileMove(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_move")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FilePermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FilePreview(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_preview")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRestore(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_restore")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRevert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_revert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRollbackChanges(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_rollback_changes")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileSaveCopyReference(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_save_copy_reference")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestChange(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_change")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestClose(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_close")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestReceiveFile(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_receive_file")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupAddExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_add_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeManagementType(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_management_type")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupMoved(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_moved")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRemoveExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_remove_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmError(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_error")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LoginFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "login_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LoginSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "login_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::Logout(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "logout")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ResellerSupportSessionEnd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "reseller_support_session_end")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ResellerSupportSessionStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "reseller_support_session_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SignInAsSessionEnd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sign_in_as_session_end")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SignInAsSessionStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sign_in_as_session_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoError(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_error")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberAddName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_add_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeAdminRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_admin_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeEmail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_email")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeMembershipType(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_membership_type")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberPermanentlyDeleteAccountContents(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsAddCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsRemoveCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_remove_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSuggest(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_suggest")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberTransferAccountContents(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_transfer_account_contents")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentAddToFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_add_to_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentArchive(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_archive")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentPermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRemoveFromFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRestore(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_restore")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocAddComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_add_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeSharingPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDeleteComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_delete_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocEdit(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_edit")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocEditComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_edit_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocFollowed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_followed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocMention(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_mention")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocRequestAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_request_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocResolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocRevert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_revert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocSlackShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_slack_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocTrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_trashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocUnresolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocUntrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_untrashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewAllow(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_allow")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewDefaultTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_default_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewForbid(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_forbid")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderChangeSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_change_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderFollowed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_followed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordChange(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_change")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordReset(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_reset")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordResetAll(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_reset_all")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmCreateExceptionsReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_create_exceptions_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmCreateUsageReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_create_usage_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ExportMembersReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "export_members_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperAdminExportStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_admin_export_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncCreateAdminPrivilegeReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamActivityCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_activity_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CollectionShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "collection_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclInviteOnly(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_invite_only")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclTeamLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_team_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteShared(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_shared")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteShareReceive(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_share_receive")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::OpenNoteShared(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "open_note_shared")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfAddGroup(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_add_group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfAllowNonMembersToViewSharedLinks(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfExternalInviteWarn(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_external_invite_warn")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbInviteChangeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_invite_change_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbUninvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_uninvite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfInviteGroup(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_invite_group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamGrantAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_grant_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamInviteChangeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_invite_change_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamJoin(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_join")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamJoinFromOobLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamUninvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_uninvite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddInvitees(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_invitees")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeDownloadsPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeInviteeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkAudience(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_audience")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeViewerInfoPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentClaimInvitation(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_claim_invitation")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRelinquishMembership(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveInvitees(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_invitees")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRequestAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_request_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentUnshare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_unshare")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersInheritancePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_inheritance_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersManagementPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_management_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderDeclineInvitation(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_decline_invitation")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderMount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_mount")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderNest(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_nest")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderTransferOwnership(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderUnmount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_unmount")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkAddExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_add_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkChangeExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_change_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkChangeVisibility(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_change_visibility")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkDisable(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_disable")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkRemoveExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_remove_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedNoteOpened(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_note_opened")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShmodelGroupShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shmodel_group_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeSamlIdentityMode(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderDowngrade(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_downgrade")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderPermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AllowDownloadDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "allow_download_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AllowDownloadEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "allow_download_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DataPlacementRestrictionChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DataPlacementRestrictionSatisfyPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeDesktopPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeMobilePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeOverageAction(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeUnlinkAction(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ExtendedVersionHistoryChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "extended_version_history_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileCommentsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_comments_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsEmailsEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_emails_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsEmailsRestrictedToTeamOnly(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GoogleSsoChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "google_sso_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupUserManagementChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_user_management_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberRequestsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_requests_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeCapsTypePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_caps_type_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSuggestionsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_suggestions_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MicrosoftOfficeAddinChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NetworkControlChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "network_control_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeDeploymentPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_deployment_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeMemberLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_member_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeMemberPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_member_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupAddition(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupRemoval(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PermanentDeleteChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "permanent_delete_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeFolderJoinPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeMemberPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_member_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncNotOptOut(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncOptOut(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_opt_out")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TwoAccountChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "two_account_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WebSessionsChangeFixedLengthPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WebSessionsChangeIdleLengthPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeFrom(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_from")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeTo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_to")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileAddLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_add_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeDefaultLanguage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_default_language")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileRemoveLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_remove_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaAddBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_add_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaAddSecurityKey(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_add_security_key")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangeBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaRemoveBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaRemoveSecurityKey(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_remove_security_key")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaReset(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_reset")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Member data report created.
#[derive(Debug)]
pub struct ExportMembersReportDetails {
}

impl Default for ExportMembersReportDetails {
    fn default() -> Self {
        ExportMembersReportDetails {
        }
    }
}

const EXPORT_MEMBERS_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl ExportMembersReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExportMembersReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, EXPORT_MEMBERS_REPORT_DETAILS_FIELDS));
        }
        Ok(ExportMembersReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportDetails", EXPORT_MEMBERS_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ExportMembersReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ExportMembersReportType {
    pub description: String,
}

impl ExportMembersReportType {
    pub fn new(description: String) -> Self {
        ExportMembersReportType {
            description,
        }
    }

}

const EXPORT_MEMBERS_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl ExportMembersReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExportMembersReportType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXPORT_MEMBERS_REPORT_TYPE_FIELDS))
            }
        }
        Ok(ExportMembersReportType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportType", EXPORT_MEMBERS_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExportMembersReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Accepted or opted out of extended version history.
#[derive(Debug)]
pub struct ExtendedVersionHistoryChangePolicyDetails {
    /// New extended version history policy.
    pub new_value: ExtendedVersionHistoryPolicy,
    /// Previous extended version history policy. Might be missing due to historical data gap.
    pub previous_value: Option<ExtendedVersionHistoryPolicy>,
}

impl ExtendedVersionHistoryChangePolicyDetails {
    pub fn new(new_value: ExtendedVersionHistoryPolicy) -> Self {
        ExtendedVersionHistoryChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ExtendedVersionHistoryPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl ExtendedVersionHistoryChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExtendedVersionHistoryChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(ExtendedVersionHistoryChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExtendedVersionHistoryChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExtendedVersionHistoryChangePolicyDetails", EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExtendedVersionHistoryChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ExtendedVersionHistoryChangePolicyType {
    pub description: String,
}

impl ExtendedVersionHistoryChangePolicyType {
    pub fn new(description: String) -> Self {
        ExtendedVersionHistoryChangePolicyType {
            description,
        }
    }

}

const EXTENDED_VERSION_HISTORY_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ExtendedVersionHistoryChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExtendedVersionHistoryChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXTENDED_VERSION_HISTORY_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(ExtendedVersionHistoryChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExtendedVersionHistoryChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExtendedVersionHistoryChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExtendedVersionHistoryChangePolicyType", EXTENDED_VERSION_HISTORY_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExtendedVersionHistoryChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ExtendedVersionHistoryPolicy {
    ExplicitlyLimited,
    ExplicitlyUnlimited,
    ImplicitlyLimited,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExtendedVersionHistoryPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "explicitly_limited" => Ok(ExtendedVersionHistoryPolicy::ExplicitlyLimited),
                    "explicitly_unlimited" => Ok(ExtendedVersionHistoryPolicy::ExplicitlyUnlimited),
                    "implicitly_limited" => Ok(ExtendedVersionHistoryPolicy::ImplicitlyLimited),
                    _ => Ok(ExtendedVersionHistoryPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["explicitly_limited",
                                    "explicitly_unlimited",
                                    "implicitly_limited",
                                    "other"];
        deserializer.deserialize_struct("ExtendedVersionHistoryPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExtendedVersionHistoryPolicy::ExplicitlyLimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "explicitly_limited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::ExplicitlyUnlimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "explicitly_unlimited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::ImplicitlyLimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "implicitly_limited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// A user without a Dropbox account.
#[derive(Debug)]
pub struct ExternalUserLogInfo {
    /// An external user identifier.
    pub user_identifier: String,
    /// Identifier type.
    pub identifier_type: IdentifierType,
}

impl ExternalUserLogInfo {
    pub fn new(user_identifier: String, identifier_type: IdentifierType) -> Self {
        ExternalUserLogInfo {
            user_identifier,
            identifier_type,
        }
    }

}

const EXTERNAL_USER_LOG_INFO_FIELDS: &[&str] = &["user_identifier",
                                                 "identifier_type"];
impl ExternalUserLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExternalUserLogInfo, V::Error> {
        use serde::de;
        let mut field_user_identifier = None;
        let mut field_identifier_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_identifier" => {
                    if field_user_identifier.is_some() {
                        return Err(de::Error::duplicate_field("user_identifier"));
                    }
                    field_user_identifier = Some(map.next_value()?);
                }
                "identifier_type" => {
                    if field_identifier_type.is_some() {
                        return Err(de::Error::duplicate_field("identifier_type"));
                    }
                    field_identifier_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXTERNAL_USER_LOG_INFO_FIELDS))
            }
        }
        Ok(ExternalUserLogInfo {
            user_identifier: field_user_identifier.ok_or_else(|| de::Error::missing_field("user_identifier"))?,
            identifier_type: field_identifier_type.ok_or_else(|| de::Error::missing_field("identifier_type"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_identifier", &self.user_identifier)?;
        s.serialize_field("identifier_type", &self.identifier_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExternalUserLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExternalUserLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExternalUserLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExternalUserLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExternalUserLogInfo", EXTERNAL_USER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExternalUserLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExternalUserLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Provides details about a failure
#[derive(Debug)]
pub struct FailureDetailsLogInfo {
    /// A user friendly explanation of the error. Might be missing due to historical data gap.
    pub user_friendly_message: Option<String>,
    /// A technical explanation of the error. This is relevant for some errors.
    pub technical_error_message: Option<String>,
}

impl Default for FailureDetailsLogInfo {
    fn default() -> Self {
        FailureDetailsLogInfo {
            user_friendly_message: None,
            technical_error_message: None,
        }
    }
}

const FAILURE_DETAILS_LOG_INFO_FIELDS: &[&str] = &["user_friendly_message",
                                                   "technical_error_message"];
impl FailureDetailsLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FailureDetailsLogInfo, V::Error> {
        use serde::de;
        let mut field_user_friendly_message = None;
        let mut field_technical_error_message = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_friendly_message" => {
                    if field_user_friendly_message.is_some() {
                        return Err(de::Error::duplicate_field("user_friendly_message"));
                    }
                    field_user_friendly_message = Some(map.next_value()?);
                }
                "technical_error_message" => {
                    if field_technical_error_message.is_some() {
                        return Err(de::Error::duplicate_field("technical_error_message"));
                    }
                    field_technical_error_message = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FAILURE_DETAILS_LOG_INFO_FIELDS))
            }
        }
        Ok(FailureDetailsLogInfo {
            user_friendly_message: field_user_friendly_message,
            technical_error_message: field_technical_error_message,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_friendly_message", &self.user_friendly_message)?;
        s.serialize_field("technical_error_message", &self.technical_error_message)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FailureDetailsLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FailureDetailsLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FailureDetailsLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FailureDetailsLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FailureDetailsLogInfo", FAILURE_DETAILS_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FailureDetailsLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FailureDetailsLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a file comment.
#[derive(Debug)]
pub struct FileAddCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileAddCommentDetails {
    fn default() -> Self {
        FileAddCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_ADD_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileAddCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_ADD_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileAddCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddCommentDetails", FILE_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileAddCommentType {
    pub description: String,
}

impl FileAddCommentType {
    pub fn new(description: String) -> Self {
        FileAddCommentType {
            description,
        }
    }

}

const FILE_ADD_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileAddCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_ADD_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileAddCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddCommentType", FILE_ADD_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added files and/or folders.
#[derive(Debug)]
pub struct FileAddDetails {
}

impl Default for FileAddDetails {
    fn default() -> Self {
        FileAddDetails {
        }
    }
}

const FILE_ADD_DETAILS_FIELDS: &[&str] = &[];
impl FileAddDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_ADD_DETAILS_FIELDS));
        }
        Ok(FileAddDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddDetails", FILE_ADD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileAddDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileAddType {
    pub description: String,
}

impl FileAddType {
    pub fn new(description: String) -> Self {
        FileAddType {
            description,
        }
    }

}

const FILE_ADD_TYPE_FIELDS: &[&str] = &["description"];
impl FileAddType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_ADD_TYPE_FIELDS))
            }
        }
        Ok(FileAddType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAddType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddType", FILE_ADD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Subscribed to or unsubscribed from comment notifications for file.
#[derive(Debug)]
pub struct FileChangeCommentSubscriptionDetails {
    /// New file comment subscription.
    pub new_value: FileCommentNotificationPolicy,
    /// Previous file comment subscription. Might be missing due to historical data gap.
    pub previous_value: Option<FileCommentNotificationPolicy>,
}

impl FileChangeCommentSubscriptionDetails {
    pub fn new(new_value: FileCommentNotificationPolicy) -> Self {
        FileChangeCommentSubscriptionDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileCommentNotificationPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_CHANGE_COMMENT_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl FileChangeCommentSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileChangeCommentSubscriptionDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_CHANGE_COMMENT_SUBSCRIPTION_DETAILS_FIELDS))
            }
        }
        Ok(FileChangeCommentSubscriptionDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileChangeCommentSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileChangeCommentSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileChangeCommentSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileChangeCommentSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileChangeCommentSubscriptionDetails", FILE_CHANGE_COMMENT_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileChangeCommentSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileChangeCommentSubscriptionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileChangeCommentSubscriptionType {
    pub description: String,
}

impl FileChangeCommentSubscriptionType {
    pub fn new(description: String) -> Self {
        FileChangeCommentSubscriptionType {
            description,
        }
    }

}

const FILE_CHANGE_COMMENT_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl FileChangeCommentSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileChangeCommentSubscriptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_CHANGE_COMMENT_SUBSCRIPTION_TYPE_FIELDS))
            }
        }
        Ok(FileChangeCommentSubscriptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileChangeCommentSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileChangeCommentSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileChangeCommentSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileChangeCommentSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileChangeCommentSubscriptionType", FILE_CHANGE_COMMENT_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileChangeCommentSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileChangeCommentSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enable or disable file comments notifications
#[derive(Debug)]
pub enum FileCommentNotificationPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentNotificationPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileCommentNotificationPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentNotificationPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(FileCommentNotificationPolicy::Disabled),
                    "enabled" => Ok(FileCommentNotificationPolicy::Enabled),
                    _ => Ok(FileCommentNotificationPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileCommentNotificationPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentNotificationPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileCommentNotificationPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentNotificationPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileCommentNotificationPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentNotificationPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileCommentNotificationPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled or disabled commenting on team files.
#[derive(Debug)]
pub struct FileCommentsChangePolicyDetails {
    /// New commenting on team files policy.
    pub new_value: FileCommentsPolicy,
    /// Previous commenting on team files policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileCommentsPolicy>,
}

impl FileCommentsChangePolicyDetails {
    pub fn new(new_value: FileCommentsPolicy) -> Self {
        FileCommentsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileCommentsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl FileCommentsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileCommentsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(FileCommentsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCommentsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCommentsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCommentsChangePolicyDetails", FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCommentsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileCommentsChangePolicyType {
    pub description: String,
}

impl FileCommentsChangePolicyType {
    pub fn new(description: String) -> Self {
        FileCommentsChangePolicyType {
            description,
        }
    }

}

const FILE_COMMENTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl FileCommentsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileCommentsChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COMMENTS_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(FileCommentsChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCommentsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCommentsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCommentsChangePolicyType", FILE_COMMENTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCommentsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File comments policy
#[derive(Debug)]
pub enum FileCommentsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileCommentsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCommentsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(FileCommentsPolicy::Disabled),
                    "enabled" => Ok(FileCommentsPolicy::Enabled),
                    _ => Ok(FileCommentsPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileCommentsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileCommentsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileCommentsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileCommentsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Copied files and/or folders.
#[derive(Debug)]
pub struct FileCopyDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileCopyDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileCopyDetails {
            relocate_action_details,
        }
    }

}

const FILE_COPY_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileCopyDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COPY_DETAILS_FIELDS))
            }
        }
        Ok(FileCopyDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCopyDetails", FILE_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCopyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileCopyType {
    pub description: String,
}

impl FileCopyType {
    pub fn new(description: String) -> Self {
        FileCopyType {
            description,
        }
    }

}

const FILE_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl FileCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileCopyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_COPY_TYPE_FIELDS))
            }
        }
        Ok(FileCopyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCopyType", FILE_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a file comment.
#[derive(Debug)]
pub struct FileDeleteCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileDeleteCommentDetails {
    fn default() -> Self {
        FileDeleteCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_DELETE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileDeleteCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_DELETE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileDeleteCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteCommentDetails", FILE_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileDeleteCommentType {
    pub description: String,
}

impl FileDeleteCommentType {
    pub fn new(description: String) -> Self {
        FileDeleteCommentType {
            description,
        }
    }

}

const FILE_DELETE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileDeleteCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_DELETE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileDeleteCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDeleteCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteCommentType", FILE_DELETE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted files and/or folders.
#[derive(Debug)]
pub struct FileDeleteDetails {
}

impl Default for FileDeleteDetails {
    fn default() -> Self {
        FileDeleteDetails {
        }
    }
}

const FILE_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl FileDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_DELETE_DETAILS_FIELDS));
        }
        Ok(FileDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteDetails", FILE_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileDeleteType {
    pub description: String,
}

impl FileDeleteType {
    pub fn new(description: String) -> Self {
        FileDeleteType {
            description,
        }
    }

}

const FILE_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FileDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_DELETE_TYPE_FIELDS))
            }
        }
        Ok(FileDeleteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteType", FILE_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded files and/or folders.
#[derive(Debug)]
pub struct FileDownloadDetails {
}

impl Default for FileDownloadDetails {
    fn default() -> Self {
        FileDownloadDetails {
        }
    }
}

const FILE_DOWNLOAD_DETAILS_FIELDS: &[&str] = &[];
impl FileDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDownloadDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_DOWNLOAD_DETAILS_FIELDS));
        }
        Ok(FileDownloadDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDownloadDetails", FILE_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDownloadDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileDownloadType {
    pub description: String,
}

impl FileDownloadType {
    pub fn new(description: String) -> Self {
        FileDownloadType {
            description,
        }
    }

}

const FILE_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl FileDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDownloadType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_DOWNLOAD_TYPE_FIELDS))
            }
        }
        Ok(FileDownloadType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDownloadType", FILE_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited files.
#[derive(Debug)]
pub struct FileEditDetails {
}

impl Default for FileEditDetails {
    fn default() -> Self {
        FileEditDetails {
        }
    }
}

const FILE_EDIT_DETAILS_FIELDS: &[&str] = &[];
impl FileEditDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileEditDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_EDIT_DETAILS_FIELDS));
        }
        Ok(FileEditDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditDetails", FILE_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileEditDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileEditType {
    pub description: String,
}

impl FileEditType {
    pub fn new(description: String) -> Self {
        FileEditType {
            description,
        }
    }

}

const FILE_EDIT_TYPE_FIELDS: &[&str] = &["description"];
impl FileEditType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileEditType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_EDIT_TYPE_FIELDS))
            }
        }
        Ok(FileEditType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileEditType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditType", FILE_EDIT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileEditType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Create a copy reference to a file or folder.
#[derive(Debug)]
pub struct FileGetCopyReferenceDetails {
}

impl Default for FileGetCopyReferenceDetails {
    fn default() -> Self {
        FileGetCopyReferenceDetails {
        }
    }
}

const FILE_GET_COPY_REFERENCE_DETAILS_FIELDS: &[&str] = &[];
impl FileGetCopyReferenceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileGetCopyReferenceDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_GET_COPY_REFERENCE_DETAILS_FIELDS));
        }
        Ok(FileGetCopyReferenceDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileGetCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileGetCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileGetCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileGetCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileGetCopyReferenceDetails", FILE_GET_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileGetCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileGetCopyReferenceDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileGetCopyReferenceType {
    pub description: String,
}

impl FileGetCopyReferenceType {
    pub fn new(description: String) -> Self {
        FileGetCopyReferenceType {
            description,
        }
    }

}

const FILE_GET_COPY_REFERENCE_TYPE_FIELDS: &[&str] = &["description"];
impl FileGetCopyReferenceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileGetCopyReferenceType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_GET_COPY_REFERENCE_TYPE_FIELDS))
            }
        }
        Ok(FileGetCopyReferenceType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileGetCopyReferenceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileGetCopyReferenceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileGetCopyReferenceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileGetCopyReferenceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileGetCopyReferenceType", FILE_GET_COPY_REFERENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileGetCopyReferenceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileGetCopyReferenceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Liked a file comment.
#[derive(Debug)]
pub struct FileLikeCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileLikeCommentDetails {
    fn default() -> Self {
        FileLikeCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_LIKE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileLikeCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileLikeCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LIKE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileLikeCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLikeCommentDetails", FILE_LIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLikeCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileLikeCommentType {
    pub description: String,
}

impl FileLikeCommentType {
    pub fn new(description: String) -> Self {
        FileLikeCommentType {
            description,
        }
    }

}

const FILE_LIKE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileLikeCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileLikeCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LIKE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileLikeCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLikeCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLikeCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLikeCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLikeCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLikeCommentType", FILE_LIKE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLikeCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLikeCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File's logged information.
#[derive(Debug)]
pub struct FileLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FileLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FILE_LOG_INFO_FIELDS: &[&str] = &["path",
                                        "display_name",
                                        "file_id"];
impl FileLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LOG_INFO_FIELDS))
            }
        }
        Ok(FileLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLogInfo", FILE_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Moved files and/or folders.
#[derive(Debug)]
pub struct FileMoveDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileMoveDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileMoveDetails {
            relocate_action_details,
        }
    }

}

const FILE_MOVE_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileMoveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileMoveDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_MOVE_DETAILS_FIELDS))
            }
        }
        Ok(FileMoveDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMoveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMoveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMoveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMoveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMoveDetails", FILE_MOVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMoveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMoveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileMoveType {
    pub description: String,
}

impl FileMoveType {
    pub fn new(description: String) -> Self {
        FileMoveType {
            description,
        }
    }

}

const FILE_MOVE_TYPE_FIELDS: &[&str] = &["description"];
impl FileMoveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileMoveType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_MOVE_TYPE_FIELDS))
            }
        }
        Ok(FileMoveType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMoveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMoveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMoveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMoveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMoveType", FILE_MOVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMoveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMoveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Generic information relevant both for files and folders
#[derive(Debug)]
pub struct FileOrFolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FileOrFolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileOrFolderLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FILE_OR_FOLDER_LOG_INFO_FIELDS: &[&str] = &["path",
                                                  "display_name",
                                                  "file_id"];
impl FileOrFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileOrFolderLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_OR_FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(FileOrFolderLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileOrFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileOrFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileOrFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileOrFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileOrFolderLogInfo", FILE_OR_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileOrFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileOrFolderLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted files and/or folders.
#[derive(Debug)]
pub struct FilePermanentlyDeleteDetails {
}

impl Default for FilePermanentlyDeleteDetails {
    fn default() -> Self {
        FilePermanentlyDeleteDetails {
        }
    }
}

const FILE_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl FilePermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePermanentlyDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_PERMANENTLY_DELETE_DETAILS_FIELDS));
        }
        Ok(FilePermanentlyDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermanentlyDeleteDetails", FILE_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePermanentlyDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FilePermanentlyDeleteType {
    pub description: String,
}

impl FilePermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        FilePermanentlyDeleteType {
            description,
        }
    }

}

const FILE_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FilePermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePermanentlyDeleteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_PERMANENTLY_DELETE_TYPE_FIELDS))
            }
        }
        Ok(FilePermanentlyDeleteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermanentlyDeleteType", FILE_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FilePermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Previewed files and/or folders.
#[derive(Debug)]
pub struct FilePreviewDetails {
}

impl Default for FilePreviewDetails {
    fn default() -> Self {
        FilePreviewDetails {
        }
    }
}

const FILE_PREVIEW_DETAILS_FIELDS: &[&str] = &[];
impl FilePreviewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePreviewDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_PREVIEW_DETAILS_FIELDS));
        }
        Ok(FilePreviewDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePreviewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePreviewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePreviewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePreviewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePreviewDetails", FILE_PREVIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePreviewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePreviewDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FilePreviewType {
    pub description: String,
}

impl FilePreviewType {
    pub fn new(description: String) -> Self {
        FilePreviewType {
            description,
        }
    }

}

const FILE_PREVIEW_TYPE_FIELDS: &[&str] = &["description"];
impl FilePreviewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePreviewType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_PREVIEW_TYPE_FIELDS))
            }
        }
        Ok(FilePreviewType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePreviewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePreviewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePreviewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePreviewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePreviewType", FILE_PREVIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePreviewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FilePreviewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed files and/or folders.
#[derive(Debug)]
pub struct FileRenameDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileRenameDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileRenameDetails {
            relocate_action_details,
        }
    }

}

const FILE_RENAME_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRenameDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(FileRenameDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRenameDetails", FILE_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRenameType {
    pub description: String,
}

impl FileRenameType {
    pub fn new(description: String) -> Self {
        FileRenameType {
            description,
        }
    }

}

const FILE_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl FileRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRenameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RENAME_TYPE_FIELDS))
            }
        }
        Ok(FileRenameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRenameType", FILE_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change a file request.
#[derive(Debug)]
pub struct FileRequestChangeDetails {
    /// New file request details.
    pub new_details: FileRequestDetails,
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// Previous file request details. Might be missing due to historical data gap.
    pub previous_details: Option<FileRequestDetails>,
}

impl FileRequestChangeDetails {
    pub fn new(new_details: FileRequestDetails) -> Self {
        FileRequestChangeDetails {
            new_details,
            file_request_id: None,
            previous_details: None,
        }
    }

    pub fn with_file_request_id(
        mut self,
        value: Option<super::file_requests::FileRequestId>,
    ) -> Self {
        self.file_request_id = value;
        self
    }

    pub fn with_previous_details(mut self, value: Option<FileRequestDetails>) -> Self {
        self.previous_details = value;
        self
    }

}

const FILE_REQUEST_CHANGE_DETAILS_FIELDS: &[&str] = &["new_details",
                                                      "file_request_id",
                                                      "previous_details"];
impl FileRequestChangeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestChangeDetails, V::Error> {
        use serde::de;
        let mut field_new_details = None;
        let mut field_file_request_id = None;
        let mut field_previous_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_details" => {
                    if field_new_details.is_some() {
                        return Err(de::Error::duplicate_field("new_details"));
                    }
                    field_new_details = Some(map.next_value()?);
                }
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "previous_details" => {
                    if field_previous_details.is_some() {
                        return Err(de::Error::duplicate_field("previous_details"));
                    }
                    field_previous_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CHANGE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestChangeDetails {
            new_details: field_new_details.ok_or_else(|| de::Error::missing_field("new_details"))?,
            file_request_id: field_file_request_id,
            previous_details: field_previous_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_details", &self.new_details)?;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("previous_details", &self.previous_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeDetails", FILE_REQUEST_CHANGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestChangeType {
    pub description: String,
}

impl FileRequestChangeType {
    pub fn new(description: String) -> Self {
        FileRequestChangeType {
            description,
        }
    }

}

const FILE_REQUEST_CHANGE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestChangeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestChangeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CHANGE_TYPE_FIELDS))
            }
        }
        Ok(FileRequestChangeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeType", FILE_REQUEST_CHANGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Closed a file request.
#[derive(Debug)]
pub struct FileRequestCloseDetails {
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// Previous file request details. Might be missing due to historical data gap.
    pub previous_details: Option<FileRequestDetails>,
}

impl Default for FileRequestCloseDetails {
    fn default() -> Self {
        FileRequestCloseDetails {
            file_request_id: None,
            previous_details: None,
        }
    }
}

const FILE_REQUEST_CLOSE_DETAILS_FIELDS: &[&str] = &["file_request_id",
                                                     "previous_details"];
impl FileRequestCloseDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCloseDetails, V::Error> {
        use serde::de;
        let mut field_file_request_id = None;
        let mut field_previous_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "previous_details" => {
                    if field_previous_details.is_some() {
                        return Err(de::Error::duplicate_field("previous_details"));
                    }
                    field_previous_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CLOSE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestCloseDetails {
            file_request_id: field_file_request_id,
            previous_details: field_previous_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("previous_details", &self.previous_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCloseDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCloseDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCloseDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCloseDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCloseDetails", FILE_REQUEST_CLOSE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCloseDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCloseDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestCloseType {
    pub description: String,
}

impl FileRequestCloseType {
    pub fn new(description: String) -> Self {
        FileRequestCloseType {
            description,
        }
    }

}

const FILE_REQUEST_CLOSE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestCloseType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCloseType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CLOSE_TYPE_FIELDS))
            }
        }
        Ok(FileRequestCloseType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCloseType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCloseType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCloseType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCloseType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCloseType", FILE_REQUEST_CLOSE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCloseType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCloseType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a file request.
#[derive(Debug)]
pub struct FileRequestCreateDetails {
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// File request details. Might be missing due to historical data gap.
    pub request_details: Option<FileRequestDetails>,
}

impl Default for FileRequestCreateDetails {
    fn default() -> Self {
        FileRequestCreateDetails {
            file_request_id: None,
            request_details: None,
        }
    }
}

const FILE_REQUEST_CREATE_DETAILS_FIELDS: &[&str] = &["file_request_id",
                                                      "request_details"];
impl FileRequestCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCreateDetails, V::Error> {
        use serde::de;
        let mut field_file_request_id = None;
        let mut field_request_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "request_details" => {
                    if field_request_details.is_some() {
                        return Err(de::Error::duplicate_field("request_details"));
                    }
                    field_request_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestCreateDetails {
            file_request_id: field_file_request_id,
            request_details: field_request_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("request_details", &self.request_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCreateDetails", FILE_REQUEST_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestCreateType {
    pub description: String,
}

impl FileRequestCreateType {
    pub fn new(description: String) -> Self {
        FileRequestCreateType {
            description,
        }
    }

}

const FILE_REQUEST_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_CREATE_TYPE_FIELDS))
            }
        }
        Ok(FileRequestCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCreateType", FILE_REQUEST_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File request deadline
#[derive(Debug)]
pub struct FileRequestDeadline {
    /// The deadline for this file request. Might be missing due to historical data gap.
    pub deadline: Option<super::common::DropboxTimestamp>,
    /// If set, allow uploads after the deadline has passed. Might be missing due to historical data
    /// gap.
    pub allow_late_uploads: Option<String>,
}

impl Default for FileRequestDeadline {
    fn default() -> Self {
        FileRequestDeadline {
            deadline: None,
            allow_late_uploads: None,
        }
    }
}

const FILE_REQUEST_DEADLINE_FIELDS: &[&str] = &["deadline",
                                                "allow_late_uploads"];
impl FileRequestDeadline {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestDeadline, V::Error> {
        use serde::de;
        let mut field_deadline = None;
        let mut field_allow_late_uploads = None;
        while let Some(key) = map.next_key()? {
            match key {
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                "allow_late_uploads" => {
                    if field_allow_late_uploads.is_some() {
                        return Err(de::Error::duplicate_field("allow_late_uploads"));
                    }
                    field_allow_late_uploads = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_DEADLINE_FIELDS))
            }
        }
        Ok(FileRequestDeadline {
            deadline: field_deadline,
            allow_late_uploads: field_allow_late_uploads,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("deadline", &self.deadline)?;
        s.serialize_field("allow_late_uploads", &self.allow_late_uploads)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDeadline {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDeadline;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestDeadline struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDeadline::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDeadline", FILE_REQUEST_DEADLINE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDeadline {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDeadline", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File request details
#[derive(Debug)]
pub struct FileRequestDetails {
    /// Asset position in the Assets list.
    pub asset_index: u64,
    /// File request deadline. Might be missing due to historical data gap.
    pub deadline: Option<FileRequestDeadline>,
}

impl FileRequestDetails {
    pub fn new(asset_index: u64) -> Self {
        FileRequestDetails {
            asset_index,
            deadline: None,
        }
    }

    pub fn with_deadline(mut self, value: Option<FileRequestDeadline>) -> Self {
        self.deadline = value;
        self
    }

}

const FILE_REQUEST_DETAILS_FIELDS: &[&str] = &["asset_index",
                                               "deadline"];
impl FileRequestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestDetails, V::Error> {
        use serde::de;
        let mut field_asset_index = None;
        let mut field_deadline = None;
        while let Some(key) = map.next_key()? {
            match key {
                "asset_index" => {
                    if field_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("asset_index"));
                    }
                    field_asset_index = Some(map.next_value()?);
                }
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestDetails {
            asset_index: field_asset_index.ok_or_else(|| de::Error::missing_field("asset_index"))?,
            deadline: field_deadline,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("asset_index", &self.asset_index)?;
        s.serialize_field("deadline", &self.deadline)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDetails", FILE_REQUEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Received files for a file request.
#[derive(Debug)]
pub struct FileRequestReceiveFileDetails {
    /// Submitted file names.
    pub submitted_file_names: Vec<String>,
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// File request details. Might be missing due to historical data gap.
    pub file_request_details: Option<FileRequestDetails>,
    /// The name as provided by the submitter. Might be missing due to historical data gap.
    pub submitter_name: Option<super::common::DisplayNameLegacy>,
    /// The email as provided by the submitter. Might be missing due to historical data gap.
    pub submitter_email: Option<EmailAddress>,
}

impl FileRequestReceiveFileDetails {
    pub fn new(submitted_file_names: Vec<String>) -> Self {
        FileRequestReceiveFileDetails {
            submitted_file_names,
            file_request_id: None,
            file_request_details: None,
            submitter_name: None,
            submitter_email: None,
        }
    }

    pub fn with_file_request_id(
        mut self,
        value: Option<super::file_requests::FileRequestId>,
    ) -> Self {
        self.file_request_id = value;
        self
    }

    pub fn with_file_request_details(mut self, value: Option<FileRequestDetails>) -> Self {
        self.file_request_details = value;
        self
    }

    pub fn with_submitter_name(mut self, value: Option<super::common::DisplayNameLegacy>) -> Self {
        self.submitter_name = value;
        self
    }

    pub fn with_submitter_email(mut self, value: Option<EmailAddress>) -> Self {
        self.submitter_email = value;
        self
    }

}

const FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS: &[&str] = &["submitted_file_names",
                                                            "file_request_id",
                                                            "file_request_details",
                                                            "submitter_name",
                                                            "submitter_email"];
impl FileRequestReceiveFileDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestReceiveFileDetails, V::Error> {
        use serde::de;
        let mut field_submitted_file_names = None;
        let mut field_file_request_id = None;
        let mut field_file_request_details = None;
        let mut field_submitter_name = None;
        let mut field_submitter_email = None;
        while let Some(key) = map.next_key()? {
            match key {
                "submitted_file_names" => {
                    if field_submitted_file_names.is_some() {
                        return Err(de::Error::duplicate_field("submitted_file_names"));
                    }
                    field_submitted_file_names = Some(map.next_value()?);
                }
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "file_request_details" => {
                    if field_file_request_details.is_some() {
                        return Err(de::Error::duplicate_field("file_request_details"));
                    }
                    field_file_request_details = Some(map.next_value()?);
                }
                "submitter_name" => {
                    if field_submitter_name.is_some() {
                        return Err(de::Error::duplicate_field("submitter_name"));
                    }
                    field_submitter_name = Some(map.next_value()?);
                }
                "submitter_email" => {
                    if field_submitter_email.is_some() {
                        return Err(de::Error::duplicate_field("submitter_email"));
                    }
                    field_submitter_email = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestReceiveFileDetails {
            submitted_file_names: field_submitted_file_names.ok_or_else(|| de::Error::missing_field("submitted_file_names"))?,
            file_request_id: field_file_request_id,
            file_request_details: field_file_request_details,
            submitter_name: field_submitter_name,
            submitter_email: field_submitter_email,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("submitted_file_names", &self.submitted_file_names)?;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("file_request_details", &self.file_request_details)?;
        s.serialize_field("submitter_name", &self.submitter_name)?;
        s.serialize_field("submitter_email", &self.submitter_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestReceiveFileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestReceiveFileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestReceiveFileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestReceiveFileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestReceiveFileDetails", FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestReceiveFileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestReceiveFileDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestReceiveFileType {
    pub description: String,
}

impl FileRequestReceiveFileType {
    pub fn new(description: String) -> Self {
        FileRequestReceiveFileType {
            description,
        }
    }

}

const FILE_REQUEST_RECEIVE_FILE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestReceiveFileType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestReceiveFileType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUEST_RECEIVE_FILE_TYPE_FIELDS))
            }
        }
        Ok(FileRequestReceiveFileType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestReceiveFileType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestReceiveFileType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestReceiveFileType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestReceiveFileType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestReceiveFileType", FILE_REQUEST_RECEIVE_FILE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestReceiveFileType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestReceiveFileType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled file requests.
#[derive(Debug)]
pub struct FileRequestsChangePolicyDetails {
    /// New file requests policy.
    pub new_value: FileRequestsPolicy,
    /// Previous file requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileRequestsPolicy>,
}

impl FileRequestsChangePolicyDetails {
    pub fn new(new_value: FileRequestsPolicy) -> Self {
        FileRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl FileRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(FileRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsChangePolicyDetails", FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsChangePolicyType {
    pub description: String,
}

impl FileRequestsChangePolicyType {
    pub fn new(description: String) -> Self {
        FileRequestsChangePolicyType {
            description,
        }
    }

}

const FILE_REQUESTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUESTS_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(FileRequestsChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsChangePolicyType", FILE_REQUESTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled file request emails for everyone.
#[derive(Debug)]
pub struct FileRequestsEmailsEnabledDetails {
}

impl Default for FileRequestsEmailsEnabledDetails {
    fn default() -> Self {
        FileRequestsEmailsEnabledDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl FileRequestsEmailsEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsEnabledDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS));
        }
        Ok(FileRequestsEmailsEnabledDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsEnabledDetails", FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsEmailsEnabledType {
    pub description: String,
}

impl FileRequestsEmailsEnabledType {
    pub fn new(description: String) -> Self {
        FileRequestsEmailsEnabledType {
            description,
        }
    }

}

const FILE_REQUESTS_EMAILS_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsEmailsEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsEnabledType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_ENABLED_TYPE_FIELDS))
            }
        }
        Ok(FileRequestsEmailsEnabledType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsEnabledType", FILE_REQUESTS_EMAILS_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsEmailsEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Allowed file request emails for the team.
#[derive(Debug)]
pub struct FileRequestsEmailsRestrictedToTeamOnlyDetails {
}

impl Default for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn default() -> Self {
        FileRequestsEmailsRestrictedToTeamOnlyDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS: &[&str] = &[];
impl FileRequestsEmailsRestrictedToTeamOnlyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsRestrictedToTeamOnlyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS));
        }
        Ok(FileRequestsEmailsRestrictedToTeamOnlyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsRestrictedToTeamOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsRestrictedToTeamOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsEmailsRestrictedToTeamOnlyType {
    pub description: String,
}

impl FileRequestsEmailsRestrictedToTeamOnlyType {
    pub fn new(description: String) -> Self {
        FileRequestsEmailsRestrictedToTeamOnlyType {
            description,
        }
    }

}

const FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsEmailsRestrictedToTeamOnlyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsRestrictedToTeamOnlyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_TYPE_FIELDS))
            }
        }
        Ok(FileRequestsEmailsRestrictedToTeamOnlyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsRestrictedToTeamOnlyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsRestrictedToTeamOnlyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsRestrictedToTeamOnlyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsRestrictedToTeamOnlyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsRestrictedToTeamOnlyType", FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsRestrictedToTeamOnlyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsEmailsRestrictedToTeamOnlyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File requests policy
#[derive(Debug)]
pub enum FileRequestsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(FileRequestsPolicy::Disabled),
                    "enabled" => Ok(FileRequestsPolicy::Enabled),
                    _ => Ok(FileRequestsPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileRequestsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Resolved a file comment.
#[derive(Debug)]
pub struct FileResolveCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileResolveCommentDetails {
    fn default() -> Self {
        FileResolveCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_RESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileResolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileResolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileResolveCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileResolveCommentDetails", FILE_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileResolveCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileResolveCommentType {
    pub description: String,
}

impl FileResolveCommentType {
    pub fn new(description: String) -> Self {
        FileResolveCommentType {
            description,
        }
    }

}

const FILE_RESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileResolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileResolveCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RESOLVE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileResolveCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileResolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileResolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileResolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileResolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileResolveCommentType", FILE_RESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileResolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileResolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored deleted files and/or folders.
#[derive(Debug)]
pub struct FileRestoreDetails {
}

impl Default for FileRestoreDetails {
    fn default() -> Self {
        FileRestoreDetails {
        }
    }
}

const FILE_RESTORE_DETAILS_FIELDS: &[&str] = &[];
impl FileRestoreDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRestoreDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_RESTORE_DETAILS_FIELDS));
        }
        Ok(FileRestoreDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRestoreDetails", FILE_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRestoreDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRestoreType {
    pub description: String,
}

impl FileRestoreType {
    pub fn new(description: String) -> Self {
        FileRestoreType {
            description,
        }
    }

}

const FILE_RESTORE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRestoreType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRestoreType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_RESTORE_TYPE_FIELDS))
            }
        }
        Ok(FileRestoreType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRestoreType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRestoreType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRestoreType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRestoreType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRestoreType", FILE_RESTORE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRestoreType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRestoreType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reverted files to a previous version.
#[derive(Debug)]
pub struct FileRevertDetails {
}

impl Default for FileRevertDetails {
    fn default() -> Self {
        FileRevertDetails {
        }
    }
}

const FILE_REVERT_DETAILS_FIELDS: &[&str] = &[];
impl FileRevertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRevertDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_REVERT_DETAILS_FIELDS));
        }
        Ok(FileRevertDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRevertDetails", FILE_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRevertDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRevertType {
    pub description: String,
}

impl FileRevertType {
    pub fn new(description: String) -> Self {
        FileRevertType {
            description,
        }
    }

}

const FILE_REVERT_TYPE_FIELDS: &[&str] = &["description"];
impl FileRevertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRevertType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_REVERT_TYPE_FIELDS))
            }
        }
        Ok(FileRevertType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRevertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRevertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRevertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRevertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRevertType", FILE_REVERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRevertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRevertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Rolled back file change location changes.
#[derive(Debug)]
pub struct FileRollbackChangesDetails {
}

impl Default for FileRollbackChangesDetails {
    fn default() -> Self {
        FileRollbackChangesDetails {
        }
    }
}

const FILE_ROLLBACK_CHANGES_DETAILS_FIELDS: &[&str] = &[];
impl FileRollbackChangesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRollbackChangesDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, FILE_ROLLBACK_CHANGES_DETAILS_FIELDS));
        }
        Ok(FileRollbackChangesDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRollbackChangesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRollbackChangesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRollbackChangesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRollbackChangesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRollbackChangesDetails", FILE_ROLLBACK_CHANGES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRollbackChangesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRollbackChangesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRollbackChangesType {
    pub description: String,
}

impl FileRollbackChangesType {
    pub fn new(description: String) -> Self {
        FileRollbackChangesType {
            description,
        }
    }

}

const FILE_ROLLBACK_CHANGES_TYPE_FIELDS: &[&str] = &["description"];
impl FileRollbackChangesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRollbackChangesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_ROLLBACK_CHANGES_TYPE_FIELDS))
            }
        }
        Ok(FileRollbackChangesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRollbackChangesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRollbackChangesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRollbackChangesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRollbackChangesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRollbackChangesType", FILE_ROLLBACK_CHANGES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRollbackChangesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRollbackChangesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Save a file or folder using a copy reference.
#[derive(Debug)]
pub struct FileSaveCopyReferenceDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileSaveCopyReferenceDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileSaveCopyReferenceDetails {
            relocate_action_details,
        }
    }

}

const FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileSaveCopyReferenceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileSaveCopyReferenceDetails, V::Error> {
        use serde::de;
        let mut field_relocate_action_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS))
            }
        }
        Ok(FileSaveCopyReferenceDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| de::Error::missing_field("relocate_action_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileSaveCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileSaveCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileSaveCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileSaveCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileSaveCopyReferenceDetails", FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileSaveCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileSaveCopyReferenceDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileSaveCopyReferenceType {
    pub description: String,
}

impl FileSaveCopyReferenceType {
    pub fn new(description: String) -> Self {
        FileSaveCopyReferenceType {
            description,
        }
    }

}

const FILE_SAVE_COPY_REFERENCE_TYPE_FIELDS: &[&str] = &["description"];
impl FileSaveCopyReferenceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileSaveCopyReferenceType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_SAVE_COPY_REFERENCE_TYPE_FIELDS))
            }
        }
        Ok(FileSaveCopyReferenceType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileSaveCopyReferenceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileSaveCopyReferenceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileSaveCopyReferenceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileSaveCopyReferenceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileSaveCopyReferenceType", FILE_SAVE_COPY_REFERENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileSaveCopyReferenceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileSaveCopyReferenceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unliked a file comment.
#[derive(Debug)]
pub struct FileUnlikeCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileUnlikeCommentDetails {
    fn default() -> Self {
        FileUnlikeCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_UNLIKE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileUnlikeCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnlikeCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_UNLIKE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileUnlikeCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnlikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnlikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileUnlikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnlikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnlikeCommentDetails", FILE_UNLIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnlikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnlikeCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileUnlikeCommentType {
    pub description: String,
}

impl FileUnlikeCommentType {
    pub fn new(description: String) -> Self {
        FileUnlikeCommentType {
            description,
        }
    }

}

const FILE_UNLIKE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileUnlikeCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnlikeCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_UNLIKE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileUnlikeCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnlikeCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnlikeCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileUnlikeCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnlikeCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnlikeCommentType", FILE_UNLIKE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnlikeCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnlikeCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved a file comment.
#[derive(Debug)]
pub struct FileUnresolveCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileUnresolveCommentDetails {
    fn default() -> Self {
        FileUnresolveCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_UNRESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileUnresolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnresolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_UNRESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(FileUnresolveCommentDetails {
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnresolveCommentDetails", FILE_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnresolveCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileUnresolveCommentType {
    pub description: String,
}

impl FileUnresolveCommentType {
    pub fn new(description: String) -> Self {
        FileUnresolveCommentType {
            description,
        }
    }

}

const FILE_UNRESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileUnresolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnresolveCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_UNRESOLVE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(FileUnresolveCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnresolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnresolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileUnresolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnresolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnresolveCommentType", FILE_UNRESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnresolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnresolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Folder's logged information.
#[derive(Debug)]
pub struct FolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
}

impl FolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FolderLogInfo {
            path,
            display_name: None,
            file_id: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

}

const FOLDER_LOG_INFO_FIELDS: &[&str] = &["path",
                                          "display_name",
                                          "file_id"];
impl FolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FolderLogInfo, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(FolderLogInfo {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderLogInfo", FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Geographic location details.
#[derive(Debug)]
pub struct GeoLocationLogInfo {
    /// IP address.
    pub ip_address: IpAddress,
    /// City name.
    pub city: Option<String>,
    /// Region name.
    pub region: Option<String>,
    /// Country code.
    pub country: Option<String>,
}

impl GeoLocationLogInfo {
    pub fn new(ip_address: IpAddress) -> Self {
        GeoLocationLogInfo {
            ip_address,
            city: None,
            region: None,
            country: None,
        }
    }

    pub fn with_city(mut self, value: Option<String>) -> Self {
        self.city = value;
        self
    }

    pub fn with_region(mut self, value: Option<String>) -> Self {
        self.region = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

}

const GEO_LOCATION_LOG_INFO_FIELDS: &[&str] = &["ip_address",
                                                "city",
                                                "region",
                                                "country"];
impl GeoLocationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GeoLocationLogInfo, V::Error> {
        use serde::de;
        let mut field_ip_address = None;
        let mut field_city = None;
        let mut field_region = None;
        let mut field_country = None;
        while let Some(key) = map.next_key()? {
            match key {
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "city" => {
                    if field_city.is_some() {
                        return Err(de::Error::duplicate_field("city"));
                    }
                    field_city = Some(map.next_value()?);
                }
                "region" => {
                    if field_region.is_some() {
                        return Err(de::Error::duplicate_field("region"));
                    }
                    field_region = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GEO_LOCATION_LOG_INFO_FIELDS))
            }
        }
        Ok(GeoLocationLogInfo {
            ip_address: field_ip_address.ok_or_else(|| de::Error::missing_field("ip_address"))?,
            city: field_city,
            region: field_region,
            country: field_country,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("city", &self.city)?;
        s.serialize_field("region", &self.region)?;
        s.serialize_field("country", &self.country)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GeoLocationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GeoLocationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GeoLocationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GeoLocationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GeoLocationLogInfo", GEO_LOCATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GeoLocationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GeoLocationLogInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsArg {
    /// Number of results to return per call.
    pub limit: u32,
    /// Filter the events by account ID. Return ony events with this account_id as either Actor,
    /// Context, or Participants.
    pub account_id: Option<super::users_common::AccountId>,
    /// Filter by time range.
    pub time: Option<super::team_common::TimeRange>,
    /// Filter the returned events to a single category.
    pub category: Option<EventCategory>,
}

impl Default for GetTeamEventsArg {
    fn default() -> Self {
        GetTeamEventsArg {
            limit: 1000,
            account_id: None,
            time: None,
            category: None,
        }
    }
}

const GET_TEAM_EVENTS_ARG_FIELDS: &[&str] = &["limit",
                                              "account_id",
                                              "time",
                                              "category"];
impl GetTeamEventsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetTeamEventsArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        let mut field_account_id = None;
        let mut field_time = None;
        let mut field_category = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "time" => {
                    if field_time.is_some() {
                        return Err(de::Error::duplicate_field("time"));
                    }
                    field_time = Some(map.next_value()?);
                }
                "category" => {
                    if field_category.is_some() {
                        return Err(de::Error::duplicate_field("category"));
                    }
                    field_category = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_ARG_FIELDS))
            }
        }
        Ok(GetTeamEventsArg {
            limit: field_limit.unwrap_or(1000),
            account_id: field_account_id,
            time: field_time,
            category: field_category,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("time", &self.time)?;
        s.serialize_field("category", &self.category)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsArg", GET_TEAM_EVENTS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsContinueArg {
    /// Indicates from what point to get the next set of events.
    pub cursor: String,
}

impl GetTeamEventsContinueArg {
    pub fn new(cursor: String) -> Self {
        GetTeamEventsContinueArg {
            cursor,
        }
    }

}

const GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl GetTeamEventsContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetTeamEventsContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(GetTeamEventsContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsContinueArg", GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors that can be raised when calling :route:`get_events/continue`.
#[derive(Debug)]
pub enum GetTeamEventsContinueError {
    /// Bad cursor.
    BadCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "bad_cursor" => Ok(GetTeamEventsContinueError::BadCursor),
                    _ => Ok(GetTeamEventsContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor",
                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsContinueError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsContinueError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            GetTeamEventsContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsContinueError {
    fn description(&self) -> &str {
        "GetTeamEventsContinueError"
    }
}

impl ::std::fmt::Display for GetTeamEventsContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Errors that can be raised when calling :route:`get_events`.
#[derive(Debug)]
pub enum GetTeamEventsError {
    /// No user found matching the provided account_id.
    AccountIdNotFound,
    /// Invalid time range.
    InvalidTimeRange,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "account_id_not_found" => Ok(GetTeamEventsError::AccountIdNotFound),
                    "invalid_time_range" => Ok(GetTeamEventsError::InvalidTimeRange),
                    _ => Ok(GetTeamEventsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["account_id_not_found",
                                    "invalid_time_range",
                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsError::AccountIdNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "account_id_not_found")?;
                s.end()
            }
            GetTeamEventsError::InvalidTimeRange => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "invalid_time_range")?;
                s.end()
            }
            GetTeamEventsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsError {
    fn description(&self) -> &str {
        "GetTeamEventsError"
    }
}

impl ::std::fmt::Display for GetTeamEventsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GetTeamEventsResult {
    /// List of events.
    pub events: Vec<TeamEvent>,
    /// Pass the cursor into :route:`get_events/continue` to obtain additional events.
    pub cursor: String,
    /// Is true if there are additional events that have not been returned yet. An additional call
    /// to :route:`get_events/continue` can retrieve them.
    pub has_more: bool,
}

impl GetTeamEventsResult {
    pub fn new(events: Vec<TeamEvent>, cursor: String, has_more: bool) -> Self {
        GetTeamEventsResult {
            events,
            cursor,
            has_more,
        }
    }

}

const GET_TEAM_EVENTS_RESULT_FIELDS: &[&str] = &["events",
                                                 "cursor",
                                                 "has_more"];
impl GetTeamEventsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetTeamEventsResult, V::Error> {
        use serde::de;
        let mut field_events = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        while let Some(key) = map.next_key()? {
            match key {
                "events" => {
                    if field_events.is_some() {
                        return Err(de::Error::duplicate_field("events"));
                    }
                    field_events = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_TEAM_EVENTS_RESULT_FIELDS))
            }
        }
        Ok(GetTeamEventsResult {
            events: field_events.ok_or_else(|| de::Error::missing_field("events"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("events", &self.events)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsResult", GET_TEAM_EVENTS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled Google single sign-on for the team.
#[derive(Debug)]
pub struct GoogleSsoChangePolicyDetails {
    /// New Google single sign-on policy.
    pub new_value: GoogleSsoPolicy,
    /// Previous Google single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<GoogleSsoPolicy>,
}

impl GoogleSsoChangePolicyDetails {
    pub fn new(new_value: GoogleSsoPolicy) -> Self {
        GoogleSsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<GoogleSsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl GoogleSsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GoogleSsoChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(GoogleSsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GoogleSsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GoogleSsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GoogleSsoChangePolicyDetails", GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GoogleSsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GoogleSsoChangePolicyType {
    pub description: String,
}

impl GoogleSsoChangePolicyType {
    pub fn new(description: String) -> Self {
        GoogleSsoChangePolicyType {
            description,
        }
    }

}

const GOOGLE_SSO_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl GoogleSsoChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GoogleSsoChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GOOGLE_SSO_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(GoogleSsoChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GoogleSsoChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GoogleSsoChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GoogleSsoChangePolicyType", GOOGLE_SSO_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GoogleSsoChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Google SSO policy
#[derive(Debug)]
pub enum GoogleSsoPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GoogleSsoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(GoogleSsoPolicy::Disabled),
                    "enabled" => Ok(GoogleSsoPolicy::Enabled),
                    _ => Ok(GoogleSsoPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("GoogleSsoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GoogleSsoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            GoogleSsoPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            GoogleSsoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added an external ID for group.
#[derive(Debug)]
pub struct GroupAddExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
}

impl GroupAddExternalIdDetails {
    pub fn new(new_value: super::team_common::GroupExternalId) -> Self {
        GroupAddExternalIdDetails {
            new_value,
        }
    }

}

const GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value"];
impl GroupAddExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupAddExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupAddExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddExternalIdDetails", GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupAddExternalIdType {
    pub description: String,
}

impl GroupAddExternalIdType {
    pub fn new(description: String) -> Self {
        GroupAddExternalIdType {
            description,
        }
    }

}

const GROUP_ADD_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupAddExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupAddExternalIdType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_EXTERNAL_ID_TYPE_FIELDS))
            }
        }
        Ok(GroupAddExternalIdType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddExternalIdType", GROUP_ADD_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added team members to a group.
#[derive(Debug)]
pub struct GroupAddMemberDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupAddMemberDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupAddMemberDetails {
            is_group_owner,
        }
    }

}

const GROUP_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["is_group_owner"];
impl GroupAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_is_group_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(GroupAddMemberDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| de::Error::missing_field("is_group_owner"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddMemberDetails", GROUP_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupAddMemberType {
    pub description: String,
}

impl GroupAddMemberType {
    pub fn new(description: String) -> Self {
        GroupAddMemberType {
            description,
        }
    }

}

const GROUP_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl GroupAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupAddMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_ADD_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(GroupAddMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddMemberType", GROUP_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the external ID for group.
#[derive(Debug)]
pub struct GroupChangeExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupChangeExternalIdDetails {
    pub fn new(
        new_value: super::team_common::GroupExternalId,
        previous_value: super::team_common::GroupExternalId,
    ) -> Self {
        GroupChangeExternalIdDetails {
            new_value,
            previous_value,
        }
    }

}

const GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl GroupChangeExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeExternalIdDetails", GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeExternalIdDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeExternalIdType {
    pub description: String,
}

impl GroupChangeExternalIdType {
    pub fn new(description: String) -> Self {
        GroupChangeExternalIdType {
            description,
        }
    }

}

const GROUP_CHANGE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeExternalIdType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_EXTERNAL_ID_TYPE_FIELDS))
            }
        }
        Ok(GroupChangeExternalIdType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeExternalIdType", GROUP_CHANGE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed group management type.
#[derive(Debug)]
pub struct GroupChangeManagementTypeDetails {
    /// New group management type.
    pub new_value: super::team_common::GroupManagementType,
    /// Previous group management type. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_common::GroupManagementType>,
}

impl GroupChangeManagementTypeDetails {
    pub fn new(new_value: super::team_common::GroupManagementType) -> Self {
        GroupChangeManagementTypeDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_common::GroupManagementType>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                               "previous_value"];
impl GroupChangeManagementTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeManagementTypeDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeManagementTypeDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeManagementTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeManagementTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeManagementTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeManagementTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeManagementTypeDetails", GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeManagementTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeManagementTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeManagementTypeType {
    pub description: String,
}

impl GroupChangeManagementTypeType {
    pub fn new(description: String) -> Self {
        GroupChangeManagementTypeType {
            description,
        }
    }

}

const GROUP_CHANGE_MANAGEMENT_TYPE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeManagementTypeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeManagementTypeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MANAGEMENT_TYPE_TYPE_FIELDS))
            }
        }
        Ok(GroupChangeManagementTypeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeManagementTypeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeManagementTypeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeManagementTypeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeManagementTypeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeManagementTypeType", GROUP_CHANGE_MANAGEMENT_TYPE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeManagementTypeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeManagementTypeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the manager permissions belonging to a group member.
#[derive(Debug)]
pub struct GroupChangeMemberRoleDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupChangeMemberRoleDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupChangeMemberRoleDetails {
            is_group_owner,
        }
    }

}

const GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["is_group_owner"];
impl GroupChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_is_group_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(GroupChangeMemberRoleDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| de::Error::missing_field("is_group_owner"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeMemberRoleDetails", GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeMemberRoleDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeMemberRoleType {
    pub description: String,
}

impl GroupChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        GroupChangeMemberRoleType {
            description,
        }
    }

}

const GROUP_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupChangeMemberRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CHANGE_MEMBER_ROLE_TYPE_FIELDS))
            }
        }
        Ok(GroupChangeMemberRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeMemberRoleType", GROUP_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a group.
#[derive(Debug)]
pub struct GroupCreateDetails {
    /// Group join policy.
    pub join_policy: GroupJoinPolicy,
    /// Is company managed group. Might be missing due to historical data gap.
    pub is_company_managed: Option<bool>,
}

impl GroupCreateDetails {
    pub fn new(join_policy: GroupJoinPolicy) -> Self {
        GroupCreateDetails {
            join_policy,
            is_company_managed: None,
        }
    }

    pub fn with_is_company_managed(mut self, value: Option<bool>) -> Self {
        self.is_company_managed = value;
        self
    }

}

const GROUP_CREATE_DETAILS_FIELDS: &[&str] = &["join_policy",
                                               "is_company_managed"];
impl GroupCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupCreateDetails, V::Error> {
        use serde::de;
        let mut field_join_policy = None;
        let mut field_is_company_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "join_policy" => {
                    if field_join_policy.is_some() {
                        return Err(de::Error::duplicate_field("join_policy"));
                    }
                    field_join_policy = Some(map.next_value()?);
                }
                "is_company_managed" => {
                    if field_is_company_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_company_managed"));
                    }
                    field_is_company_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(GroupCreateDetails {
            join_policy: field_join_policy.ok_or_else(|| de::Error::missing_field("join_policy"))?,
            is_company_managed: field_is_company_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("join_policy", &self.join_policy)?;
        s.serialize_field("is_company_managed", &self.is_company_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateDetails", GROUP_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupCreateType {
    pub description: String,
}

impl GroupCreateType {
    pub fn new(description: String) -> Self {
        GroupCreateType {
            description,
        }
    }

}

const GROUP_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CREATE_TYPE_FIELDS))
            }
        }
        Ok(GroupCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateType", GROUP_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a group.
#[derive(Debug)]
pub struct GroupDeleteDetails {
    /// Is company managed group. Might be missing due to historical data gap.
    pub is_company_managed: Option<bool>,
}

impl Default for GroupDeleteDetails {
    fn default() -> Self {
        GroupDeleteDetails {
            is_company_managed: None,
        }
    }
}

const GROUP_DELETE_DETAILS_FIELDS: &[&str] = &["is_company_managed"];
impl GroupDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupDeleteDetails, V::Error> {
        use serde::de;
        let mut field_is_company_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "is_company_managed" => {
                    if field_is_company_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_company_managed"));
                    }
                    field_is_company_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_DELETE_DETAILS_FIELDS))
            }
        }
        Ok(GroupDeleteDetails {
            is_company_managed: field_is_company_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_company_managed", &self.is_company_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDeleteDetails", GROUP_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupDeleteType {
    pub description: String,
}

impl GroupDeleteType {
    pub fn new(description: String) -> Self {
        GroupDeleteType {
            description,
        }
    }

}

const GROUP_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupDeleteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_DELETE_TYPE_FIELDS))
            }
        }
        Ok(GroupDeleteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDeleteType", GROUP_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupJoinPolicy {
    Open,
    RequestToJoin,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "open" => Ok(GroupJoinPolicy::Open),
                    "request_to_join" => Ok(GroupJoinPolicy::RequestToJoin),
                    _ => Ok(GroupJoinPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["open",
                                    "request_to_join",
                                    "other"];
        deserializer.deserialize_struct("GroupJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupJoinPolicy::Open => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "open")?;
                s.end()
            }
            GroupJoinPolicy::RequestToJoin => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "request_to_join")?;
                s.end()
            }
            GroupJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Group's logged information.
#[derive(Debug)]
pub struct GroupLogInfo {
    /// The name of this group.
    pub display_name: String,
    /// The unique id of this group. Might be missing due to historical data gap.
    pub group_id: Option<super::team_common::GroupId>,
    /// External group ID. Might be missing due to historical data gap.
    pub external_id: Option<super::team_common::GroupExternalId>,
}

impl GroupLogInfo {
    pub fn new(display_name: String) -> Self {
        GroupLogInfo {
            display_name,
            group_id: None,
            external_id: None,
        }
    }

    pub fn with_group_id(mut self, value: Option<super::team_common::GroupId>) -> Self {
        self.group_id = value;
        self
    }

    pub fn with_external_id(mut self, value: Option<super::team_common::GroupExternalId>) -> Self {
        self.external_id = value;
        self
    }

}

const GROUP_LOG_INFO_FIELDS: &[&str] = &["display_name",
                                         "group_id",
                                         "external_id"];
impl GroupLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupLogInfo, V::Error> {
        use serde::de;
        let mut field_display_name = None;
        let mut field_group_id = None;
        let mut field_external_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "group_id" => {
                    if field_group_id.is_some() {
                        return Err(de::Error::duplicate_field("group_id"));
                    }
                    field_group_id = Some(map.next_value()?);
                }
                "external_id" => {
                    if field_external_id.is_some() {
                        return Err(de::Error::duplicate_field("external_id"));
                    }
                    field_external_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_LOG_INFO_FIELDS))
            }
        }
        Ok(GroupLogInfo {
            display_name: field_display_name.ok_or_else(|| de::Error::missing_field("display_name"))?,
            group_id: field_group_id,
            external_id: field_external_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("group_id", &self.group_id)?;
        s.serialize_field("external_id", &self.external_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupLogInfo", GROUP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Moved a group.
#[derive(Debug)]
pub struct GroupMovedDetails {
}

impl Default for GroupMovedDetails {
    fn default() -> Self {
        GroupMovedDetails {
        }
    }
}

const GROUP_MOVED_DETAILS_FIELDS: &[&str] = &[];
impl GroupMovedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupMovedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, GROUP_MOVED_DETAILS_FIELDS));
        }
        Ok(GroupMovedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMovedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMovedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMovedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMovedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMovedDetails", GROUP_MOVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMovedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupMovedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct GroupMovedType {
    pub description: String,
}

impl GroupMovedType {
    pub fn new(description: String) -> Self {
        GroupMovedType {
            description,
        }
    }

}

const GROUP_MOVED_TYPE_FIELDS: &[&str] = &["description"];
impl GroupMovedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupMovedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MOVED_TYPE_FIELDS))
            }
        }
        Ok(GroupMovedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMovedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMovedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMovedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMovedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMovedType", GROUP_MOVED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMovedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMovedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the external ID for group.
#[derive(Debug)]
pub struct GroupRemoveExternalIdDetails {
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupRemoveExternalIdDetails {
    pub fn new(previous_value: super::team_common::GroupExternalId) -> Self {
        GroupRemoveExternalIdDetails {
            previous_value,
        }
    }

}

const GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl GroupRemoveExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRemoveExternalIdDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS))
            }
        }
        Ok(GroupRemoveExternalIdDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveExternalIdDetails", GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupRemoveExternalIdType {
    pub description: String,
}

impl GroupRemoveExternalIdType {
    pub fn new(description: String) -> Self {
        GroupRemoveExternalIdType {
            description,
        }
    }

}

const GROUP_REMOVE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRemoveExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRemoveExternalIdType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_REMOVE_EXTERNAL_ID_TYPE_FIELDS))
            }
        }
        Ok(GroupRemoveExternalIdType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveExternalIdType", GROUP_REMOVE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed team members from a group.
#[derive(Debug)]
pub struct GroupRemoveMemberDetails {
}

impl Default for GroupRemoveMemberDetails {
    fn default() -> Self {
        GroupRemoveMemberDetails {
        }
    }
}

const GROUP_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &[];
impl GroupRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRemoveMemberDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, GROUP_REMOVE_MEMBER_DETAILS_FIELDS));
        }
        Ok(GroupRemoveMemberDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveMemberDetails", GROUP_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupRemoveMemberDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct GroupRemoveMemberType {
    pub description: String,
}

impl GroupRemoveMemberType {
    pub fn new(description: String) -> Self {
        GroupRemoveMemberType {
            description,
        }
    }

}

const GROUP_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRemoveMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_REMOVE_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(GroupRemoveMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveMemberType", GROUP_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed a group.
#[derive(Debug)]
pub struct GroupRenameDetails {
    /// Previous display name.
    pub previous_value: String,
    /// New display name.
    pub new_value: String,
}

impl GroupRenameDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        GroupRenameDetails {
            previous_value,
            new_value,
        }
    }

}

const GROUP_RENAME_DETAILS_FIELDS: &[&str] = &["previous_value",
                                               "new_value"];
impl GroupRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRenameDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(GroupRenameDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRenameDetails", GROUP_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRenameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupRenameType {
    pub description: String,
}

impl GroupRenameType {
    pub fn new(description: String) -> Self {
        GroupRenameType {
            description,
        }
    }

}

const GROUP_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRenameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_RENAME_TYPE_FIELDS))
            }
        }
        Ok(GroupRenameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRenameType", GROUP_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can create groups.
#[derive(Debug)]
pub struct GroupUserManagementChangePolicyDetails {
    /// New group users management policy.
    pub new_value: super::team_policies::GroupCreation,
    /// Previous group users management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::GroupCreation>,
}

impl GroupUserManagementChangePolicyDetails {
    pub fn new(new_value: super::team_policies::GroupCreation) -> Self {
        GroupUserManagementChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::GroupCreation>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl GroupUserManagementChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupUserManagementChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(GroupUserManagementChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUserManagementChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUserManagementChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUserManagementChangePolicyDetails", GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUserManagementChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupUserManagementChangePolicyType {
    pub description: String,
}

impl GroupUserManagementChangePolicyType {
    pub fn new(description: String) -> Self {
        GroupUserManagementChangePolicyType {
            description,
        }
    }

}

const GROUP_USER_MANAGEMENT_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl GroupUserManagementChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupUserManagementChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_USER_MANAGEMENT_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(GroupUserManagementChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUserManagementChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUserManagementChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUserManagementChangePolicyType", GROUP_USER_MANAGEMENT_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUserManagementChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum IdentifierType {
    Email,
    FacebookProfileName,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for IdentifierType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = IdentifierType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a IdentifierType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email" => Ok(IdentifierType::Email),
                    "facebook_profile_name" => Ok(IdentifierType::FacebookProfileName),
                    _ => Ok(IdentifierType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["email",
                                    "facebook_profile_name",
                                    "other"];
        deserializer.deserialize_struct("IdentifierType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for IdentifierType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            IdentifierType::Email => {
                // unit
                let mut s = serializer.serialize_struct("IdentifierType", 1)?;
                s.serialize_field(".tag", "email")?;
                s.end()
            }
            IdentifierType::FacebookProfileName => {
                // unit
                let mut s = serializer.serialize_struct("IdentifierType", 1)?;
                s.serialize_field(".tag", "facebook_profile_name")?;
                s.end()
            }
            IdentifierType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional information relevant when a new member joins the team.
#[derive(Debug)]
pub struct JoinTeamDetails {
    /// Linked applications.
    pub linked_apps: Vec<AppLogInfo>,
    /// Linked devices.
    pub linked_devices: Vec<LinkedDeviceLogInfo>,
    /// Linked shared folders.
    pub linked_shared_folders: Vec<FolderLogInfo>,
}

impl JoinTeamDetails {
    pub fn new(
        linked_apps: Vec<AppLogInfo>,
        linked_devices: Vec<LinkedDeviceLogInfo>,
        linked_shared_folders: Vec<FolderLogInfo>,
    ) -> Self {
        JoinTeamDetails {
            linked_apps,
            linked_devices,
            linked_shared_folders,
        }
    }

}

const JOIN_TEAM_DETAILS_FIELDS: &[&str] = &["linked_apps",
                                            "linked_devices",
                                            "linked_shared_folders"];
impl JoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<JoinTeamDetails, V::Error> {
        use serde::de;
        let mut field_linked_apps = None;
        let mut field_linked_devices = None;
        let mut field_linked_shared_folders = None;
        while let Some(key) = map.next_key()? {
            match key {
                "linked_apps" => {
                    if field_linked_apps.is_some() {
                        return Err(de::Error::duplicate_field("linked_apps"));
                    }
                    field_linked_apps = Some(map.next_value()?);
                }
                "linked_devices" => {
                    if field_linked_devices.is_some() {
                        return Err(de::Error::duplicate_field("linked_devices"));
                    }
                    field_linked_devices = Some(map.next_value()?);
                }
                "linked_shared_folders" => {
                    if field_linked_shared_folders.is_some() {
                        return Err(de::Error::duplicate_field("linked_shared_folders"));
                    }
                    field_linked_shared_folders = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, JOIN_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(JoinTeamDetails {
            linked_apps: field_linked_apps.ok_or_else(|| de::Error::missing_field("linked_apps"))?,
            linked_devices: field_linked_devices.ok_or_else(|| de::Error::missing_field("linked_devices"))?,
            linked_shared_folders: field_linked_shared_folders.ok_or_else(|| de::Error::missing_field("linked_shared_folders"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("linked_apps", &self.linked_apps)?;
        s.serialize_field("linked_devices", &self.linked_devices)?;
        s.serialize_field("linked_shared_folders", &self.linked_shared_folders)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for JoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = JoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a JoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                JoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("JoinTeamDetails", JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for JoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("JoinTeamDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information on sessions, in legacy format
#[derive(Debug)]
pub struct LegacyDeviceSessionLogInfo {
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Is device managed by emm. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
    /// Information on the hosting platform. Might be missing due to historical data gap.
    pub platform: Option<String>,
    /// The mac address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub mac_address: Option<IpAddress>,
    /// The hosting OS version. Might be missing due to historical data gap.
    pub os_version: Option<String>,
    /// Information on the hosting device type. Might be missing due to historical data gap.
    pub device_type: Option<String>,
    /// The Dropbox client version. Might be missing due to historical data gap.
    pub client_version: Option<String>,
    /// Alternative unique device session id, instead of session id field. Might be missing due to
    /// historical data gap.
    pub legacy_uniq_id: Option<String>,
}

impl Default for LegacyDeviceSessionLogInfo {
    fn default() -> Self {
        LegacyDeviceSessionLogInfo {
            session_id: None,
            ip_address: None,
            created: None,
            updated: None,
            display_name: None,
            is_emm_managed: None,
            platform: None,
            mac_address: None,
            os_version: None,
            device_type: None,
            client_version: None,
            legacy_uniq_id: None,
        }
    }
}

const LEGACY_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id",
                                                         "ip_address",
                                                         "created",
                                                         "updated",
                                                         "display_name",
                                                         "is_emm_managed",
                                                         "platform",
                                                         "mac_address",
                                                         "os_version",
                                                         "device_type",
                                                         "client_version",
                                                         "legacy_uniq_id"];
impl LegacyDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LegacyDeviceSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_display_name = None;
        let mut field_is_emm_managed = None;
        let mut field_platform = None;
        let mut field_mac_address = None;
        let mut field_os_version = None;
        let mut field_device_type = None;
        let mut field_client_version = None;
        let mut field_legacy_uniq_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "mac_address" => {
                    if field_mac_address.is_some() {
                        return Err(de::Error::duplicate_field("mac_address"));
                    }
                    field_mac_address = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "legacy_uniq_id" => {
                    if field_legacy_uniq_id.is_some() {
                        return Err(de::Error::duplicate_field("legacy_uniq_id"));
                    }
                    field_legacy_uniq_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LEGACY_DEVICE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(LegacyDeviceSessionLogInfo {
            session_id: field_session_id,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            display_name: field_display_name,
            is_emm_managed: field_is_emm_managed,
            platform: field_platform,
            mac_address: field_mac_address,
            os_version: field_os_version,
            device_type: field_device_type,
            client_version: field_client_version,
            legacy_uniq_id: field_legacy_uniq_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("mac_address", &self.mac_address)?;
        s.serialize_field("os_version", &self.os_version)?;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("legacy_uniq_id", &self.legacy_uniq_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegacyDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegacyDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LegacyDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegacyDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegacyDeviceSessionLogInfo", LEGACY_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegacyDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegacyDeviceSessionLogInfo", 12)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked Device's logged information.
#[derive(Debug)]
pub struct LinkedDeviceLogInfo {
    /// Device type.
    pub device_type: String,
    /// Device display name.
    pub display_name: Option<String>,
    /// The IP address of the last activity from this device.
    pub ip_address: Option<IpAddress>,
    /// Last activity.
    pub last_activity: Option<String>,
    /// Device platform name.
    pub platform: Option<String>,
}

impl LinkedDeviceLogInfo {
    pub fn new(device_type: String) -> Self {
        LinkedDeviceLogInfo {
            device_type,
            display_name: None,
            ip_address: None,
            last_activity: None,
            platform: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_last_activity(mut self, value: Option<String>) -> Self {
        self.last_activity = value;
        self
    }

    pub fn with_platform(mut self, value: Option<String>) -> Self {
        self.platform = value;
        self
    }

}

const LINKED_DEVICE_LOG_INFO_FIELDS: &[&str] = &["device_type",
                                                 "display_name",
                                                 "ip_address",
                                                 "last_activity",
                                                 "platform"];
impl LinkedDeviceLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LinkedDeviceLogInfo, V::Error> {
        use serde::de;
        let mut field_device_type = None;
        let mut field_display_name = None;
        let mut field_ip_address = None;
        let mut field_last_activity = None;
        let mut field_platform = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "last_activity" => {
                    if field_last_activity.is_some() {
                        return Err(de::Error::duplicate_field("last_activity"));
                    }
                    field_last_activity = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LINKED_DEVICE_LOG_INFO_FIELDS))
            }
        }
        Ok(LinkedDeviceLogInfo {
            device_type: field_device_type.ok_or_else(|| de::Error::missing_field("device_type"))?,
            display_name: field_display_name,
            ip_address: field_ip_address,
            last_activity: field_last_activity,
            platform: field_platform,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("last_activity", &self.last_activity)?;
        s.serialize_field("platform", &self.platform)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LinkedDeviceLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LinkedDeviceLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkedDeviceLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LinkedDeviceLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LinkedDeviceLogInfo", LINKED_DEVICE_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LinkedDeviceLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LinkedDeviceLogInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in.
#[derive(Debug)]
pub struct LoginFailDetails {
    /// Login method.
    pub login_method: LoginMethod,
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
    /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
}

impl LoginFailDetails {
    pub fn new(login_method: LoginMethod, error_details: FailureDetailsLogInfo) -> Self {
        LoginFailDetails {
            login_method,
            error_details,
            is_emm_managed: None,
        }
    }

    pub fn with_is_emm_managed(mut self, value: Option<bool>) -> Self {
        self.is_emm_managed = value;
        self
    }

}

const LOGIN_FAIL_DETAILS_FIELDS: &[&str] = &["login_method",
                                             "error_details",
                                             "is_emm_managed"];
impl LoginFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LoginFailDetails, V::Error> {
        use serde::de;
        let mut field_login_method = None;
        let mut field_error_details = None;
        let mut field_is_emm_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "login_method" => {
                    if field_login_method.is_some() {
                        return Err(de::Error::duplicate_field("login_method"));
                    }
                    field_login_method = Some(map.next_value()?);
                }
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LOGIN_FAIL_DETAILS_FIELDS))
            }
        }
        Ok(LoginFailDetails {
            login_method: field_login_method.ok_or_else(|| de::Error::missing_field("login_method"))?,
            error_details: field_error_details.ok_or_else(|| de::Error::missing_field("error_details"))?,
            is_emm_managed: field_is_emm_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("login_method", &self.login_method)?;
        s.serialize_field("error_details", &self.error_details)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LoginFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginFailDetails", LOGIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginFailDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LoginFailType {
    pub description: String,
}

impl LoginFailType {
    pub fn new(description: String) -> Self {
        LoginFailType {
            description,
        }
    }

}

const LOGIN_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl LoginFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LoginFailType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LOGIN_FAIL_TYPE_FIELDS))
            }
        }
        Ok(LoginFailType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LoginFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginFailType", LOGIN_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum LoginMethod {
    Password,
    TwoFactorAuthentication,
    Saml,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LoginMethod {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LoginMethod;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LoginMethod structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "password" => Ok(LoginMethod::Password),
                    "two_factor_authentication" => Ok(LoginMethod::TwoFactorAuthentication),
                    "saml" => Ok(LoginMethod::Saml),
                    _ => Ok(LoginMethod::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["password",
                                    "two_factor_authentication",
                                    "saml",
                                    "other"];
        deserializer.deserialize_struct("LoginMethod", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LoginMethod {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LoginMethod::Password => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            LoginMethod::TwoFactorAuthentication => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "two_factor_authentication")?;
                s.end()
            }
            LoginMethod::Saml => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "saml")?;
                s.end()
            }
            LoginMethod::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Signed in.
#[derive(Debug)]
pub struct LoginSuccessDetails {
    /// Login method.
    pub login_method: LoginMethod,
    /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
}

impl LoginSuccessDetails {
    pub fn new(login_method: LoginMethod) -> Self {
        LoginSuccessDetails {
            login_method,
            is_emm_managed: None,
        }
    }

    pub fn with_is_emm_managed(mut self, value: Option<bool>) -> Self {
        self.is_emm_managed = value;
        self
    }

}

const LOGIN_SUCCESS_DETAILS_FIELDS: &[&str] = &["login_method",
                                                "is_emm_managed"];
impl LoginSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LoginSuccessDetails, V::Error> {
        use serde::de;
        let mut field_login_method = None;
        let mut field_is_emm_managed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "login_method" => {
                    if field_login_method.is_some() {
                        return Err(de::Error::duplicate_field("login_method"));
                    }
                    field_login_method = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LOGIN_SUCCESS_DETAILS_FIELDS))
            }
        }
        Ok(LoginSuccessDetails {
            login_method: field_login_method.ok_or_else(|| de::Error::missing_field("login_method"))?,
            is_emm_managed: field_is_emm_managed,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("login_method", &self.login_method)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LoginSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginSuccessDetails", LOGIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LoginSuccessType {
    pub description: String,
}

impl LoginSuccessType {
    pub fn new(description: String) -> Self {
        LoginSuccessType {
            description,
        }
    }

}

const LOGIN_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl LoginSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LoginSuccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LOGIN_SUCCESS_TYPE_FIELDS))
            }
        }
        Ok(LoginSuccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LoginSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginSuccessType", LOGIN_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Signed out.
#[derive(Debug)]
pub struct LogoutDetails {
}

impl Default for LogoutDetails {
    fn default() -> Self {
        LogoutDetails {
        }
    }
}

const LOGOUT_DETAILS_FIELDS: &[&str] = &[];
impl LogoutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LogoutDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, LOGOUT_DETAILS_FIELDS));
        }
        Ok(LogoutDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LogoutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LogoutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LogoutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LogoutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LogoutDetails", LOGOUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LogoutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("LogoutDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct LogoutType {
    pub description: String,
}

impl LogoutType {
    pub fn new(description: String) -> Self {
        LogoutType {
            description,
        }
    }

}

const LOGOUT_TYPE_FIELDS: &[&str] = &["description"];
impl LogoutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LogoutType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LOGOUT_TYPE_FIELDS))
            }
        }
        Ok(LogoutType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LogoutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LogoutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LogoutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LogoutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LogoutType", LOGOUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LogoutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LogoutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Specify team member name.
#[derive(Debug)]
pub struct MemberAddNameDetails {
    /// New user's name.
    pub new_value: UserNameLogInfo,
}

impl MemberAddNameDetails {
    pub fn new(new_value: UserNameLogInfo) -> Self {
        MemberAddNameDetails {
            new_value,
        }
    }

}

const MEMBER_ADD_NAME_DETAILS_FIELDS: &[&str] = &["new_value"];
impl MemberAddNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberAddNameDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ADD_NAME_DETAILS_FIELDS))
            }
        }
        Ok(MemberAddNameDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAddNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddNameDetails", MEMBER_ADD_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddNameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberAddNameType {
    pub description: String,
}

impl MemberAddNameType {
    pub fn new(description: String) -> Self {
        MemberAddNameType {
            description,
        }
    }

}

const MEMBER_ADD_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl MemberAddNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberAddNameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ADD_NAME_TYPE_FIELDS))
            }
        }
        Ok(MemberAddNameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAddNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddNameType", MEMBER_ADD_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the admin role belonging to team member.
#[derive(Debug)]
pub struct MemberChangeAdminRoleDetails {
    /// New admin role. This field is relevant when the admin role is changed or whenthe user role
    /// changes from no admin rights to with admin rights.
    pub new_value: Option<AdminRole>,
    /// Previous admin role. This field is relevant when the admin role is changed or when the admin
    /// role is removed.
    pub previous_value: Option<AdminRole>,
}

impl Default for MemberChangeAdminRoleDetails {
    fn default() -> Self {
        MemberChangeAdminRoleDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl MemberChangeAdminRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeAdminRoleDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeAdminRoleDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeAdminRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeAdminRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeAdminRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeAdminRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeAdminRoleDetails", MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeAdminRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeAdminRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeAdminRoleType {
    pub description: String,
}

impl MemberChangeAdminRoleType {
    pub fn new(description: String) -> Self {
        MemberChangeAdminRoleType {
            description,
        }
    }

}

const MEMBER_CHANGE_ADMIN_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeAdminRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeAdminRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_ADMIN_ROLE_TYPE_FIELDS))
            }
        }
        Ok(MemberChangeAdminRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeAdminRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeAdminRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeAdminRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeAdminRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeAdminRoleType", MEMBER_CHANGE_ADMIN_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeAdminRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeAdminRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member email address.
#[derive(Debug)]
pub struct MemberChangeEmailDetails {
    /// New email.
    pub new_value: EmailAddress,
    /// Previous email. Might be missing due to historical data gap.
    pub previous_value: Option<EmailAddress>,
}

impl MemberChangeEmailDetails {
    pub fn new(new_value: EmailAddress) -> Self {
        MemberChangeEmailDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<EmailAddress>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_CHANGE_EMAIL_DETAILS_FIELDS: &[&str] = &["new_value",
                                                      "previous_value"];
impl MemberChangeEmailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeEmailDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_EMAIL_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeEmailDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeEmailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeEmailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeEmailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeEmailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeEmailDetails", MEMBER_CHANGE_EMAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeEmailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeEmailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeEmailType {
    pub description: String,
}

impl MemberChangeEmailType {
    pub fn new(description: String) -> Self {
        MemberChangeEmailType {
            description,
        }
    }

}

const MEMBER_CHANGE_EMAIL_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeEmailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeEmailType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_EMAIL_TYPE_FIELDS))
            }
        }
        Ok(MemberChangeEmailType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeEmailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeEmailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeEmailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeEmailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeEmailType", MEMBER_CHANGE_EMAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeEmailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeEmailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the membership type (limited vs full) for team member.
#[derive(Debug)]
pub struct MemberChangeMembershipTypeDetails {
    /// Previous membership type.
    pub prev_value: TeamMembershipType,
    /// New membership type.
    pub new_value: TeamMembershipType,
}

impl MemberChangeMembershipTypeDetails {
    pub fn new(prev_value: TeamMembershipType, new_value: TeamMembershipType) -> Self {
        MemberChangeMembershipTypeDetails {
            prev_value,
            new_value,
        }
    }

}

const MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS: &[&str] = &["prev_value",
                                                                "new_value"];
impl MemberChangeMembershipTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeMembershipTypeDetails, V::Error> {
        use serde::de;
        let mut field_prev_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "prev_value" => {
                    if field_prev_value.is_some() {
                        return Err(de::Error::duplicate_field("prev_value"));
                    }
                    field_prev_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeMembershipTypeDetails {
            prev_value: field_prev_value.ok_or_else(|| de::Error::missing_field("prev_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("prev_value", &self.prev_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeMembershipTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeMembershipTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeMembershipTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeMembershipTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeMembershipTypeDetails", MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeMembershipTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeMembershipTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeMembershipTypeType {
    pub description: String,
}

impl MemberChangeMembershipTypeType {
    pub fn new(description: String) -> Self {
        MemberChangeMembershipTypeType {
            description,
        }
    }

}

const MEMBER_CHANGE_MEMBERSHIP_TYPE_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeMembershipTypeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeMembershipTypeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_MEMBERSHIP_TYPE_TYPE_FIELDS))
            }
        }
        Ok(MemberChangeMembershipTypeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeMembershipTypeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeMembershipTypeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeMembershipTypeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeMembershipTypeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeMembershipTypeType", MEMBER_CHANGE_MEMBERSHIP_TYPE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeMembershipTypeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeMembershipTypeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member name.
#[derive(Debug)]
pub struct MemberChangeNameDetails {
    /// New user's name.
    pub new_value: UserNameLogInfo,
    /// Previous user's name. Might be missing due to historical data gap.
    pub previous_value: Option<UserNameLogInfo>,
}

impl MemberChangeNameDetails {
    pub fn new(new_value: UserNameLogInfo) -> Self {
        MemberChangeNameDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<UserNameLogInfo>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_CHANGE_NAME_DETAILS_FIELDS: &[&str] = &["new_value",
                                                     "previous_value"];
impl MemberChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeNameDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_NAME_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeNameDetails", MEMBER_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeNameType {
    pub description: String,
}

impl MemberChangeNameType {
    pub fn new(description: String) -> Self {
        MemberChangeNameType {
            description,
        }
    }

}

const MEMBER_CHANGE_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeNameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_NAME_TYPE_FIELDS))
            }
        }
        Ok(MemberChangeNameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeNameType", MEMBER_CHANGE_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the membership status of a team member.
#[derive(Debug)]
pub struct MemberChangeStatusDetails {
    /// New member status.
    pub new_value: MemberStatus,
    /// Previous member status. Might be missing due to historical data gap.
    pub previous_value: Option<MemberStatus>,
    /// Additional information indicating the action taken that caused status change.
    pub action: Option<ActionDetails>,
}

impl MemberChangeStatusDetails {
    pub fn new(new_value: MemberStatus) -> Self {
        MemberChangeStatusDetails {
            new_value,
            previous_value: None,
            action: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberStatus>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_action(mut self, value: Option<ActionDetails>) -> Self {
        self.action = value;
        self
    }

}

const MEMBER_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                       "previous_value",
                                                       "action"];
impl MemberChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_action = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "action" => {
                    if field_action.is_some() {
                        return Err(de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(MemberChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            action: field_action,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("action", &self.action)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeStatusDetails", MEMBER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeStatusType {
    pub description: String,
}

impl MemberChangeStatusType {
    pub fn new(description: String) -> Self {
        MemberChangeStatusType {
            description,
        }
    }

}

const MEMBER_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeStatusType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_CHANGE_STATUS_TYPE_FIELDS))
            }
        }
        Ok(MemberChangeStatusType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeStatusType", MEMBER_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted contents of a removed team member account.
#[derive(Debug)]
pub struct MemberPermanentlyDeleteAccountContentsDetails {
}

impl Default for MemberPermanentlyDeleteAccountContentsDetails {
    fn default() -> Self {
        MemberPermanentlyDeleteAccountContentsDetails {
        }
    }
}

const MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS: &[&str] = &[];
impl MemberPermanentlyDeleteAccountContentsDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberPermanentlyDeleteAccountContentsDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS));
        }
        Ok(MemberPermanentlyDeleteAccountContentsDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermanentlyDeleteAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermanentlyDeleteAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberPermanentlyDeleteAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermanentlyDeleteAccountContentsDetails", MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermanentlyDeleteAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberPermanentlyDeleteAccountContentsDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberPermanentlyDeleteAccountContentsType {
    pub description: String,
}

impl MemberPermanentlyDeleteAccountContentsType {
    pub fn new(description: String) -> Self {
        MemberPermanentlyDeleteAccountContentsType {
            description,
        }
    }

}

const MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberPermanentlyDeleteAccountContentsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberPermanentlyDeleteAccountContentsType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_TYPE_FIELDS))
            }
        }
        Ok(MemberPermanentlyDeleteAccountContentsType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermanentlyDeleteAccountContentsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermanentlyDeleteAccountContentsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberPermanentlyDeleteAccountContentsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermanentlyDeleteAccountContentsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermanentlyDeleteAccountContentsType", MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermanentlyDeleteAccountContentsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberPermanentlyDeleteAccountContentsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberRemoveActionType {
    Delete,
    Offboard,
    Leave,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRemoveActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberRemoveActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRemoveActionType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "delete" => Ok(MemberRemoveActionType::Delete),
                    "offboard" => Ok(MemberRemoveActionType::Offboard),
                    "leave" => Ok(MemberRemoveActionType::Leave),
                    _ => Ok(MemberRemoveActionType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["delete",
                                    "offboard",
                                    "leave",
                                    "other"];
        deserializer.deserialize_struct("MemberRemoveActionType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRemoveActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberRemoveActionType::Delete => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "delete")?;
                s.end()
            }
            MemberRemoveActionType::Offboard => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "offboard")?;
                s.end()
            }
            MemberRemoveActionType::Leave => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "leave")?;
                s.end()
            }
            MemberRemoveActionType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed whether users can find the team when not invited.
#[derive(Debug)]
pub struct MemberRequestsChangePolicyDetails {
    /// New member change requests policy.
    pub new_value: MemberRequestsPolicy,
    /// Previous member change requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberRequestsPolicy>,
}

impl MemberRequestsChangePolicyDetails {
    pub fn new(new_value: MemberRequestsPolicy) -> Self {
        MemberRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl MemberRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberRequestsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRequestsChangePolicyDetails", MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberRequestsChangePolicyType {
    pub description: String,
}

impl MemberRequestsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberRequestsChangePolicyType {
            description,
        }
    }

}

const MEMBER_REQUESTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberRequestsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberRequestsChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_REQUESTS_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(MemberRequestsChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRequestsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRequestsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRequestsChangePolicyType", MEMBER_REQUESTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRequestsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberRequestsPolicy {
    AutoAccept,
    Disabled,
    RequireApproval,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "auto_accept" => Ok(MemberRequestsPolicy::AutoAccept),
                    "disabled" => Ok(MemberRequestsPolicy::Disabled),
                    "require_approval" => Ok(MemberRequestsPolicy::RequireApproval),
                    _ => Ok(MemberRequestsPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["auto_accept",
                                    "disabled",
                                    "require_approval",
                                    "other"];
        deserializer.deserialize_struct("MemberRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberRequestsPolicy::AutoAccept => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "auto_accept")?;
                s.end()
            }
            MemberRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberRequestsPolicy::RequireApproval => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "require_approval")?;
                s.end()
            }
            MemberRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Set custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsAddCustomQuotaDetails {
    /// New custom quota value in bytes.
    pub new_value: u64,
}

impl MemberSpaceLimitsAddCustomQuotaDetails {
    pub fn new(new_value: u64) -> Self {
        MemberSpaceLimitsAddCustomQuotaDetails {
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &["new_value"];
impl MemberSpaceLimitsAddCustomQuotaDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsAddCustomQuotaDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsAddCustomQuotaDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddCustomQuotaDetails", MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddCustomQuotaDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsAddCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsAddCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsAddCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsAddCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsAddCustomQuotaType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsAddCustomQuotaType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddCustomQuotaType", MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an exception for one or more team members to bypass space limits imposed by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsAddExceptionDetails {
}

impl Default for MemberSpaceLimitsAddExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsAddExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsAddExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsAddExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(MemberSpaceLimitsAddExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddExceptionDetails", MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsAddExceptionType {
    pub description: String,
}

impl MemberSpaceLimitsAddExceptionType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsAddExceptionType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsAddExceptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_ADD_EXCEPTION_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsAddExceptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddExceptionType", MEMBER_SPACE_LIMITS_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the member space limit type for the team.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCapsTypePolicyDetails {
    /// Previous space limit type.
    pub previous_value: SpaceCapsType,
    /// New space limit type.
    pub new_value: SpaceCapsType,
}

impl MemberSpaceLimitsChangeCapsTypePolicyDetails {
    pub fn new(previous_value: SpaceCapsType, new_value: SpaceCapsType) -> Self {
        MemberSpaceLimitsChangeCapsTypePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                              "new_value"];
impl MemberSpaceLimitsChangeCapsTypePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeCapsTypePolicyDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeCapsTypePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCapsTypePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCapsTypePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCapsTypePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCapsTypePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCapsTypePolicyDetails", MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCapsTypePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCapsTypePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCapsTypePolicyType {
    pub description: String,
}

impl MemberSpaceLimitsChangeCapsTypePolicyType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeCapsTypePolicyType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeCapsTypePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeCapsTypePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeCapsTypePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCapsTypePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCapsTypePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCapsTypePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCapsTypePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCapsTypePolicyType", MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCapsTypePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCapsTypePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCustomQuotaDetails {
    /// Previous custom quota value in bytes.
    pub previous_value: u64,
    /// New custom quota value in bytes.
    pub new_value: u64,
}

impl MemberSpaceLimitsChangeCustomQuotaDetails {
    pub fn new(previous_value: u64, new_value: u64) -> Self {
        MemberSpaceLimitsChangeCustomQuotaDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                          "new_value"];
impl MemberSpaceLimitsChangeCustomQuotaDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeCustomQuotaDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeCustomQuotaDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCustomQuotaDetails", MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCustomQuotaDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsChangeCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeCustomQuotaType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeCustomQuotaType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCustomQuotaType", MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the team default limit level.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangePolicyDetails {
    /// Previous team default limit value in bytes. Might be missing due to historical data gap.
    pub previous_value: Option<u64>,
    /// New team default limit value in bytes. Might be missing due to historical data gap.
    pub new_value: Option<u64>,
}

impl Default for MemberSpaceLimitsChangePolicyDetails {
    fn default() -> Self {
        MemberSpaceLimitsChangePolicyDetails {
            previous_value: None,
            new_value: None,
        }
    }
}

const MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                    "new_value"];
impl MemberSpaceLimitsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangePolicyDetails {
            previous_value: field_previous_value,
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangePolicyDetails", MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangePolicyType {
    pub description: String,
}

impl MemberSpaceLimitsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangePolicyType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangePolicyType", MEMBER_SPACE_LIMITS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the status with respect to whether the team member is under or over storage quota
/// specified by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeStatusDetails {
    /// Previous storage quota status.
    pub previous_value: SpaceLimitsStatus,
    /// New storage quota status.
    pub new_value: SpaceLimitsStatus,
}

impl MemberSpaceLimitsChangeStatusDetails {
    pub fn new(previous_value: SpaceLimitsStatus, new_value: SpaceLimitsStatus) -> Self {
        MemberSpaceLimitsChangeStatusDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                    "new_value"];
impl MemberSpaceLimitsChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeStatusDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeStatusDetails", MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeStatusType {
    pub description: String,
}

impl MemberSpaceLimitsChangeStatusType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeStatusType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangeStatusType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_CHANGE_STATUS_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsChangeStatusType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeStatusType", MEMBER_SPACE_LIMITS_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveCustomQuotaDetails {
}

impl Default for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn default() -> Self {
        MemberSpaceLimitsRemoveCustomQuotaDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsRemoveCustomQuotaDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveCustomQuotaDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_DETAILS_FIELDS));
        }
        Ok(MemberSpaceLimitsRemoveCustomQuotaDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveCustomQuotaDetails", MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsRemoveCustomQuotaDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsRemoveCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsRemoveCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsRemoveCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveCustomQuotaType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsRemoveCustomQuotaType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveCustomQuotaType", MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsRemoveCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed an exception for one or more team members to bypass space limits imposed by policy.
#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveExceptionDetails {
}

impl Default for MemberSpaceLimitsRemoveExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsRemoveExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsRemoveExceptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveExceptionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS));
        }
        Ok(MemberSpaceLimitsRemoveExceptionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveExceptionDetails", MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveExceptionType {
    pub description: String,
}

impl MemberSpaceLimitsRemoveExceptionType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsRemoveExceptionType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveExceptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_TYPE_FIELDS))
            }
        }
        Ok(MemberSpaceLimitsRemoveExceptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveExceptionType", MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberStatus {
    NotJoined,
    Invited,
    Active,
    Suspended,
    Removed,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "not_joined" => Ok(MemberStatus::NotJoined),
                    "invited" => Ok(MemberStatus::Invited),
                    "active" => Ok(MemberStatus::Active),
                    "suspended" => Ok(MemberStatus::Suspended),
                    "removed" => Ok(MemberStatus::Removed),
                    _ => Ok(MemberStatus::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["not_joined",
                                    "invited",
                                    "active",
                                    "suspended",
                                    "removed",
                                    "other"];
        deserializer.deserialize_struct("MemberStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberStatus::NotJoined => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "not_joined")?;
                s.end()
            }
            MemberStatus::Invited => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            MemberStatus::Active => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            MemberStatus::Suspended => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "suspended")?;
                s.end()
            }
            MemberStatus::Removed => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "removed")?;
                s.end()
            }
            MemberStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Suggested a new team member to be added to the team.
#[derive(Debug)]
pub struct MemberSuggestDetails {
    /// suggested users emails.
    pub suggested_members: Vec<EmailAddress>,
}

impl MemberSuggestDetails {
    pub fn new(suggested_members: Vec<EmailAddress>) -> Self {
        MemberSuggestDetails {
            suggested_members,
        }
    }

}

const MEMBER_SUGGEST_DETAILS_FIELDS: &[&str] = &["suggested_members"];
impl MemberSuggestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSuggestDetails, V::Error> {
        use serde::de;
        let mut field_suggested_members = None;
        while let Some(key) = map.next_key()? {
            match key {
                "suggested_members" => {
                    if field_suggested_members.is_some() {
                        return Err(de::Error::duplicate_field("suggested_members"));
                    }
                    field_suggested_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SUGGEST_DETAILS_FIELDS))
            }
        }
        Ok(MemberSuggestDetails {
            suggested_members: field_suggested_members.ok_or_else(|| de::Error::missing_field("suggested_members"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("suggested_members", &self.suggested_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestDetails", MEMBER_SUGGEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSuggestType {
    pub description: String,
}

impl MemberSuggestType {
    pub fn new(description: String) -> Self {
        MemberSuggestType {
            description,
        }
    }

}

const MEMBER_SUGGEST_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSuggestType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSuggestType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SUGGEST_TYPE_FIELDS))
            }
        }
        Ok(MemberSuggestType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestType", MEMBER_SUGGEST_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled the option for team members to suggest new members to add to the team.
#[derive(Debug)]
pub struct MemberSuggestionsChangePolicyDetails {
    /// New team member suggestions policy.
    pub new_value: MemberSuggestionsPolicy,
    /// Previous team member suggestions policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberSuggestionsPolicy>,
}

impl MemberSuggestionsChangePolicyDetails {
    pub fn new(new_value: MemberSuggestionsPolicy) -> Self {
        MemberSuggestionsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberSuggestionsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl MemberSuggestionsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSuggestionsChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MemberSuggestionsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestionsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestionsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestionsChangePolicyDetails", MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestionsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSuggestionsChangePolicyType {
    pub description: String,
}

impl MemberSuggestionsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberSuggestionsChangePolicyType {
            description,
        }
    }

}

const MEMBER_SUGGESTIONS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSuggestionsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSuggestionsChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_SUGGESTIONS_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(MemberSuggestionsChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestionsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestionsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestionsChangePolicyType", MEMBER_SUGGESTIONS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestionsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Member suggestions policy
#[derive(Debug)]
pub enum MemberSuggestionsPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSuggestionsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(MemberSuggestionsPolicy::Disabled),
                    "enabled" => Ok(MemberSuggestionsPolicy::Enabled),
                    _ => Ok(MemberSuggestionsPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("MemberSuggestionsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSuggestionsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Transferred contents of a removed team member account to another member.
#[derive(Debug)]
pub struct MemberTransferAccountContentsDetails {
}

impl Default for MemberTransferAccountContentsDetails {
    fn default() -> Self {
        MemberTransferAccountContentsDetails {
        }
    }
}

const MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS: &[&str] = &[];
impl MemberTransferAccountContentsDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberTransferAccountContentsDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS));
        }
        Ok(MemberTransferAccountContentsDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberTransferAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberTransferAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberTransferAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberTransferAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberTransferAccountContentsDetails", MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberTransferAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberTransferAccountContentsDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberTransferAccountContentsType {
    pub description: String,
}

impl MemberTransferAccountContentsType {
    pub fn new(description: String) -> Self {
        MemberTransferAccountContentsType {
            description,
        }
    }

}

const MEMBER_TRANSFER_ACCOUNT_CONTENTS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberTransferAccountContentsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberTransferAccountContentsType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_TRANSFER_ACCOUNT_CONTENTS_TYPE_FIELDS))
            }
        }
        Ok(MemberTransferAccountContentsType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberTransferAccountContentsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberTransferAccountContentsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberTransferAccountContentsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberTransferAccountContentsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberTransferAccountContentsType", MEMBER_TRANSFER_ACCOUNT_CONTENTS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberTransferAccountContentsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberTransferAccountContentsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled the Microsoft Office add-in, which lets team members save files to Dropbox
/// directly from Microsoft Office.
#[derive(Debug)]
pub struct MicrosoftOfficeAddinChangePolicyDetails {
    /// New Microsoft Office addin policy.
    pub new_value: MicrosoftOfficeAddinPolicy,
    /// Previous Microsoft Office addin policy. Might be missing due to historical data gap.
    pub previous_value: Option<MicrosoftOfficeAddinPolicy>,
}

impl MicrosoftOfficeAddinChangePolicyDetails {
    pub fn new(new_value: MicrosoftOfficeAddinPolicy) -> Self {
        MicrosoftOfficeAddinChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MicrosoftOfficeAddinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                       "previous_value"];
impl MicrosoftOfficeAddinChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MicrosoftOfficeAddinChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(MicrosoftOfficeAddinChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MicrosoftOfficeAddinChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MicrosoftOfficeAddinChangePolicyDetails", MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MicrosoftOfficeAddinChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MicrosoftOfficeAddinChangePolicyType {
    pub description: String,
}

impl MicrosoftOfficeAddinChangePolicyType {
    pub fn new(description: String) -> Self {
        MicrosoftOfficeAddinChangePolicyType {
            description,
        }
    }

}

const MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MicrosoftOfficeAddinChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MicrosoftOfficeAddinChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(MicrosoftOfficeAddinChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MicrosoftOfficeAddinChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MicrosoftOfficeAddinChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MicrosoftOfficeAddinChangePolicyType", MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MicrosoftOfficeAddinChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Microsoft Office addin policy
#[derive(Debug)]
pub enum MicrosoftOfficeAddinPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MicrosoftOfficeAddinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(MicrosoftOfficeAddinPolicy::Disabled),
                    "enabled" => Ok(MicrosoftOfficeAddinPolicy::Enabled),
                    _ => Ok(MicrosoftOfficeAddinPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("MicrosoftOfficeAddinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MicrosoftOfficeAddinPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// An indication that an error occurred while retrieving the event. Some attributes of the event
/// may be omitted as a result.
#[derive(Debug)]
pub struct MissingDetails {
    /// All the data that could be retrieved and converted from the source event.
    pub source_event_fields: Option<String>,
}

impl Default for MissingDetails {
    fn default() -> Self {
        MissingDetails {
            source_event_fields: None,
        }
    }
}

const MISSING_DETAILS_FIELDS: &[&str] = &["source_event_fields"];
impl MissingDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MissingDetails, V::Error> {
        use serde::de;
        let mut field_source_event_fields = None;
        while let Some(key) = map.next_key()? {
            match key {
                "source_event_fields" => {
                    if field_source_event_fields.is_some() {
                        return Err(de::Error::duplicate_field("source_event_fields"));
                    }
                    field_source_event_fields = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MISSING_DETAILS_FIELDS))
            }
        }
        Ok(MissingDetails {
            source_event_fields: field_source_event_fields,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("source_event_fields", &self.source_event_fields)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MissingDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MissingDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MissingDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MissingDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MissingDetails", MISSING_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MissingDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MissingDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about linked Dropbox mobile client sessions
#[derive(Debug)]
pub struct MobileDeviceSessionLogInfo {
    /// The device name.
    pub device_name: String,
    /// The mobile application type.
    pub client_type: super::team::MobileClientPlatform,
    /// The Dropbox client version.
    pub client_version: String,
    /// last carrier used by the device.
    pub last_carrier: String,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// The hosting OS version.
    pub os_version: Option<String>,
}

impl MobileDeviceSessionLogInfo {
    pub fn new(
        device_name: String,
        client_type: super::team::MobileClientPlatform,
        client_version: String,
        last_carrier: String,
    ) -> Self {
        MobileDeviceSessionLogInfo {
            device_name,
            client_type,
            client_version,
            last_carrier,
            session_id: None,
            ip_address: None,
            created: None,
            updated: None,
            os_version: None,
        }
    }

    pub fn with_session_id(mut self, value: Option<DeviceSessionId>) -> Self {
        self.session_id = value;
        self
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_os_version(mut self, value: Option<String>) -> Self {
        self.os_version = value;
        self
    }

}

const MOBILE_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["device_name",
                                                         "client_type",
                                                         "client_version",
                                                         "last_carrier",
                                                         "session_id",
                                                         "ip_address",
                                                         "created",
                                                         "updated",
                                                         "os_version"];
impl MobileDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MobileDeviceSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_device_name = None;
        let mut field_client_type = None;
        let mut field_client_version = None;
        let mut field_last_carrier = None;
        let mut field_session_id = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_os_version = None;
        while let Some(key) = map.next_key()? {
            match key {
                "device_name" => {
                    if field_device_name.is_some() {
                        return Err(de::Error::duplicate_field("device_name"));
                    }
                    field_device_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "last_carrier" => {
                    if field_last_carrier.is_some() {
                        return Err(de::Error::duplicate_field("last_carrier"));
                    }
                    field_last_carrier = Some(map.next_value()?);
                }
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MOBILE_DEVICE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(MobileDeviceSessionLogInfo {
            device_name: field_device_name.ok_or_else(|| de::Error::missing_field("device_name"))?,
            client_type: field_client_type.ok_or_else(|| de::Error::missing_field("client_type"))?,
            client_version: field_client_version.ok_or_else(|| de::Error::missing_field("client_version"))?,
            last_carrier: field_last_carrier.ok_or_else(|| de::Error::missing_field("last_carrier"))?,
            session_id: field_session_id,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            os_version: field_os_version,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_name", &self.device_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("last_carrier", &self.last_carrier)?;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("os_version", &self.os_version)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MobileDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileDeviceSessionLogInfo", MOBILE_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileDeviceSessionLogInfo", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Mobile session.
#[derive(Debug)]
pub struct MobileSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for MobileSessionLogInfo {
    fn default() -> Self {
        MobileSessionLogInfo {
            session_id: None,
        }
    }
}

const MOBILE_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl MobileSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MobileSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MOBILE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(MobileSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MobileSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileSessionLogInfo", MOBILE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Namespace relative path details.
#[derive(Debug)]
pub struct NamespaceRelativePathLogInfo {
    /// Namespace ID. Might be missing due to historical data gap.
    pub ns_id: Option<NamespaceId>,
    /// A path relative to the specified namespace ID. Might be missing due to historical data gap.
    pub relative_path: Option<FilePath>,
}

impl Default for NamespaceRelativePathLogInfo {
    fn default() -> Self {
        NamespaceRelativePathLogInfo {
            ns_id: None,
            relative_path: None,
        }
    }
}

const NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS: &[&str] = &["ns_id",
                                                           "relative_path"];
impl NamespaceRelativePathLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NamespaceRelativePathLogInfo, V::Error> {
        use serde::de;
        let mut field_ns_id = None;
        let mut field_relative_path = None;
        while let Some(key) = map.next_key()? {
            match key {
                "ns_id" => {
                    if field_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("ns_id"));
                    }
                    field_ns_id = Some(map.next_value()?);
                }
                "relative_path" => {
                    if field_relative_path.is_some() {
                        return Err(de::Error::duplicate_field("relative_path"));
                    }
                    field_relative_path = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS))
            }
        }
        Ok(NamespaceRelativePathLogInfo {
            ns_id: field_ns_id,
            relative_path: field_relative_path,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ns_id", &self.ns_id)?;
        s.serialize_field("relative_path", &self.relative_path)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NamespaceRelativePathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NamespaceRelativePathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NamespaceRelativePathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NamespaceRelativePathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NamespaceRelativePathLogInfo", NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NamespaceRelativePathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NamespaceRelativePathLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled network control.
#[derive(Debug)]
pub struct NetworkControlChangePolicyDetails {
    /// New network control policy.
    pub new_value: NetworkControlPolicy,
    /// Previous network control policy. Might be missing due to historical data gap.
    pub previous_value: Option<NetworkControlPolicy>,
}

impl NetworkControlChangePolicyDetails {
    pub fn new(new_value: NetworkControlPolicy) -> Self {
        NetworkControlChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<NetworkControlPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl NetworkControlChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NetworkControlChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(NetworkControlChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NetworkControlChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NetworkControlChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NetworkControlChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NetworkControlChangePolicyDetails", NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NetworkControlChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NetworkControlChangePolicyType {
    pub description: String,
}

impl NetworkControlChangePolicyType {
    pub fn new(description: String) -> Self {
        NetworkControlChangePolicyType {
            description,
        }
    }

}

const NETWORK_CONTROL_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl NetworkControlChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NetworkControlChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NETWORK_CONTROL_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(NetworkControlChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NetworkControlChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NetworkControlChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NetworkControlChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NetworkControlChangePolicyType", NETWORK_CONTROL_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NetworkControlChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Network control policy
#[derive(Debug)]
pub enum NetworkControlPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = NetworkControlPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NetworkControlPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(NetworkControlPolicy::Disabled),
                    "enabled" => Ok(NetworkControlPolicy::Enabled),
                    _ => Ok(NetworkControlPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("NetworkControlPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            NetworkControlPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            NetworkControlPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            NetworkControlPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Non team member's logged information.
#[derive(Debug)]
pub struct NonTeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayNameLegacy>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<EmailAddress>,
}

impl Default for NonTeamMemberLogInfo {
    fn default() -> Self {
        NonTeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
        }
    }
}

const NON_TEAM_MEMBER_LOG_INFO_FIELDS: &[&str] = &["account_id",
                                                   "display_name",
                                                   "email"];
impl NonTeamMemberLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NonTeamMemberLogInfo, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NON_TEAM_MEMBER_LOG_INFO_FIELDS))
            }
        }
        Ok(NonTeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NonTeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NonTeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NonTeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NonTeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NonTeamMemberLogInfo", NON_TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NonTeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NonTeamMemberLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a Paper document to be invite-only.
#[derive(Debug)]
pub struct NoteAclInviteOnlyDetails {
}

impl Default for NoteAclInviteOnlyDetails {
    fn default() -> Self {
        NoteAclInviteOnlyDetails {
        }
    }
}

const NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclInviteOnlyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclInviteOnlyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS));
        }
        Ok(NoteAclInviteOnlyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclInviteOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclInviteOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclInviteOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclInviteOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclInviteOnlyDetails", NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclInviteOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclInviteOnlyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclInviteOnlyType {
    pub description: String,
}

impl NoteAclInviteOnlyType {
    pub fn new(description: String) -> Self {
        NoteAclInviteOnlyType {
            description,
        }
    }

}

const NOTE_ACL_INVITE_ONLY_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclInviteOnlyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclInviteOnlyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NOTE_ACL_INVITE_ONLY_TYPE_FIELDS))
            }
        }
        Ok(NoteAclInviteOnlyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclInviteOnlyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclInviteOnlyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclInviteOnlyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclInviteOnlyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclInviteOnlyType", NOTE_ACL_INVITE_ONLY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclInviteOnlyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclInviteOnlyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a Paper document to be link accessible.
#[derive(Debug)]
pub struct NoteAclLinkDetails {
}

impl Default for NoteAclLinkDetails {
    fn default() -> Self {
        NoteAclLinkDetails {
        }
    }
}

const NOTE_ACL_LINK_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclLinkDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_LINK_DETAILS_FIELDS));
        }
        Ok(NoteAclLinkDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclLinkDetails", NOTE_ACL_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclLinkDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclLinkType {
    pub description: String,
}

impl NoteAclLinkType {
    pub fn new(description: String) -> Self {
        NoteAclLinkType {
            description,
        }
    }

}

const NOTE_ACL_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclLinkType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NOTE_ACL_LINK_TYPE_FIELDS))
            }
        }
        Ok(NoteAclLinkType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclLinkType", NOTE_ACL_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a Paper document to be link accessible for the team.
#[derive(Debug)]
pub struct NoteAclTeamLinkDetails {
}

impl Default for NoteAclTeamLinkDetails {
    fn default() -> Self {
        NoteAclTeamLinkDetails {
        }
    }
}

const NOTE_ACL_TEAM_LINK_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclTeamLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclTeamLinkDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_ACL_TEAM_LINK_DETAILS_FIELDS));
        }
        Ok(NoteAclTeamLinkDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclTeamLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclTeamLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclTeamLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclTeamLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclTeamLinkDetails", NOTE_ACL_TEAM_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclTeamLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclTeamLinkDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclTeamLinkType {
    pub description: String,
}

impl NoteAclTeamLinkType {
    pub fn new(description: String) -> Self {
        NoteAclTeamLinkType {
            description,
        }
    }

}

const NOTE_ACL_TEAM_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclTeamLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclTeamLinkType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NOTE_ACL_TEAM_LINK_TYPE_FIELDS))
            }
        }
        Ok(NoteAclTeamLinkType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclTeamLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclTeamLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteAclTeamLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclTeamLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclTeamLinkType", NOTE_ACL_TEAM_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclTeamLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclTeamLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper document received.
#[derive(Debug)]
pub struct NoteShareReceiveDetails {
}

impl Default for NoteShareReceiveDetails {
    fn default() -> Self {
        NoteShareReceiveDetails {
        }
    }
}

const NOTE_SHARE_RECEIVE_DETAILS_FIELDS: &[&str] = &[];
impl NoteShareReceiveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteShareReceiveDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_SHARE_RECEIVE_DETAILS_FIELDS));
        }
        Ok(NoteShareReceiveDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteShareReceiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteShareReceiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteShareReceiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteShareReceiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteShareReceiveDetails", NOTE_SHARE_RECEIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteShareReceiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteShareReceiveDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteShareReceiveType {
    pub description: String,
}

impl NoteShareReceiveType {
    pub fn new(description: String) -> Self {
        NoteShareReceiveType {
            description,
        }
    }

}

const NOTE_SHARE_RECEIVE_TYPE_FIELDS: &[&str] = &["description"];
impl NoteShareReceiveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteShareReceiveType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NOTE_SHARE_RECEIVE_TYPE_FIELDS))
            }
        }
        Ok(NoteShareReceiveType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteShareReceiveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteShareReceiveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteShareReceiveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteShareReceiveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteShareReceiveType", NOTE_SHARE_RECEIVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteShareReceiveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteShareReceiveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared a Paper doc.
#[derive(Debug)]
pub struct NoteSharedDetails {
}

impl Default for NoteSharedDetails {
    fn default() -> Self {
        NoteSharedDetails {
        }
    }
}

const NOTE_SHARED_DETAILS_FIELDS: &[&str] = &[];
impl NoteSharedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteSharedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, NOTE_SHARED_DETAILS_FIELDS));
        }
        Ok(NoteSharedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteSharedDetails", NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteSharedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteSharedType {
    pub description: String,
}

impl NoteSharedType {
    pub fn new(description: String) -> Self {
        NoteSharedType {
            description,
        }
    }

}

const NOTE_SHARED_TYPE_FIELDS: &[&str] = &["description"];
impl NoteSharedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteSharedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NOTE_SHARED_TYPE_FIELDS))
            }
        }
        Ok(NoteSharedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteSharedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteSharedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NoteSharedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteSharedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteSharedType", NOTE_SHARED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteSharedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteSharedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opened a shared Paper doc.
#[derive(Debug)]
pub struct OpenNoteSharedDetails {
}

impl Default for OpenNoteSharedDetails {
    fn default() -> Self {
        OpenNoteSharedDetails {
        }
    }
}

const OPEN_NOTE_SHARED_DETAILS_FIELDS: &[&str] = &[];
impl OpenNoteSharedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<OpenNoteSharedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, OPEN_NOTE_SHARED_DETAILS_FIELDS));
        }
        Ok(OpenNoteSharedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OpenNoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OpenNoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a OpenNoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OpenNoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OpenNoteSharedDetails", OPEN_NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OpenNoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("OpenNoteSharedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct OpenNoteSharedType {
    pub description: String,
}

impl OpenNoteSharedType {
    pub fn new(description: String) -> Self {
        OpenNoteSharedType {
            description,
        }
    }

}

const OPEN_NOTE_SHARED_TYPE_FIELDS: &[&str] = &["description"];
impl OpenNoteSharedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<OpenNoteSharedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, OPEN_NOTE_SHARED_TYPE_FIELDS))
            }
        }
        Ok(OpenNoteSharedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OpenNoteSharedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OpenNoteSharedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a OpenNoteSharedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OpenNoteSharedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OpenNoteSharedType", OPEN_NOTE_SHARED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OpenNoteSharedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OpenNoteSharedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The origin from which the actor performed the action.
#[derive(Debug)]
pub struct OriginLogInfo {
    /// The method that was used to perform the action.
    pub access_method: AccessMethodLogInfo,
    /// Geographic location details.
    pub geo_location: Option<GeoLocationLogInfo>,
}

impl OriginLogInfo {
    pub fn new(access_method: AccessMethodLogInfo) -> Self {
        OriginLogInfo {
            access_method,
            geo_location: None,
        }
    }

    pub fn with_geo_location(mut self, value: Option<GeoLocationLogInfo>) -> Self {
        self.geo_location = value;
        self
    }

}

const ORIGIN_LOG_INFO_FIELDS: &[&str] = &["access_method",
                                          "geo_location"];
impl OriginLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<OriginLogInfo, V::Error> {
        use serde::de;
        let mut field_access_method = None;
        let mut field_geo_location = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_method" => {
                    if field_access_method.is_some() {
                        return Err(de::Error::duplicate_field("access_method"));
                    }
                    field_access_method = Some(map.next_value()?);
                }
                "geo_location" => {
                    if field_geo_location.is_some() {
                        return Err(de::Error::duplicate_field("geo_location"));
                    }
                    field_geo_location = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ORIGIN_LOG_INFO_FIELDS))
            }
        }
        Ok(OriginLogInfo {
            access_method: field_access_method.ok_or_else(|| de::Error::missing_field("access_method"))?,
            geo_location: field_geo_location,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_method", &self.access_method)?;
        s.serialize_field("geo_location", &self.geo_location)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OriginLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OriginLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a OriginLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OriginLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OriginLogInfo", ORIGIN_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OriginLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OriginLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperAccessType {
    Viewer,
    Commenter,
    Editor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperAccessType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "viewer" => Ok(PaperAccessType::Viewer),
                    "commenter" => Ok(PaperAccessType::Commenter),
                    "editor" => Ok(PaperAccessType::Editor),
                    _ => Ok(PaperAccessType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["viewer",
                                    "commenter",
                                    "editor",
                                    "other"];
        deserializer.deserialize_struct("PaperAccessType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperAccessType::Viewer => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "viewer")?;
                s.end()
            }
            PaperAccessType::Commenter => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "commenter")?;
                s.end()
            }
            PaperAccessType::Editor => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "editor")?;
                s.end()
            }
            PaperAccessType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Exported all Paper documents in the team.
#[derive(Debug)]
pub struct PaperAdminExportStartDetails {
}

impl Default for PaperAdminExportStartDetails {
    fn default() -> Self {
        PaperAdminExportStartDetails {
        }
    }
}

const PAPER_ADMIN_EXPORT_START_DETAILS_FIELDS: &[&str] = &[];
impl PaperAdminExportStartDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperAdminExportStartDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_ADMIN_EXPORT_START_DETAILS_FIELDS));
        }
        Ok(PaperAdminExportStartDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAdminExportStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperAdminExportStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperAdminExportStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperAdminExportStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperAdminExportStartDetails", PAPER_ADMIN_EXPORT_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAdminExportStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperAdminExportStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperAdminExportStartType {
    pub description: String,
}

impl PaperAdminExportStartType {
    pub fn new(description: String) -> Self {
        PaperAdminExportStartType {
            description,
        }
    }

}

const PAPER_ADMIN_EXPORT_START_TYPE_FIELDS: &[&str] = &["description"];
impl PaperAdminExportStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperAdminExportStartType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_ADMIN_EXPORT_START_TYPE_FIELDS))
            }
        }
        Ok(PaperAdminExportStartType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAdminExportStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperAdminExportStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperAdminExportStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperAdminExportStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperAdminExportStartType", PAPER_ADMIN_EXPORT_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAdminExportStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperAdminExportStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether Dropbox Paper, when enabled, is deployed to all teams or to specific members of
/// the team.
#[derive(Debug)]
pub struct PaperChangeDeploymentPolicyDetails {
    /// New Dropbox Paper deployment policy.
    pub new_value: super::team_policies::PaperDeploymentPolicy,
    /// Previous Dropbox Paper deployment policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::PaperDeploymentPolicy>,
}

impl PaperChangeDeploymentPolicyDetails {
    pub fn new(new_value: super::team_policies::PaperDeploymentPolicy) -> Self {
        PaperChangeDeploymentPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::PaperDeploymentPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl PaperChangeDeploymentPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeDeploymentPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangeDeploymentPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeDeploymentPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeDeploymentPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeDeploymentPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeDeploymentPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeDeploymentPolicyDetails", PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeDeploymentPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeDeploymentPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeDeploymentPolicyType {
    pub description: String,
}

impl PaperChangeDeploymentPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeDeploymentPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_DEPLOYMENT_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeDeploymentPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeDeploymentPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_DEPLOYMENT_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PaperChangeDeploymentPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeDeploymentPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeDeploymentPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeDeploymentPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeDeploymentPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeDeploymentPolicyType", PAPER_CHANGE_DEPLOYMENT_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeDeploymentPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeDeploymentPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether non team members can view Paper documents using a link.
#[derive(Debug)]
pub struct PaperChangeMemberLinkPolicyDetails {
    /// New paper external link accessibility policy.
    pub new_value: PaperMemberPolicy,
}

impl PaperChangeMemberLinkPolicyDetails {
    pub fn new(new_value: PaperMemberPolicy) -> Self {
        PaperChangeMemberLinkPolicyDetails {
            new_value,
        }
    }

}

const PAPER_CHANGE_MEMBER_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl PaperChangeMemberLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeMemberLinkPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_MEMBER_LINK_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangeMemberLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberLinkPolicyDetails", PAPER_CHANGE_MEMBER_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberLinkPolicyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeMemberLinkPolicyType {
    pub description: String,
}

impl PaperChangeMemberLinkPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeMemberLinkPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_MEMBER_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeMemberLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeMemberLinkPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_MEMBER_LINK_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PaperChangeMemberLinkPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberLinkPolicyType", PAPER_CHANGE_MEMBER_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share Paper documents externally (i.e. outside the team), and
/// if so, whether they should be accessible only by team members or anyone by default.
#[derive(Debug)]
pub struct PaperChangeMemberPolicyDetails {
    /// New paper external accessibility policy.
    pub new_value: PaperMemberPolicy,
    /// Previous paper external accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<PaperMemberPolicy>,
}

impl PaperChangeMemberPolicyDetails {
    pub fn new(new_value: PaperMemberPolicy) -> Self {
        PaperChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<PaperMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                             "previous_value"];
impl PaperChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeMemberPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberPolicyDetails", PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeMemberPolicyType {
    pub description: String,
}

impl PaperChangeMemberPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeMemberPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_MEMBER_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeMemberPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangeMemberPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_MEMBER_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PaperChangeMemberPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberPolicyType", PAPER_CHANGE_MEMBER_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled Dropbox Paper for the team.
#[derive(Debug)]
pub struct PaperChangePolicyDetails {
    /// New Dropbox Paper policy.
    pub new_value: super::team_policies::PaperEnabledPolicy,
    /// Previous Dropbox Paper policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::PaperEnabledPolicy>,
}

impl PaperChangePolicyDetails {
    pub fn new(new_value: super::team_policies::PaperEnabledPolicy) -> Self {
        PaperChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::PaperEnabledPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                      "previous_value"];
impl PaperChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangePolicyDetails", PAPER_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangePolicyType {
    pub description: String,
}

impl PaperChangePolicyType {
    pub fn new(description: String) -> Self {
        PaperChangePolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PaperChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangePolicyType", PAPER_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users to the membership of a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentAddMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentAddMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentAddMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentAddMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddMemberDetails", PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentAddMemberType {
    pub description: String,
}

impl PaperContentAddMemberType {
    pub fn new(description: String) -> Self {
        PaperContentAddMemberType {
            description,
        }
    }

}

const PAPER_CONTENT_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentAddMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(PaperContentAddMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddMemberType", PAPER_CONTENT_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added Paper doc or folder to a folder.
#[derive(Debug)]
pub struct PaperContentAddToFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Parent asset position in the Assets list.
    pub parent_asset_index: u64,
}

impl PaperContentAddToFolderDetails {
    pub fn new(event_uuid: String, target_asset_index: u64, parent_asset_index: u64) -> Self {
        PaperContentAddToFolderDetails {
            event_uuid,
            target_asset_index,
            parent_asset_index,
        }
    }

}

const PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                              "target_asset_index",
                                                              "parent_asset_index"];
impl PaperContentAddToFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentAddToFolderDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_target_asset_index = None;
        let mut field_parent_asset_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "parent_asset_index" => {
                    if field_parent_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("parent_asset_index"));
                    }
                    field_parent_asset_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentAddToFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            parent_asset_index: field_parent_asset_index.ok_or_else(|| de::Error::missing_field("parent_asset_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("parent_asset_index", &self.parent_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddToFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddToFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddToFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddToFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddToFolderDetails", PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddToFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddToFolderDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentAddToFolderType {
    pub description: String,
}

impl PaperContentAddToFolderType {
    pub fn new(description: String) -> Self {
        PaperContentAddToFolderType {
            description,
        }
    }

}

const PAPER_CONTENT_ADD_TO_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentAddToFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentAddToFolderType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ADD_TO_FOLDER_TYPE_FIELDS))
            }
        }
        Ok(PaperContentAddToFolderType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddToFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddToFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddToFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddToFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddToFolderType", PAPER_CONTENT_ADD_TO_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddToFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddToFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentArchiveDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentArchiveDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentArchiveDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentArchiveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentArchiveDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentArchiveDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentArchiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentArchiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentArchiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentArchiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentArchiveDetails", PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentArchiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentArchiveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentArchiveType {
    pub description: String,
}

impl PaperContentArchiveType {
    pub fn new(description: String) -> Self {
        PaperContentArchiveType {
            description,
        }
    }

}

const PAPER_CONTENT_ARCHIVE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentArchiveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentArchiveType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_ARCHIVE_TYPE_FIELDS))
            }
        }
        Ok(PaperContentArchiveType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentArchiveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentArchiveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentArchiveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentArchiveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentArchiveType", PAPER_CONTENT_ARCHIVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentArchiveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentArchiveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentCreateDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentCreateDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentCreateDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_CREATE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentCreateDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentCreateDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentCreateDetails", PAPER_CONTENT_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentCreateType {
    pub description: String,
}

impl PaperContentCreateType {
    pub fn new(description: String) -> Self {
        PaperContentCreateType {
            description,
        }
    }

}

const PAPER_CONTENT_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_CREATE_TYPE_FIELDS))
            }
        }
        Ok(PaperContentCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentCreateType", PAPER_CONTENT_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentPermanentlyDeleteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentPermanentlyDeleteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentPermanentlyDeleteDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentPermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentPermanentlyDeleteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentPermanentlyDeleteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentPermanentlyDeleteDetails", PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentPermanentlyDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentPermanentlyDeleteType {
    pub description: String,
}

impl PaperContentPermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        PaperContentPermanentlyDeleteType {
            description,
        }
    }

}

const PAPER_CONTENT_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentPermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentPermanentlyDeleteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_PERMANENTLY_DELETE_TYPE_FIELDS))
            }
        }
        Ok(PaperContentPermanentlyDeleteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentPermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentPermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentPermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentPermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentPermanentlyDeleteType", PAPER_CONTENT_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentPermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentPermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed Paper doc or folder from a folder.
#[derive(Debug)]
pub struct PaperContentRemoveFromFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRemoveFromFolderDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveFromFolderDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRemoveFromFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRemoveFromFolderDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRemoveFromFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveFromFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveFromFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveFromFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveFromFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveFromFolderDetails", PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveFromFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveFromFolderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRemoveFromFolderType {
    pub description: String,
}

impl PaperContentRemoveFromFolderType {
    pub fn new(description: String) -> Self {
        PaperContentRemoveFromFolderType {
            description,
        }
    }

}

const PAPER_CONTENT_REMOVE_FROM_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRemoveFromFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRemoveFromFolderType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_FROM_FOLDER_TYPE_FIELDS))
            }
        }
        Ok(PaperContentRemoveFromFolderType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveFromFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveFromFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveFromFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveFromFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveFromFolderType", PAPER_CONTENT_REMOVE_FROM_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveFromFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveFromFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a user from the membership of a Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRemoveMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRemoveMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRemoveMemberDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRemoveMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveMemberDetails", PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRemoveMemberType {
    pub description: String,
}

impl PaperContentRemoveMemberType {
    pub fn new(description: String) -> Self {
        PaperContentRemoveMemberType {
            description,
        }
    }

}

const PAPER_CONTENT_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRemoveMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_REMOVE_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(PaperContentRemoveMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveMemberType", PAPER_CONTENT_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRenameDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRenameDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRenameDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RENAME_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRenameDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRenameDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRenameDetails", PAPER_CONTENT_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRenameType {
    pub description: String,
}

impl PaperContentRenameType {
    pub fn new(description: String) -> Self {
        PaperContentRenameType {
            description,
        }
    }

}

const PAPER_CONTENT_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRenameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RENAME_TYPE_FIELDS))
            }
        }
        Ok(PaperContentRenameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRenameType", PAPER_CONTENT_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored an archived Paper doc or folder.
#[derive(Debug)]
pub struct PaperContentRestoreDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRestoreDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRestoreDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RESTORE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRestoreDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRestoreDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RESTORE_DETAILS_FIELDS))
            }
        }
        Ok(PaperContentRestoreDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRestoreDetails", PAPER_CONTENT_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRestoreDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRestoreType {
    pub description: String,
}

impl PaperContentRestoreType {
    pub fn new(description: String) -> Self {
        PaperContentRestoreType {
            description,
        }
    }

}

const PAPER_CONTENT_RESTORE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRestoreType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperContentRestoreType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_CONTENT_RESTORE_TYPE_FIELDS))
            }
        }
        Ok(PaperContentRestoreType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRestoreType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRestoreType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperContentRestoreType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRestoreType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRestoreType", PAPER_CONTENT_RESTORE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRestoreType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRestoreType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocAddCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocAddCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocAddCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "comment_text"];
impl PaperDocAddCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocAddCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocAddCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocAddCommentDetails", PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocAddCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocAddCommentType {
    pub description: String,
}

impl PaperDocAddCommentType {
    pub fn new(description: String) -> Self {
        PaperDocAddCommentType {
            description,
        }
    }

}

const PAPER_DOC_ADD_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocAddCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocAddCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_ADD_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocAddCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocAddCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocAddCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocAddCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocAddCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocAddCommentType", PAPER_DOC_ADD_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocAddCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocAddCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of a Paper doc member.
#[derive(Debug)]
pub struct PaperDocChangeMemberRoleDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Paper doc access type.
    pub access_type: PaperAccessType,
}

impl PaperDocChangeMemberRoleDetails {
    pub fn new(event_uuid: String, access_type: PaperAccessType) -> Self {
        PaperDocChangeMemberRoleDetails {
            event_uuid,
            access_type,
        }
    }

}

const PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                               "access_type"];
impl PaperDocChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_access_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocChangeMemberRoleDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("access_type", &self.access_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeMemberRoleDetails", PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeMemberRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeMemberRoleType {
    pub description: String,
}

impl PaperDocChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        PaperDocChangeMemberRoleType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeMemberRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_MEMBER_ROLE_TYPE_FIELDS))
            }
        }
        Ok(PaperDocChangeMemberRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeMemberRoleType", PAPER_DOC_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sharing policy for Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeSharingPolicyDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Sharing policy with external users. Might be missing due to historical data gap.
    pub public_sharing_policy: Option<String>,
    /// Sharing policy with team. Might be missing due to historical data gap.
    pub team_sharing_policy: Option<String>,
}

impl PaperDocChangeSharingPolicyDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocChangeSharingPolicyDetails {
            event_uuid,
            public_sharing_policy: None,
            team_sharing_policy: None,
        }
    }

    pub fn with_public_sharing_policy(mut self, value: Option<String>) -> Self {
        self.public_sharing_policy = value;
        self
    }

    pub fn with_team_sharing_policy(mut self, value: Option<String>) -> Self {
        self.team_sharing_policy = value;
        self
    }

}

const PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                  "public_sharing_policy",
                                                                  "team_sharing_policy"];
impl PaperDocChangeSharingPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeSharingPolicyDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_public_sharing_policy = None;
        let mut field_team_sharing_policy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "public_sharing_policy" => {
                    if field_public_sharing_policy.is_some() {
                        return Err(de::Error::duplicate_field("public_sharing_policy"));
                    }
                    field_public_sharing_policy = Some(map.next_value()?);
                }
                "team_sharing_policy" => {
                    if field_team_sharing_policy.is_some() {
                        return Err(de::Error::duplicate_field("team_sharing_policy"));
                    }
                    field_team_sharing_policy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocChangeSharingPolicyDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            public_sharing_policy: field_public_sharing_policy,
            team_sharing_policy: field_team_sharing_policy,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("public_sharing_policy", &self.public_sharing_policy)?;
        s.serialize_field("team_sharing_policy", &self.team_sharing_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSharingPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSharingPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSharingPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSharingPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSharingPolicyDetails", PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSharingPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSharingPolicyDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeSharingPolicyType {
    pub description: String,
}

impl PaperDocChangeSharingPolicyType {
    pub fn new(description: String) -> Self {
        PaperDocChangeSharingPolicyType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_SHARING_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeSharingPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeSharingPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_SHARING_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PaperDocChangeSharingPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSharingPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSharingPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSharingPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSharingPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSharingPolicyType", PAPER_DOC_CHANGE_SHARING_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSharingPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSharingPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed or unfollowed a Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeSubscriptionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New doc subscription level.
    pub new_subscription_level: String,
    /// Previous doc subscription level. Might be missing due to historical data gap.
    pub previous_subscription_level: Option<String>,
}

impl PaperDocChangeSubscriptionDetails {
    pub fn new(event_uuid: String, new_subscription_level: String) -> Self {
        PaperDocChangeSubscriptionDetails {
            event_uuid,
            new_subscription_level,
            previous_subscription_level: None,
        }
    }

    pub fn with_previous_subscription_level(mut self, value: Option<String>) -> Self {
        self.previous_subscription_level = value;
        self
    }

}

const PAPER_DOC_CHANGE_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                "new_subscription_level",
                                                                "previous_subscription_level"];
impl PaperDocChangeSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeSubscriptionDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_new_subscription_level = None;
        let mut field_previous_subscription_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_subscription_level" => {
                    if field_new_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("new_subscription_level"));
                    }
                    field_new_subscription_level = Some(map.next_value()?);
                }
                "previous_subscription_level" => {
                    if field_previous_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("previous_subscription_level"));
                    }
                    field_previous_subscription_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_SUBSCRIPTION_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocChangeSubscriptionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            new_subscription_level: field_new_subscription_level.ok_or_else(|| de::Error::missing_field("new_subscription_level"))?,
            previous_subscription_level: field_previous_subscription_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_subscription_level", &self.new_subscription_level)?;
        s.serialize_field("previous_subscription_level", &self.previous_subscription_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSubscriptionDetails", PAPER_DOC_CHANGE_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSubscriptionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeSubscriptionType {
    pub description: String,
}

impl PaperDocChangeSubscriptionType {
    pub fn new(description: String) -> Self {
        PaperDocChangeSubscriptionType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocChangeSubscriptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_CHANGE_SUBSCRIPTION_TYPE_FIELDS))
            }
        }
        Ok(PaperDocChangeSubscriptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSubscriptionType", PAPER_DOC_CHANGE_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocDeleteCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocDeleteCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeleteCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                           "comment_text"];
impl PaperDocDeleteCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDeleteCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDeleteCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeleteCommentDetails", PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeleteCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDeleteCommentType {
    pub description: String,
}

impl PaperDocDeleteCommentType {
    pub fn new(description: String) -> Self {
        PaperDocDeleteCommentType {
            description,
        }
    }

}

const PAPER_DOC_DELETE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDeleteCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDeleteCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocDeleteCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeleteCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeleteCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeleteCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeleteCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeleteCommentType", PAPER_DOC_DELETE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeleteCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeleteCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc archived.
#[derive(Debug)]
pub struct PaperDocDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_DELETED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDeletedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeletedDetails", PAPER_DOC_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDeletedType {
    pub description: String,
}

impl PaperDocDeletedType {
    pub fn new(description: String) -> Self {
        PaperDocDeletedType {
            description,
        }
    }

}

const PAPER_DOC_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDeletedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DELETED_TYPE_FIELDS))
            }
        }
        Ok(PaperDocDeletedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeletedType", PAPER_DOC_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded a Paper doc in a particular output format.
#[derive(Debug)]
pub struct PaperDocDownloadDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Export file format.
    pub export_file_format: PaperDownloadFormat,
}

impl PaperDocDownloadDetails {
    pub fn new(event_uuid: String, export_file_format: PaperDownloadFormat) -> Self {
        PaperDocDownloadDetails {
            event_uuid,
            export_file_format,
        }
    }

}

const PAPER_DOC_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                     "export_file_format"];
impl PaperDocDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDownloadDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_export_file_format = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "export_file_format" => {
                    if field_export_file_format.is_some() {
                        return Err(de::Error::duplicate_field("export_file_format"));
                    }
                    field_export_file_format = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DOWNLOAD_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocDownloadDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            export_file_format: field_export_file_format.ok_or_else(|| de::Error::missing_field("export_file_format"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("export_file_format", &self.export_file_format)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDownloadDetails", PAPER_DOC_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDownloadDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDownloadType {
    pub description: String,
}

impl PaperDocDownloadType {
    pub fn new(description: String) -> Self {
        PaperDocDownloadType {
            description,
        }
    }

}

const PAPER_DOC_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocDownloadType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_DOWNLOAD_TYPE_FIELDS))
            }
        }
        Ok(PaperDocDownloadType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDownloadType", PAPER_DOC_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocEditCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocEditCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                         "comment_text"];
impl PaperDocEditCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocEditCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocEditCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditCommentDetails", PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocEditCommentType {
    pub description: String,
}

impl PaperDocEditCommentType {
    pub fn new(description: String) -> Self {
        PaperDocEditCommentType {
            description,
        }
    }

}

const PAPER_DOC_EDIT_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocEditCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocEditCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocEditCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditCommentType", PAPER_DOC_EDIT_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited a Paper doc.
#[derive(Debug)]
pub struct PaperDocEditDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocEditDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_EDIT_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocEditDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocEditDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocEditDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditDetails", PAPER_DOC_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocEditType {
    pub description: String,
}

impl PaperDocEditType {
    pub fn new(description: String) -> Self {
        PaperDocEditType {
            description,
        }
    }

}

const PAPER_DOC_EDIT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocEditType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocEditType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_EDIT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocEditType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditType", PAPER_DOC_EDIT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed a Paper doc.
#[derive(Debug)]
pub struct PaperDocFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_FOLLOWED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocFollowedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_FOLLOWED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocFollowedDetails", PAPER_DOC_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocFollowedType {
    pub description: String,
}

impl PaperDocFollowedType {
    pub fn new(description: String) -> Self {
        PaperDocFollowedType {
            description,
        }
    }

}

const PAPER_DOC_FOLLOWED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocFollowedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocFollowedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_FOLLOWED_TYPE_FIELDS))
            }
        }
        Ok(PaperDocFollowedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocFollowedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocFollowedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocFollowedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocFollowedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocFollowedType", PAPER_DOC_FOLLOWED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocFollowedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocFollowedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Mentioned a member in a Paper doc.
#[derive(Debug)]
pub struct PaperDocMentionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocMentionDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocMentionDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_MENTION_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocMentionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocMentionDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_MENTION_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocMentionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocMentionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocMentionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocMentionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocMentionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocMentionDetails", PAPER_DOC_MENTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocMentionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocMentionDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocMentionType {
    pub description: String,
}

impl PaperDocMentionType {
    pub fn new(description: String) -> Self {
        PaperDocMentionType {
            description,
        }
    }

}

const PAPER_DOC_MENTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocMentionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocMentionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_MENTION_TYPE_FIELDS))
            }
        }
        Ok(PaperDocMentionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocMentionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocMentionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocMentionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocMentionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocMentionType", PAPER_DOC_MENTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocMentionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocMentionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to be a member on a Paper doc.
#[derive(Debug)]
pub struct PaperDocRequestAccessDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRequestAccessDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRequestAccessDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocRequestAccessDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocRequestAccessDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRequestAccessDetails", PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocRequestAccessType {
    pub description: String,
}

impl PaperDocRequestAccessType {
    pub fn new(description: String) -> Self {
        PaperDocRequestAccessType {
            description,
        }
    }

}

const PAPER_DOC_REQUEST_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocRequestAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocRequestAccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REQUEST_ACCESS_TYPE_FIELDS))
            }
        }
        Ok(PaperDocRequestAccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRequestAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRequestAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRequestAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRequestAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRequestAccessType", PAPER_DOC_REQUEST_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRequestAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRequestAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc comment resolved.
#[derive(Debug)]
pub struct PaperDocResolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocResolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocResolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                            "comment_text"];
impl PaperDocResolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocResolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocResolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocResolveCommentDetails", PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocResolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocResolveCommentType {
    pub description: String,
}

impl PaperDocResolveCommentType {
    pub fn new(description: String) -> Self {
        PaperDocResolveCommentType {
            description,
        }
    }

}

const PAPER_DOC_RESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocResolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocResolveCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_RESOLVE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocResolveCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocResolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocResolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocResolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocResolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocResolveCommentType", PAPER_DOC_RESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocResolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocResolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored a Paper doc to previous revision.
#[derive(Debug)]
pub struct PaperDocRevertDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRevertDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRevertDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REVERT_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocRevertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocRevertDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REVERT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocRevertDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRevertDetails", PAPER_DOC_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRevertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocRevertType {
    pub description: String,
}

impl PaperDocRevertType {
    pub fn new(description: String) -> Self {
        PaperDocRevertType {
            description,
        }
    }

}

const PAPER_DOC_REVERT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocRevertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocRevertType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_REVERT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocRevertType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRevertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRevertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocRevertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRevertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRevertType", PAPER_DOC_REVERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRevertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRevertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc link shared via slack.
#[derive(Debug)]
pub struct PaperDocSlackShareDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocSlackShareDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocSlackShareDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocSlackShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocSlackShareDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocSlackShareDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocSlackShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocSlackShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocSlackShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocSlackShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocSlackShareDetails", PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocSlackShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocSlackShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocSlackShareType {
    pub description: String,
}

impl PaperDocSlackShareType {
    pub fn new(description: String) -> Self {
        PaperDocSlackShareType {
            description,
        }
    }

}

const PAPER_DOC_SLACK_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocSlackShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocSlackShareType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_SLACK_SHARE_TYPE_FIELDS))
            }
        }
        Ok(PaperDocSlackShareType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocSlackShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocSlackShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocSlackShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocSlackShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocSlackShareType", PAPER_DOC_SLACK_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocSlackShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocSlackShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc shared with team member.
#[derive(Debug)]
pub struct PaperDocTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTeamInviteDetails", PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocTeamInviteType {
    pub description: String,
}

impl PaperDocTeamInviteType {
    pub fn new(description: String) -> Self {
        PaperDocTeamInviteType {
            description,
        }
    }

}

const PAPER_DOC_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocTeamInviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_TEAM_INVITE_TYPE_FIELDS))
            }
        }
        Ok(PaperDocTeamInviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTeamInviteType", PAPER_DOC_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc trashed.
#[derive(Debug)]
pub struct PaperDocTrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocTrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocTrashedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_TRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocTrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocTrashedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_TRASHED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocTrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocTrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTrashedDetails", PAPER_DOC_TRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocTrashedType {
    pub description: String,
}

impl PaperDocTrashedType {
    pub fn new(description: String) -> Self {
        PaperDocTrashedType {
            description,
        }
    }

}

const PAPER_DOC_TRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocTrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocTrashedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_TRASHED_TYPE_FIELDS))
            }
        }
        Ok(PaperDocTrashedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocTrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTrashedType", PAPER_DOC_TRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved a Paper doc comment.
#[derive(Debug)]
pub struct PaperDocUnresolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocUnresolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocUnresolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                              "comment_text"];
impl PaperDocUnresolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocUnresolveCommentDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocUnresolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUnresolveCommentDetails", PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUnresolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocUnresolveCommentType {
    pub description: String,
}

impl PaperDocUnresolveCommentType {
    pub fn new(description: String) -> Self {
        PaperDocUnresolveCommentType {
            description,
        }
    }

}

const PAPER_DOC_UNRESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocUnresolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocUnresolveCommentType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_UNRESOLVE_COMMENT_TYPE_FIELDS))
            }
        }
        Ok(PaperDocUnresolveCommentType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUnresolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUnresolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocUnresolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUnresolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUnresolveCommentType", PAPER_DOC_UNRESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUnresolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUnresolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper doc untrashed.
#[derive(Debug)]
pub struct PaperDocUntrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocUntrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocUntrashedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_UNTRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocUntrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocUntrashedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_UNTRASHED_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocUntrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUntrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUntrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocUntrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUntrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUntrashedDetails", PAPER_DOC_UNTRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUntrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUntrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocUntrashedType {
    pub description: String,
}

impl PaperDocUntrashedType {
    pub fn new(description: String) -> Self {
        PaperDocUntrashedType {
            description,
        }
    }

}

const PAPER_DOC_UNTRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocUntrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocUntrashedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_UNTRASHED_TYPE_FIELDS))
            }
        }
        Ok(PaperDocUntrashedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUntrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUntrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocUntrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUntrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUntrashedType", PAPER_DOC_UNTRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUntrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUntrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed Paper doc.
#[derive(Debug)]
pub struct PaperDocViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocViewDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocViewDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_VIEW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocViewDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_VIEW_DETAILS_FIELDS))
            }
        }
        Ok(PaperDocViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocViewDetails", PAPER_DOC_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocViewType {
    pub description: String,
}

impl PaperDocViewType {
    pub fn new(description: String) -> Self {
        PaperDocViewType {
            description,
        }
    }

}

const PAPER_DOC_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocViewType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOC_VIEW_TYPE_FIELDS))
            }
        }
        Ok(PaperDocViewType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocViewType", PAPER_DOC_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper document's logged information.
#[derive(Debug)]
pub struct PaperDocumentLogInfo {
    /// Papers document Id.
    pub doc_id: String,
    /// Paper document title.
    pub doc_title: String,
}

impl PaperDocumentLogInfo {
    pub fn new(doc_id: String, doc_title: String) -> Self {
        PaperDocumentLogInfo {
            doc_id,
            doc_title,
        }
    }

}

const PAPER_DOCUMENT_LOG_INFO_FIELDS: &[&str] = &["doc_id",
                                                  "doc_title"];
impl PaperDocumentLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperDocumentLogInfo, V::Error> {
        use serde::de;
        let mut field_doc_id = None;
        let mut field_doc_title = None;
        while let Some(key) = map.next_key()? {
            match key {
                "doc_id" => {
                    if field_doc_id.is_some() {
                        return Err(de::Error::duplicate_field("doc_id"));
                    }
                    field_doc_id = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_DOCUMENT_LOG_INFO_FIELDS))
            }
        }
        Ok(PaperDocumentLogInfo {
            doc_id: field_doc_id.ok_or_else(|| de::Error::missing_field("doc_id"))?,
            doc_title: field_doc_title.ok_or_else(|| de::Error::missing_field("doc_title"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("doc_id", &self.doc_id)?;
        s.serialize_field("doc_title", &self.doc_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocumentLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocumentLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDocumentLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocumentLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocumentLogInfo", PAPER_DOCUMENT_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocumentLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocumentLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperDownloadFormat {
    Docx,
    Html,
    Markdown,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDownloadFormat {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDownloadFormat;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperDownloadFormat structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "docx" => Ok(PaperDownloadFormat::Docx),
                    "html" => Ok(PaperDownloadFormat::Html),
                    "markdown" => Ok(PaperDownloadFormat::Markdown),
                    _ => Ok(PaperDownloadFormat::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["docx",
                                    "html",
                                    "markdown",
                                    "other"];
        deserializer.deserialize_struct("PaperDownloadFormat", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDownloadFormat {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDownloadFormat::Docx => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "docx")?;
                s.end()
            }
            PaperDownloadFormat::Html => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "html")?;
                s.end()
            }
            PaperDownloadFormat::Markdown => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "markdown")?;
                s.end()
            }
            PaperDownloadFormat::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Users added to Paper enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupAdditionDetails {
}

impl Default for PaperEnabledUsersGroupAdditionDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupAdditionDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS: &[&str] = &[];
impl PaperEnabledUsersGroupAdditionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupAdditionDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS));
        }
        Ok(PaperEnabledUsersGroupAdditionDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupAdditionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupAdditionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupAdditionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupAdditionDetails", PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupAdditionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupAdditionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperEnabledUsersGroupAdditionType {
    pub description: String,
}

impl PaperEnabledUsersGroupAdditionType {
    pub fn new(description: String) -> Self {
        PaperEnabledUsersGroupAdditionType {
            description,
        }
    }

}

const PAPER_ENABLED_USERS_GROUP_ADDITION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperEnabledUsersGroupAdditionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupAdditionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_ADDITION_TYPE_FIELDS))
            }
        }
        Ok(PaperEnabledUsersGroupAdditionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupAdditionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupAdditionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupAdditionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupAdditionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupAdditionType", PAPER_ENABLED_USERS_GROUP_ADDITION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupAdditionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperEnabledUsersGroupAdditionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Users removed from Paper enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupRemovalDetails {
}

impl Default for PaperEnabledUsersGroupRemovalDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupRemovalDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS: &[&str] = &[];
impl PaperEnabledUsersGroupRemovalDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupRemovalDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS));
        }
        Ok(PaperEnabledUsersGroupRemovalDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupRemovalDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupRemovalDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupRemovalDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupRemovalDetails", PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupRemovalDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupRemovalDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperEnabledUsersGroupRemovalType {
    pub description: String,
}

impl PaperEnabledUsersGroupRemovalType {
    pub fn new(description: String) -> Self {
        PaperEnabledUsersGroupRemovalType {
            description,
        }
    }

}

const PAPER_ENABLED_USERS_GROUP_REMOVAL_TYPE_FIELDS: &[&str] = &["description"];
impl PaperEnabledUsersGroupRemovalType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupRemovalType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_ENABLED_USERS_GROUP_REMOVAL_TYPE_FIELDS))
            }
        }
        Ok(PaperEnabledUsersGroupRemovalType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupRemovalType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupRemovalType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupRemovalType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupRemovalType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupRemovalType", PAPER_ENABLED_USERS_GROUP_REMOVAL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupRemovalType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperEnabledUsersGroupRemovalType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper external sharing policy changed: anyone.
#[derive(Debug)]
pub struct PaperExternalViewAllowDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewAllowDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewAllowDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewAllowDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewAllowDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS))
            }
        }
        Ok(PaperExternalViewAllowDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewAllowDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewAllowDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewAllowDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewAllowDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewAllowDetails", PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewAllowDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewAllowDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewAllowType {
    pub description: String,
}

impl PaperExternalViewAllowType {
    pub fn new(description: String) -> Self {
        PaperExternalViewAllowType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_ALLOW_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewAllowType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewAllowType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_ALLOW_TYPE_FIELDS))
            }
        }
        Ok(PaperExternalViewAllowType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewAllowType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewAllowType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewAllowType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewAllowType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewAllowType", PAPER_EXTERNAL_VIEW_ALLOW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewAllowType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewAllowType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper external sharing policy changed: default team.
#[derive(Debug)]
pub struct PaperExternalViewDefaultTeamDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewDefaultTeamDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewDefaultTeamDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewDefaultTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewDefaultTeamDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS))
            }
        }
        Ok(PaperExternalViewDefaultTeamDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewDefaultTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewDefaultTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewDefaultTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewDefaultTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewDefaultTeamDetails", PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewDefaultTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewDefaultTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewDefaultTeamType {
    pub description: String,
}

impl PaperExternalViewDefaultTeamType {
    pub fn new(description: String) -> Self {
        PaperExternalViewDefaultTeamType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewDefaultTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewDefaultTeamType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_TYPE_FIELDS))
            }
        }
        Ok(PaperExternalViewDefaultTeamType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewDefaultTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewDefaultTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewDefaultTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewDefaultTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewDefaultTeamType", PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewDefaultTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewDefaultTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper external sharing policy changed: team-only.
#[derive(Debug)]
pub struct PaperExternalViewForbidDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewForbidDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewForbidDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewForbidDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewForbidDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS))
            }
        }
        Ok(PaperExternalViewForbidDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewForbidDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewForbidDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewForbidDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewForbidDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewForbidDetails", PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewForbidDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewForbidDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewForbidType {
    pub description: String,
}

impl PaperExternalViewForbidType {
    pub fn new(description: String) -> Self {
        PaperExternalViewForbidType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_FORBID_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewForbidType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperExternalViewForbidType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_EXTERNAL_VIEW_FORBID_TYPE_FIELDS))
            }
        }
        Ok(PaperExternalViewForbidType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewForbidType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewForbidType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewForbidType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewForbidType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewForbidType", PAPER_EXTERNAL_VIEW_FORBID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewForbidType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewForbidType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed or unfollowed a Paper folder.
#[derive(Debug)]
pub struct PaperFolderChangeSubscriptionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New folder subscription level.
    pub new_subscription_level: String,
    /// Previous folder subscription level. Might be missing due to historical data gap.
    pub previous_subscription_level: Option<String>,
}

impl PaperFolderChangeSubscriptionDetails {
    pub fn new(event_uuid: String, new_subscription_level: String) -> Self {
        PaperFolderChangeSubscriptionDetails {
            event_uuid,
            new_subscription_level,
            previous_subscription_level: None,
        }
    }

    pub fn with_previous_subscription_level(mut self, value: Option<String>) -> Self {
        self.previous_subscription_level = value;
        self
    }

}

const PAPER_FOLDER_CHANGE_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                   "new_subscription_level",
                                                                   "previous_subscription_level"];
impl PaperFolderChangeSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderChangeSubscriptionDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        let mut field_new_subscription_level = None;
        let mut field_previous_subscription_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_subscription_level" => {
                    if field_new_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("new_subscription_level"));
                    }
                    field_new_subscription_level = Some(map.next_value()?);
                }
                "previous_subscription_level" => {
                    if field_previous_subscription_level.is_some() {
                        return Err(de::Error::duplicate_field("previous_subscription_level"));
                    }
                    field_previous_subscription_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_CHANGE_SUBSCRIPTION_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderChangeSubscriptionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
            new_subscription_level: field_new_subscription_level.ok_or_else(|| de::Error::missing_field("new_subscription_level"))?,
            previous_subscription_level: field_previous_subscription_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_subscription_level", &self.new_subscription_level)?;
        s.serialize_field("previous_subscription_level", &self.previous_subscription_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderChangeSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderChangeSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderChangeSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderChangeSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderChangeSubscriptionDetails", PAPER_FOLDER_CHANGE_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderChangeSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderChangeSubscriptionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderChangeSubscriptionType {
    pub description: String,
}

impl PaperFolderChangeSubscriptionType {
    pub fn new(description: String) -> Self {
        PaperFolderChangeSubscriptionType {
            description,
        }
    }

}

const PAPER_FOLDER_CHANGE_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderChangeSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderChangeSubscriptionType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_CHANGE_SUBSCRIPTION_TYPE_FIELDS))
            }
        }
        Ok(PaperFolderChangeSubscriptionType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderChangeSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderChangeSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderChangeSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderChangeSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderChangeSubscriptionType", PAPER_FOLDER_CHANGE_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderChangeSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderChangeSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder archived.
#[derive(Debug)]
pub struct PaperFolderDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_DELETED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderDeletedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_DELETED_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderDeletedDetails", PAPER_FOLDER_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderDeletedType {
    pub description: String,
}

impl PaperFolderDeletedType {
    pub fn new(description: String) -> Self {
        PaperFolderDeletedType {
            description,
        }
    }

}

const PAPER_FOLDER_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderDeletedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_DELETED_TYPE_FIELDS))
            }
        }
        Ok(PaperFolderDeletedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderDeletedType", PAPER_FOLDER_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed a Paper folder.
#[derive(Debug)]
pub struct PaperFolderFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderFollowedDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderFollowedDetails", PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderFollowedType {
    pub description: String,
}

impl PaperFolderFollowedType {
    pub fn new(description: String) -> Self {
        PaperFolderFollowedType {
            description,
        }
    }

}

const PAPER_FOLDER_FOLLOWED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderFollowedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderFollowedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_FOLLOWED_TYPE_FIELDS))
            }
        }
        Ok(PaperFolderFollowedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderFollowedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderFollowedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderFollowedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderFollowedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderFollowedType", PAPER_FOLDER_FOLLOWED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderFollowedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderFollowedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder's logged information.
#[derive(Debug)]
pub struct PaperFolderLogInfo {
    /// Papers folder Id.
    pub folder_id: String,
    /// Paper folder name.
    pub folder_name: String,
}

impl PaperFolderLogInfo {
    pub fn new(folder_id: String, folder_name: String) -> Self {
        PaperFolderLogInfo {
            folder_id,
            folder_name,
        }
    }

}

const PAPER_FOLDER_LOG_INFO_FIELDS: &[&str] = &["folder_id",
                                                "folder_name"];
impl PaperFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderLogInfo, V::Error> {
        use serde::de;
        let mut field_folder_id = None;
        let mut field_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "folder_id" => {
                    if field_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("folder_id"));
                    }
                    field_folder_id = Some(map.next_value()?);
                }
                "folder_name" => {
                    if field_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("folder_name"));
                    }
                    field_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_LOG_INFO_FIELDS))
            }
        }
        Ok(PaperFolderLogInfo {
            folder_id: field_folder_id.ok_or_else(|| de::Error::missing_field("folder_id"))?,
            folder_name: field_folder_name.ok_or_else(|| de::Error::missing_field("folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_id", &self.folder_id)?;
        s.serialize_field("folder_name", &self.folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderLogInfo", PAPER_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder shared with team member.
#[derive(Debug)]
pub struct PaperFolderTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_event_uuid = None;
        while let Some(key) = map.next_key()? {
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(PaperFolderTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| de::Error::missing_field("event_uuid"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderTeamInviteDetails", PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderTeamInviteType {
    pub description: String,
}

impl PaperFolderTeamInviteType {
    pub fn new(description: String) -> Self {
        PaperFolderTeamInviteType {
            description,
        }
    }

}

const PAPER_FOLDER_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperFolderTeamInviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PAPER_FOLDER_TEAM_INVITE_TYPE_FIELDS))
            }
        }
        Ok(PaperFolderTeamInviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperFolderTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderTeamInviteType", PAPER_FOLDER_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can share Paper documents externally.
#[derive(Debug)]
pub enum PaperMemberPolicy {
    AnyoneWithLink,
    OnlyTeam,
    TeamAndExplicitlyShared,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PaperMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "anyone_with_link" => Ok(PaperMemberPolicy::AnyoneWithLink),
                    "only_team" => Ok(PaperMemberPolicy::OnlyTeam),
                    "team_and_explicitly_shared" => Ok(PaperMemberPolicy::TeamAndExplicitlyShared),
                    _ => Ok(PaperMemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["anyone_with_link",
                                    "only_team",
                                    "team_and_explicitly_shared",
                                    "other"];
        deserializer.deserialize_struct("PaperMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperMemberPolicy::AnyoneWithLink => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "anyone_with_link")?;
                s.end()
            }
            PaperMemberPolicy::OnlyTeam => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "only_team")?;
                s.end()
            }
            PaperMemberPolicy::TeamAndExplicitlyShared => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "team_and_explicitly_shared")?;
                s.end()
            }
            PaperMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// A user or group
#[derive(Debug)]
pub enum ParticipantLogInfo {
    /// A user with a Dropbox account.
    User(UserLogInfo),
    /// Group details.
    Group(GroupLogInfo),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ParticipantLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ParticipantLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ParticipantLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ParticipantLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group" => Ok(ParticipantLogInfo::Group(GroupLogInfo::internal_deserialize(map)?)),
                    _ => Ok(ParticipantLogInfo::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user",
                                    "group",
                                    "other"];
        deserializer.deserialize_struct("ParticipantLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ParticipantLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ParticipantLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ParticipantLogInfo::Group(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ParticipantLogInfo", 4)?;
                s.serialize_field(".tag", "group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ParticipantLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed password.
#[derive(Debug)]
pub struct PasswordChangeDetails {
}

impl Default for PasswordChangeDetails {
    fn default() -> Self {
        PasswordChangeDetails {
        }
    }
}

const PASSWORD_CHANGE_DETAILS_FIELDS: &[&str] = &[];
impl PasswordChangeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordChangeDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_CHANGE_DETAILS_FIELDS));
        }
        Ok(PasswordChangeDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordChangeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordChangeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordChangeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordChangeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordChangeDetails", PASSWORD_CHANGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordChangeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordChangeDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordChangeType {
    pub description: String,
}

impl PasswordChangeType {
    pub fn new(description: String) -> Self {
        PasswordChangeType {
            description,
        }
    }

}

const PASSWORD_CHANGE_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordChangeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordChangeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PASSWORD_CHANGE_TYPE_FIELDS))
            }
        }
        Ok(PasswordChangeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordChangeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordChangeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordChangeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordChangeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordChangeType", PASSWORD_CHANGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordChangeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordChangeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset all team member passwords.
#[derive(Debug)]
pub struct PasswordResetAllDetails {
}

impl Default for PasswordResetAllDetails {
    fn default() -> Self {
        PasswordResetAllDetails {
        }
    }
}

const PASSWORD_RESET_ALL_DETAILS_FIELDS: &[&str] = &[];
impl PasswordResetAllDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetAllDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_RESET_ALL_DETAILS_FIELDS));
        }
        Ok(PasswordResetAllDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetAllDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetAllDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetAllDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetAllDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetAllDetails", PASSWORD_RESET_ALL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetAllDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetAllDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordResetAllType {
    pub description: String,
}

impl PasswordResetAllType {
    pub fn new(description: String) -> Self {
        PasswordResetAllType {
            description,
        }
    }

}

const PASSWORD_RESET_ALL_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordResetAllType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetAllType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PASSWORD_RESET_ALL_TYPE_FIELDS))
            }
        }
        Ok(PasswordResetAllType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetAllType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetAllType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetAllType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetAllType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetAllType", PASSWORD_RESET_ALL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetAllType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordResetAllType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset password.
#[derive(Debug)]
pub struct PasswordResetDetails {
}

impl Default for PasswordResetDetails {
    fn default() -> Self {
        PasswordResetDetails {
        }
    }
}

const PASSWORD_RESET_DETAILS_FIELDS: &[&str] = &[];
impl PasswordResetDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, PASSWORD_RESET_DETAILS_FIELDS));
        }
        Ok(PasswordResetDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetDetails", PASSWORD_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordResetType {
    pub description: String,
}

impl PasswordResetType {
    pub fn new(description: String) -> Self {
        PasswordResetType {
            description,
        }
    }

}

const PASSWORD_RESET_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordResetType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PASSWORD_RESET_TYPE_FIELDS))
            }
        }
        Ok(PasswordResetType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PasswordResetType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetType", PASSWORD_RESET_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordResetType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Path's details.
#[derive(Debug)]
pub struct PathLogInfo {
    /// Path relative to the namespace containing the content.
    pub namespace_relative: NamespaceRelativePathLogInfo,
    /// Fully qualified path relative to event's context. Might be missing due to historical data
    /// gap.
    pub contextual: Option<FilePath>,
}

impl PathLogInfo {
    pub fn new(namespace_relative: NamespaceRelativePathLogInfo) -> Self {
        PathLogInfo {
            namespace_relative,
            contextual: None,
        }
    }

    pub fn with_contextual(mut self, value: Option<FilePath>) -> Self {
        self.contextual = value;
        self
    }

}

const PATH_LOG_INFO_FIELDS: &[&str] = &["namespace_relative",
                                        "contextual"];
impl PathLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PathLogInfo, V::Error> {
        use serde::de;
        let mut field_namespace_relative = None;
        let mut field_contextual = None;
        while let Some(key) = map.next_key()? {
            match key {
                "namespace_relative" => {
                    if field_namespace_relative.is_some() {
                        return Err(de::Error::duplicate_field("namespace_relative"));
                    }
                    field_namespace_relative = Some(map.next_value()?);
                }
                "contextual" => {
                    if field_contextual.is_some() {
                        return Err(de::Error::duplicate_field("contextual"));
                    }
                    field_contextual = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PATH_LOG_INFO_FIELDS))
            }
        }
        Ok(PathLogInfo {
            namespace_relative: field_namespace_relative.ok_or_else(|| de::Error::missing_field("namespace_relative"))?,
            contextual: field_contextual,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("namespace_relative", &self.namespace_relative)?;
        s.serialize_field("contextual", &self.contextual)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PathLogInfo", PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PathLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled or disabled the ability of team members to permanently delete content.
#[derive(Debug)]
pub struct PermanentDeleteChangePolicyDetails {
    /// New permanent delete content policy.
    pub new_value: ContentPermanentDeletePolicy,
    /// Previous permanent delete content policy. Might be missing due to historical data gap.
    pub previous_value: Option<ContentPermanentDeletePolicy>,
}

impl PermanentDeleteChangePolicyDetails {
    pub fn new(new_value: ContentPermanentDeletePolicy) -> Self {
        PermanentDeleteChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ContentPermanentDeletePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl PermanentDeleteChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PermanentDeleteChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(PermanentDeleteChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PermanentDeleteChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PermanentDeleteChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PermanentDeleteChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PermanentDeleteChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PermanentDeleteChangePolicyDetails", PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PermanentDeleteChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PermanentDeleteChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PermanentDeleteChangePolicyType {
    pub description: String,
}

impl PermanentDeleteChangePolicyType {
    pub fn new(description: String) -> Self {
        PermanentDeleteChangePolicyType {
            description,
        }
    }

}

const PERMANENT_DELETE_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PermanentDeleteChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PermanentDeleteChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PERMANENT_DELETE_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(PermanentDeleteChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PermanentDeleteChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PermanentDeleteChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PermanentDeleteChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PermanentDeleteChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PermanentDeleteChangePolicyType", PERMANENT_DELETE_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PermanentDeleteChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PermanentDeleteChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PlacementRestriction {
    EuropeOnly,
    None,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PlacementRestriction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PlacementRestriction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PlacementRestriction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "europe_only" => Ok(PlacementRestriction::EuropeOnly),
                    "none" => Ok(PlacementRestriction::None),
                    _ => Ok(PlacementRestriction::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["europe_only",
                                    "none",
                                    "other"];
        deserializer.deserialize_struct("PlacementRestriction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PlacementRestriction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PlacementRestriction::EuropeOnly => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "europe_only")?;
                s.end()
            }
            PlacementRestriction::None => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "none")?;
                s.end()
            }
            PlacementRestriction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Provides the indices of the source asset and the destination asset for a relocate action.
#[derive(Debug)]
pub struct RelocateAssetReferencesLogInfo {
    /// Source asset position in the Assets list.
    pub src_asset_index: u64,
    /// Destination asset position in the Assets list.
    pub dest_asset_index: u64,
}

impl RelocateAssetReferencesLogInfo {
    pub fn new(src_asset_index: u64, dest_asset_index: u64) -> Self {
        RelocateAssetReferencesLogInfo {
            src_asset_index,
            dest_asset_index,
        }
    }

}

const RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS: &[&str] = &["src_asset_index",
                                                             "dest_asset_index"];
impl RelocateAssetReferencesLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<RelocateAssetReferencesLogInfo, V::Error> {
        use serde::de;
        let mut field_src_asset_index = None;
        let mut field_dest_asset_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "src_asset_index" => {
                    if field_src_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("src_asset_index"));
                    }
                    field_src_asset_index = Some(map.next_value()?);
                }
                "dest_asset_index" => {
                    if field_dest_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("dest_asset_index"));
                    }
                    field_dest_asset_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS))
            }
        }
        Ok(RelocateAssetReferencesLogInfo {
            src_asset_index: field_src_asset_index.ok_or_else(|| de::Error::missing_field("src_asset_index"))?,
            dest_asset_index: field_dest_asset_index.ok_or_else(|| de::Error::missing_field("dest_asset_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("src_asset_index", &self.src_asset_index)?;
        s.serialize_field("dest_asset_index", &self.dest_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RelocateAssetReferencesLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RelocateAssetReferencesLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelocateAssetReferencesLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RelocateAssetReferencesLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RelocateAssetReferencesLogInfo", RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RelocateAssetReferencesLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RelocateAssetReferencesLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reseller information.
#[derive(Debug)]
pub struct ResellerLogInfo {
    /// Reseller name.
    pub reseller_name: String,
    /// Reseller email.
    pub reseller_email: EmailAddress,
}

impl ResellerLogInfo {
    pub fn new(reseller_name: String, reseller_email: EmailAddress) -> Self {
        ResellerLogInfo {
            reseller_name,
            reseller_email,
        }
    }

}

const RESELLER_LOG_INFO_FIELDS: &[&str] = &["reseller_name",
                                            "reseller_email"];
impl ResellerLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerLogInfo, V::Error> {
        use serde::de;
        let mut field_reseller_name = None;
        let mut field_reseller_email = None;
        while let Some(key) = map.next_key()? {
            match key {
                "reseller_name" => {
                    if field_reseller_name.is_some() {
                        return Err(de::Error::duplicate_field("reseller_name"));
                    }
                    field_reseller_name = Some(map.next_value()?);
                }
                "reseller_email" => {
                    if field_reseller_email.is_some() {
                        return Err(de::Error::duplicate_field("reseller_email"));
                    }
                    field_reseller_email = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RESELLER_LOG_INFO_FIELDS))
            }
        }
        Ok(ResellerLogInfo {
            reseller_name: field_reseller_name.ok_or_else(|| de::Error::missing_field("reseller_name"))?,
            reseller_email: field_reseller_email.ok_or_else(|| de::Error::missing_field("reseller_email"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("reseller_name", &self.reseller_name)?;
        s.serialize_field("reseller_email", &self.reseller_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerLogInfo", RESELLER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionEndDetails {
}

impl Default for ResellerSupportSessionEndDetails {
    fn default() -> Self {
        ResellerSupportSessionEndDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS: &[&str] = &[];
impl ResellerSupportSessionEndDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionEndDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS));
        }
        Ok(ResellerSupportSessionEndDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionEndDetails", RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionEndDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ResellerSupportSessionEndType {
    pub description: String,
}

impl ResellerSupportSessionEndType {
    pub fn new(description: String) -> Self {
        ResellerSupportSessionEndType {
            description,
        }
    }

}

const RESELLER_SUPPORT_SESSION_END_TYPE_FIELDS: &[&str] = &["description"];
impl ResellerSupportSessionEndType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionEndType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_END_TYPE_FIELDS))
            }
        }
        Ok(ResellerSupportSessionEndType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionEndType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionEndType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionEndType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionEndType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionEndType", RESELLER_SUPPORT_SESSION_END_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionEndType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportSessionEndType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionStartDetails {
}

impl Default for ResellerSupportSessionStartDetails {
    fn default() -> Self {
        ResellerSupportSessionStartDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS: &[&str] = &[];
impl ResellerSupportSessionStartDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionStartDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS));
        }
        Ok(ResellerSupportSessionStartDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionStartDetails", RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ResellerSupportSessionStartType {
    pub description: String,
}

impl ResellerSupportSessionStartType {
    pub fn new(description: String) -> Self {
        ResellerSupportSessionStartType {
            description,
        }
    }

}

const RESELLER_SUPPORT_SESSION_START_TYPE_FIELDS: &[&str] = &["description"];
impl ResellerSupportSessionStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionStartType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RESELLER_SUPPORT_SESSION_START_TYPE_FIELDS))
            }
        }
        Ok(ResellerSupportSessionStartType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionStartType", RESELLER_SUPPORT_SESSION_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportSessionStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Session's logged information.
#[derive(Debug)]
pub enum SessionLogInfo {
    Web(WebSessionLogInfo),
    Desktop(DesktopSessionLogInfo),
    Mobile(MobileSessionLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for SessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SessionLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "web" => Ok(SessionLogInfo::Web(WebSessionLogInfo::internal_deserialize(map)?)),
                    "desktop" => Ok(SessionLogInfo::Desktop(DesktopSessionLogInfo::internal_deserialize(map)?)),
                    "mobile" => Ok(SessionLogInfo::Mobile(MobileSessionLogInfo::internal_deserialize(map)?)),
                    _ => Ok(SessionLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &[&str] = &["mobile",
                                    "mobile",
                                    "mobile"];
        deserializer.deserialize_struct("SessionLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            SessionLogInfo::Web(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "web")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Desktop(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "desktop")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Mobile(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "mobile")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Added the team to a shared folder.
#[derive(Debug)]
pub struct SfAddGroupDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Team name.
    pub team_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfAddGroupDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String, team_name: String) -> Self {
        SfAddGroupDetails {
            target_asset_index,
            original_folder_name,
            team_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_ADD_GROUP_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name",
                                               "team_name",
                                               "sharing_permission"];
impl SfAddGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfAddGroupDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_team_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ADD_GROUP_DETAILS_FIELDS))
            }
        }
        Ok(SfAddGroupDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAddGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAddGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAddGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAddGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAddGroupDetails", SF_ADD_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAddGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAddGroupDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfAddGroupType {
    pub description: String,
}

impl SfAddGroupType {
    pub fn new(description: String) -> Self {
        SfAddGroupType {
            description,
        }
    }

}

const SF_ADD_GROUP_TYPE_FIELDS: &[&str] = &["description"];
impl SfAddGroupType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfAddGroupType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ADD_GROUP_TYPE_FIELDS))
            }
        }
        Ok(SfAddGroupType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAddGroupType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAddGroupType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAddGroupType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAddGroupType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAddGroupType", SF_ADD_GROUP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAddGroupType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAddGroupType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Allowed non collaborators to view links to files in a shared folder.
#[derive(Debug)]
pub struct SfAllowNonMembersToViewSharedLinksDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SfAllowNonMembersToViewSharedLinksDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfAllowNonMembersToViewSharedLinksDetails {
            target_asset_index,
            original_folder_name,
            shared_folder_type: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                                            "original_folder_name",
                                                                            "shared_folder_type"];
impl SfAllowNonMembersToViewSharedLinksDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfAllowNonMembersToViewSharedLinksDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS))
            }
        }
        Ok(SfAllowNonMembersToViewSharedLinksDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            shared_folder_type: field_shared_folder_type,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAllowNonMembersToViewSharedLinksDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAllowNonMembersToViewSharedLinksDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAllowNonMembersToViewSharedLinksDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAllowNonMembersToViewSharedLinksDetails", SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAllowNonMembersToViewSharedLinksDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAllowNonMembersToViewSharedLinksDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfAllowNonMembersToViewSharedLinksType {
    pub description: String,
}

impl SfAllowNonMembersToViewSharedLinksType {
    pub fn new(description: String) -> Self {
        SfAllowNonMembersToViewSharedLinksType {
            description,
        }
    }

}

const SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_TYPE_FIELDS: &[&str] = &["description"];
impl SfAllowNonMembersToViewSharedLinksType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfAllowNonMembersToViewSharedLinksType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_TYPE_FIELDS))
            }
        }
        Ok(SfAllowNonMembersToViewSharedLinksType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAllowNonMembersToViewSharedLinksType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAllowNonMembersToViewSharedLinksType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfAllowNonMembersToViewSharedLinksType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAllowNonMembersToViewSharedLinksType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAllowNonMembersToViewSharedLinksType", SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAllowNonMembersToViewSharedLinksType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAllowNonMembersToViewSharedLinksType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Admin settings: team members see a warning before sharing folders outside the team (DEPRECATED
/// FEATURE).
#[derive(Debug)]
pub struct SfExternalInviteWarnDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SfExternalInviteWarnDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfExternalInviteWarnDetails {
            target_asset_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                          "original_folder_name",
                                                          "new_sharing_permission",
                                                          "previous_sharing_permission"];
impl SfExternalInviteWarnDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfExternalInviteWarnDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS))
            }
        }
        Ok(SfExternalInviteWarnDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfExternalInviteWarnDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfExternalInviteWarnDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfExternalInviteWarnDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfExternalInviteWarnDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfExternalInviteWarnDetails", SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfExternalInviteWarnDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfExternalInviteWarnDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfExternalInviteWarnType {
    pub description: String,
}

impl SfExternalInviteWarnType {
    pub fn new(description: String) -> Self {
        SfExternalInviteWarnType {
            description,
        }
    }

}

const SF_EXTERNAL_INVITE_WARN_TYPE_FIELDS: &[&str] = &["description"];
impl SfExternalInviteWarnType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfExternalInviteWarnType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_EXTERNAL_INVITE_WARN_TYPE_FIELDS))
            }
        }
        Ok(SfExternalInviteWarnType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfExternalInviteWarnType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfExternalInviteWarnType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfExternalInviteWarnType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfExternalInviteWarnType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfExternalInviteWarnType", SF_EXTERNAL_INVITE_WARN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfExternalInviteWarnType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfExternalInviteWarnType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a Facebook user's role in a shared folder.
#[derive(Debug)]
pub struct SfFbInviteChangeRoleDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
}

impl SfFbInviteChangeRoleDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbInviteChangeRoleDetails {
            target_asset_index,
            original_folder_name,
            previous_sharing_permission: None,
            new_sharing_permission: None,
        }
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

}

const SF_FB_INVITE_CHANGE_ROLE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                           "original_folder_name",
                                                           "previous_sharing_permission",
                                                           "new_sharing_permission"];
impl SfFbInviteChangeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbInviteChangeRoleDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_previous_sharing_permission = None;
        let mut field_new_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_INVITE_CHANGE_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SfFbInviteChangeRoleDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            previous_sharing_permission: field_previous_sharing_permission,
            new_sharing_permission: field_new_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteChangeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteChangeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteChangeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteChangeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteChangeRoleDetails", SF_FB_INVITE_CHANGE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteChangeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteChangeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbInviteChangeRoleType {
    pub description: String,
}

impl SfFbInviteChangeRoleType {
    pub fn new(description: String) -> Self {
        SfFbInviteChangeRoleType {
            description,
        }
    }

}

const SF_FB_INVITE_CHANGE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbInviteChangeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbInviteChangeRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_INVITE_CHANGE_ROLE_TYPE_FIELDS))
            }
        }
        Ok(SfFbInviteChangeRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteChangeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteChangeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteChangeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteChangeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteChangeRoleType", SF_FB_INVITE_CHANGE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteChangeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteChangeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited Facebook users to a shared folder.
#[derive(Debug)]
pub struct SfFbInviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfFbInviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbInviteDetails {
            target_asset_index,
            original_folder_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_FB_INVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name",
                                               "sharing_permission"];
impl SfFbInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbInviteDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfFbInviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteDetails", SF_FB_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbInviteType {
    pub description: String,
}

impl SfFbInviteType {
    pub fn new(description: String) -> Self {
        SfFbInviteType {
            description,
        }
    }

}

const SF_FB_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbInviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_INVITE_TYPE_FIELDS))
            }
        }
        Ok(SfFbInviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteType", SF_FB_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Uninvited a Facebook user from a shared folder.
#[derive(Debug)]
pub struct SfFbUninviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfFbUninviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbUninviteDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_FB_UNINVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                 "original_folder_name"];
impl SfFbUninviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbUninviteDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_UNINVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfFbUninviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbUninviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbUninviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbUninviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbUninviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbUninviteDetails", SF_FB_UNINVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbUninviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbUninviteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbUninviteType {
    pub description: String,
}

impl SfFbUninviteType {
    pub fn new(description: String) -> Self {
        SfFbUninviteType {
            description,
        }
    }

}

const SF_FB_UNINVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbUninviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfFbUninviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_FB_UNINVITE_TYPE_FIELDS))
            }
        }
        Ok(SfFbUninviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbUninviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbUninviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfFbUninviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbUninviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbUninviteType", SF_FB_UNINVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbUninviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbUninviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited a group to a shared folder.
#[derive(Debug)]
pub struct SfInviteGroupDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
}

impl SfInviteGroupDetails {
    pub fn new(target_asset_index: u64) -> Self {
        SfInviteGroupDetails {
            target_asset_index,
        }
    }

}

const SF_INVITE_GROUP_DETAILS_FIELDS: &[&str] = &["target_asset_index"];
impl SfInviteGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfInviteGroupDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_INVITE_GROUP_DETAILS_FIELDS))
            }
        }
        Ok(SfInviteGroupDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfInviteGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfInviteGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfInviteGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfInviteGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfInviteGroupDetails", SF_INVITE_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfInviteGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfInviteGroupDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfInviteGroupType {
    pub description: String,
}

impl SfInviteGroupType {
    pub fn new(description: String) -> Self {
        SfInviteGroupType {
            description,
        }
    }

}

const SF_INVITE_GROUP_TYPE_FIELDS: &[&str] = &["description"];
impl SfInviteGroupType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfInviteGroupType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_INVITE_GROUP_TYPE_FIELDS))
            }
        }
        Ok(SfInviteGroupType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfInviteGroupType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfInviteGroupType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfInviteGroupType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfInviteGroupType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfInviteGroupType", SF_INVITE_GROUP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfInviteGroupType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfInviteGroupType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Granted access to a shared folder.
#[derive(Debug)]
pub struct SfTeamGrantAccessDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamGrantAccessDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamGrantAccessDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                       "original_folder_name"];
impl SfTeamGrantAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamGrantAccessDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamGrantAccessDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamGrantAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamGrantAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamGrantAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamGrantAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamGrantAccessDetails", SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamGrantAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamGrantAccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamGrantAccessType {
    pub description: String,
}

impl SfTeamGrantAccessType {
    pub fn new(description: String) -> Self {
        SfTeamGrantAccessType {
            description,
        }
    }

}

const SF_TEAM_GRANT_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamGrantAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamGrantAccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_GRANT_ACCESS_TYPE_FIELDS))
            }
        }
        Ok(SfTeamGrantAccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamGrantAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamGrantAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamGrantAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamGrantAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamGrantAccessType", SF_TEAM_GRANT_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamGrantAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamGrantAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed a team member's role in a shared folder.
#[derive(Debug)]
pub struct SfTeamInviteChangeRoleDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SfTeamInviteChangeRoleDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamInviteChangeRoleDetails {
            target_asset_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                             "original_folder_name",
                                                             "new_sharing_permission",
                                                             "previous_sharing_permission"];
impl SfTeamInviteChangeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamInviteChangeRoleDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamInviteChangeRoleDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteChangeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteChangeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteChangeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteChangeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteChangeRoleDetails", SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteChangeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteChangeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamInviteChangeRoleType {
    pub description: String,
}

impl SfTeamInviteChangeRoleType {
    pub fn new(description: String) -> Self {
        SfTeamInviteChangeRoleType {
            description,
        }
    }

}

const SF_TEAM_INVITE_CHANGE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamInviteChangeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamInviteChangeRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_CHANGE_ROLE_TYPE_FIELDS))
            }
        }
        Ok(SfTeamInviteChangeRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteChangeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteChangeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteChangeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteChangeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteChangeRoleType", SF_TEAM_INVITE_CHANGE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteChangeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteChangeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited team members to a shared folder.
#[derive(Debug)]
pub struct SfTeamInviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamInviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamInviteDetails {
            target_asset_index,
            original_folder_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                 "original_folder_name",
                                                 "sharing_permission"];
impl SfTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamInviteDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamInviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteDetails", SF_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamInviteType {
    pub description: String,
}

impl SfTeamInviteType {
    pub fn new(description: String) -> Self {
        SfTeamInviteType {
            description,
        }
    }

}

const SF_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamInviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_INVITE_TYPE_FIELDS))
            }
        }
        Ok(SfTeamInviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteType", SF_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined a team member's shared folder.
#[derive(Debug)]
pub struct SfTeamJoinDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamJoinDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamJoinDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_JOIN_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name"];
impl SfTeamJoinDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamJoinDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamJoinDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinDetails", SF_TEAM_JOIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined a team member's shared folder from a link.
#[derive(Debug)]
pub struct SfTeamJoinFromOobLinkDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared link token key.
    pub token_key: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamJoinFromOobLinkDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamJoinFromOobLinkDetails {
            target_asset_index,
            original_folder_name,
            token_key: None,
            sharing_permission: None,
        }
    }

    pub fn with_token_key(mut self, value: Option<String>) -> Self {
        self.token_key = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                             "original_folder_name",
                                                             "token_key",
                                                             "sharing_permission"];
impl SfTeamJoinFromOobLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamJoinFromOobLinkDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_token_key = None;
        let mut field_sharing_permission = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamJoinFromOobLinkDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
            token_key: field_token_key,
            sharing_permission: field_sharing_permission,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("token_key", &self.token_key)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinFromOobLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinFromOobLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinFromOobLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinFromOobLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinFromOobLinkDetails", SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinFromOobLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinFromOobLinkDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamJoinFromOobLinkType {
    pub description: String,
}

impl SfTeamJoinFromOobLinkType {
    pub fn new(description: String) -> Self {
        SfTeamJoinFromOobLinkType {
            description,
        }
    }

}

const SF_TEAM_JOIN_FROM_OOB_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamJoinFromOobLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamJoinFromOobLinkType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_FROM_OOB_LINK_TYPE_FIELDS))
            }
        }
        Ok(SfTeamJoinFromOobLinkType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinFromOobLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinFromOobLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinFromOobLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinFromOobLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinFromOobLinkType", SF_TEAM_JOIN_FROM_OOB_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinFromOobLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinFromOobLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamJoinType {
    pub description: String,
}

impl SfTeamJoinType {
    pub fn new(description: String) -> Self {
        SfTeamJoinType {
            description,
        }
    }

}

const SF_TEAM_JOIN_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamJoinType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamJoinType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_JOIN_TYPE_FIELDS))
            }
        }
        Ok(SfTeamJoinType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinType", SF_TEAM_JOIN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared a folder with a team member.
#[derive(Debug)]
pub struct SfTeamUninviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamUninviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamUninviteDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_UNINVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                   "original_folder_name"];
impl SfTeamUninviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamUninviteDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_UNINVITE_DETAILS_FIELDS))
            }
        }
        Ok(SfTeamUninviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| de::Error::missing_field("original_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamUninviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamUninviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamUninviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamUninviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamUninviteDetails", SF_TEAM_UNINVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamUninviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamUninviteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamUninviteType {
    pub description: String,
}

impl SfTeamUninviteType {
    pub fn new(description: String) -> Self {
        SfTeamUninviteType {
            description,
        }
    }

}

const SF_TEAM_UNINVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamUninviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SfTeamUninviteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SF_TEAM_UNINVITE_TYPE_FIELDS))
            }
        }
        Ok(SfTeamUninviteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamUninviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamUninviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SfTeamUninviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamUninviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamUninviteType", SF_TEAM_UNINVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamUninviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamUninviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent an email invitation to the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddInviteesDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// A list of invitees.
    pub invitees: Vec<EmailAddress>,
}

impl SharedContentAddInviteesDetails {
    pub fn new(
        shared_content_access_level: super::sharing::AccessLevel,
        invitees: Vec<EmailAddress>,
    ) -> Self {
        SharedContentAddInviteesDetails {
            shared_content_access_level,
            invitees,
        }
    }

}

const SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                              "invitees"];
impl SharedContentAddInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddInviteesDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_access_level = None;
        let mut field_invitees = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddInviteesDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| de::Error::missing_field("shared_content_access_level"))?,
            invitees: field_invitees.ok_or_else(|| de::Error::missing_field("invitees"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("invitees", &self.invitees)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddInviteesDetails", SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddInviteesDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddInviteesType {
    pub description: String,
}

impl SharedContentAddInviteesType {
    pub fn new(description: String) -> Self {
        SharedContentAddInviteesType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_INVITEES_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddInviteesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddInviteesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_INVITEES_TYPE_FIELDS))
            }
        }
        Ok(SharedContentAddInviteesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddInviteesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddInviteesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddInviteesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddInviteesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddInviteesType", SHARED_CONTENT_ADD_INVITEES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddInviteesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddInviteesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an expiry to the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddLinkExpiryDetails {
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentAddLinkExpiryDetails {
    fn default() -> Self {
        SharedContentAddLinkExpiryDetails {
            new_value: None,
        }
    }
}

const SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SharedContentAddLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddLinkExpiryDetails {
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkExpiryDetails", SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddLinkExpiryType {
    pub description: String,
}

impl SharedContentAddLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentAddLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentAddLinkExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkExpiryType", SHARED_CONTENT_ADD_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a password to the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddLinkPasswordDetails {
}

impl Default for SharedContentAddLinkPasswordDetails {
    fn default() -> Self {
        SharedContentAddLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentAddLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkPasswordDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS));
        }
        Ok(SharedContentAddLinkPasswordDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkPasswordDetails", SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentAddLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddLinkPasswordType {
    pub description: String,
}

impl SharedContentAddLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentAddLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkPasswordType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_LINK_PASSWORD_TYPE_FIELDS))
            }
        }
        Ok(SharedContentAddLinkPasswordType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkPasswordType", SHARED_CONTENT_ADD_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users and/or groups to the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentAddMemberDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
}

impl SharedContentAddMemberDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedContentAddMemberDetails {
            shared_content_access_level,
        }
    }

}

const SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["shared_content_access_level"];
impl SharedContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddMemberDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentAddMemberDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| de::Error::missing_field("shared_content_access_level"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddMemberDetails", SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddMemberType {
    pub description: String,
}

impl SharedContentAddMemberType {
    pub fn new(description: String) -> Self {
        SharedContentAddMemberType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_ADD_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(SharedContentAddMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddMemberType", SHARED_CONTENT_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can download the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeDownloadsPolicyDetails {
    /// New downloads policy.
    pub new_value: DownloadPolicyType,
    /// Previous downloads policy. Might be missing due to historical data gap.
    pub previous_value: Option<DownloadPolicyType>,
}

impl SharedContentChangeDownloadsPolicyDetails {
    pub fn new(new_value: DownloadPolicyType) -> Self {
        SharedContentChangeDownloadsPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<DownloadPolicyType>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl SharedContentChangeDownloadsPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeDownloadsPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeDownloadsPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeDownloadsPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeDownloadsPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeDownloadsPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeDownloadsPolicyDetails", SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeDownloadsPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeDownloadsPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeDownloadsPolicyType {
    pub description: String,
}

impl SharedContentChangeDownloadsPolicyType {
    pub fn new(description: String) -> Self {
        SharedContentChangeDownloadsPolicyType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeDownloadsPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeDownloadsPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeDownloadsPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeDownloadsPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeDownloadsPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeDownloadsPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeDownloadsPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeDownloadsPolicyType", SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeDownloadsPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeDownloadsPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of an invitee to a shared file or folder before the invitation was
/// claimed.
#[derive(Debug)]
pub struct SharedContentChangeInviteeRoleDetails {
    /// New access level.
    pub new_access_level: super::sharing::AccessLevel,
    /// The invitee whose role was changed.
    pub invitee: EmailAddress,
    /// Previous access level. Might be missing due to historical data gap.
    pub previous_access_level: Option<super::sharing::AccessLevel>,
}

impl SharedContentChangeInviteeRoleDetails {
    pub fn new(new_access_level: super::sharing::AccessLevel, invitee: EmailAddress) -> Self {
        SharedContentChangeInviteeRoleDetails {
            new_access_level,
            invitee,
            previous_access_level: None,
        }
    }

    pub fn with_previous_access_level(
        mut self,
        value: Option<super::sharing::AccessLevel>,
    ) -> Self {
        self.previous_access_level = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS: &[&str] = &["new_access_level",
                                                                     "invitee",
                                                                     "previous_access_level"];
impl SharedContentChangeInviteeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeInviteeRoleDetails, V::Error> {
        use serde::de;
        let mut field_new_access_level = None;
        let mut field_invitee = None;
        let mut field_previous_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_access_level" => {
                    if field_new_access_level.is_some() {
                        return Err(de::Error::duplicate_field("new_access_level"));
                    }
                    field_new_access_level = Some(map.next_value()?);
                }
                "invitee" => {
                    if field_invitee.is_some() {
                        return Err(de::Error::duplicate_field("invitee"));
                    }
                    field_invitee = Some(map.next_value()?);
                }
                "previous_access_level" => {
                    if field_previous_access_level.is_some() {
                        return Err(de::Error::duplicate_field("previous_access_level"));
                    }
                    field_previous_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeInviteeRoleDetails {
            new_access_level: field_new_access_level.ok_or_else(|| de::Error::missing_field("new_access_level"))?,
            invitee: field_invitee.ok_or_else(|| de::Error::missing_field("invitee"))?,
            previous_access_level: field_previous_access_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_access_level", &self.new_access_level)?;
        s.serialize_field("invitee", &self.invitee)?;
        s.serialize_field("previous_access_level", &self.previous_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeInviteeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeInviteeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeInviteeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeInviteeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeInviteeRoleDetails", SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeInviteeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeInviteeRoleDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeInviteeRoleType {
    pub description: String,
}

impl SharedContentChangeInviteeRoleType {
    pub fn new(description: String) -> Self {
        SharedContentChangeInviteeRoleType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_INVITEE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeInviteeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeInviteeRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_INVITEE_ROLE_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeInviteeRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeInviteeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeInviteeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeInviteeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeInviteeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeInviteeRoleType", SHARED_CONTENT_CHANGE_INVITEE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeInviteeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeInviteeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the audience of the link for a shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkAudienceDetails {
    /// New link audience value.
    pub new_value: super::sharing::LinkAudience,
    /// Previous link audience value.
    pub previous_value: Option<super::sharing::LinkAudience>,
}

impl SharedContentChangeLinkAudienceDetails {
    pub fn new(new_value: super::sharing::LinkAudience) -> Self {
        SharedContentChangeLinkAudienceDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::LinkAudience>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl SharedContentChangeLinkAudienceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkAudienceDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkAudienceDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkAudienceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkAudienceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkAudienceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkAudienceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkAudienceDetails", SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkAudienceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkAudienceDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkAudienceType {
    pub description: String,
}

impl SharedContentChangeLinkAudienceType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkAudienceType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_AUDIENCE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkAudienceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkAudienceType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_AUDIENCE_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkAudienceType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkAudienceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkAudienceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkAudienceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkAudienceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkAudienceType", SHARED_CONTENT_CHANGE_LINK_AUDIENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkAudienceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkAudienceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the expiry of the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkExpiryDetails {
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
    /// Previous shared content link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentChangeLinkExpiryDetails {
    fn default() -> Self {
        SharedContentChangeLinkExpiryDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                    "previous_value"];
impl SharedContentChangeLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkExpiryDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkExpiryDetails", SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkExpiryDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkExpiryType {
    pub description: String,
}

impl SharedContentChangeLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkExpiryType", SHARED_CONTENT_CHANGE_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the password on the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkPasswordDetails {
}

impl Default for SharedContentChangeLinkPasswordDetails {
    fn default() -> Self {
        SharedContentChangeLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentChangeLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkPasswordDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS));
        }
        Ok(SharedContentChangeLinkPasswordDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkPasswordDetails", SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentChangeLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkPasswordType {
    pub description: String,
}

impl SharedContentChangeLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkPasswordType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_LINK_PASSWORD_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeLinkPasswordType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkPasswordType", SHARED_CONTENT_CHANGE_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the access type of a shared file or folder member.
#[derive(Debug)]
pub struct SharedContentChangeMemberRoleDetails {
    /// New access level.
    pub new_access_level: super::sharing::AccessLevel,
    /// Previous access level. Might be missing due to historical data gap.
    pub previous_access_level: Option<super::sharing::AccessLevel>,
}

impl SharedContentChangeMemberRoleDetails {
    pub fn new(new_access_level: super::sharing::AccessLevel) -> Self {
        SharedContentChangeMemberRoleDetails {
            new_access_level,
            previous_access_level: None,
        }
    }

    pub fn with_previous_access_level(
        mut self,
        value: Option<super::sharing::AccessLevel>,
    ) -> Self {
        self.previous_access_level = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["new_access_level",
                                                                    "previous_access_level"];
impl SharedContentChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeMemberRoleDetails, V::Error> {
        use serde::de;
        let mut field_new_access_level = None;
        let mut field_previous_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_access_level" => {
                    if field_new_access_level.is_some() {
                        return Err(de::Error::duplicate_field("new_access_level"));
                    }
                    field_new_access_level = Some(map.next_value()?);
                }
                "previous_access_level" => {
                    if field_previous_access_level.is_some() {
                        return Err(de::Error::duplicate_field("previous_access_level"));
                    }
                    field_previous_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeMemberRoleDetails {
            new_access_level: field_new_access_level.ok_or_else(|| de::Error::missing_field("new_access_level"))?,
            previous_access_level: field_previous_access_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_access_level", &self.new_access_level)?;
        s.serialize_field("previous_access_level", &self.previous_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeMemberRoleDetails", SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeMemberRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeMemberRoleType {
    pub description: String,
}

impl SharedContentChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        SharedContentChangeMemberRoleType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeMemberRoleType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_MEMBER_ROLE_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeMemberRoleType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeMemberRoleType", SHARED_CONTENT_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can see who viewed the shared file or folder.
#[derive(Debug)]
pub struct SharedContentChangeViewerInfoPolicyDetails {
    /// New viewer info policy.
    pub new_value: super::sharing::ViewerInfoPolicy,
    /// Previous view info policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::ViewerInfoPolicy>,
}

impl SharedContentChangeViewerInfoPolicyDetails {
    pub fn new(new_value: super::sharing::ViewerInfoPolicy) -> Self {
        SharedContentChangeViewerInfoPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::ViewerInfoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                           "previous_value"];
impl SharedContentChangeViewerInfoPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeViewerInfoPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentChangeViewerInfoPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeViewerInfoPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeViewerInfoPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeViewerInfoPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeViewerInfoPolicyDetails", SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeViewerInfoPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeViewerInfoPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeViewerInfoPolicyType {
    pub description: String,
}

impl SharedContentChangeViewerInfoPolicyType {
    pub fn new(description: String) -> Self {
        SharedContentChangeViewerInfoPolicyType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeViewerInfoPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeViewerInfoPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentChangeViewerInfoPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeViewerInfoPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeViewerInfoPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeViewerInfoPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeViewerInfoPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeViewerInfoPolicyType", SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeViewerInfoPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeViewerInfoPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Acquired membership on a shared file or folder by claiming an invitation.
#[derive(Debug)]
pub struct SharedContentClaimInvitationDetails {
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl Default for SharedContentClaimInvitationDetails {
    fn default() -> Self {
        SharedContentClaimInvitationDetails {
            shared_content_link: None,
        }
    }
}

const SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS: &[&str] = &["shared_content_link"];
impl SharedContentClaimInvitationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentClaimInvitationDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentClaimInvitationDetails {
            shared_content_link: field_shared_content_link,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentClaimInvitationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentClaimInvitationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentClaimInvitationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentClaimInvitationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentClaimInvitationDetails", SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentClaimInvitationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentClaimInvitationDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentClaimInvitationType {
    pub description: String,
}

impl SharedContentClaimInvitationType {
    pub fn new(description: String) -> Self {
        SharedContentClaimInvitationType {
            description,
        }
    }

}

const SHARED_CONTENT_CLAIM_INVITATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentClaimInvitationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentClaimInvitationType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_CLAIM_INVITATION_TYPE_FIELDS))
            }
        }
        Ok(SharedContentClaimInvitationType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentClaimInvitationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentClaimInvitationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentClaimInvitationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentClaimInvitationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentClaimInvitationType", SHARED_CONTENT_CLAIM_INVITATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentClaimInvitationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentClaimInvitationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Copied the shared file or folder to own Dropbox.
#[derive(Debug)]
pub struct SharedContentCopyDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The path where the member saved the content.
    pub destination_path: FilePath,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentCopyDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
        destination_path: FilePath,
    ) -> Self {
        SharedContentCopyDetails {
            shared_content_link,
            shared_content_access_level,
            destination_path,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_COPY_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                      "shared_content_access_level",
                                                      "destination_path",
                                                      "shared_content_owner"];
impl SharedContentCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentCopyDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_destination_path = None;
        let mut field_shared_content_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "destination_path" => {
                    if field_destination_path.is_some() {
                        return Err(de::Error::duplicate_field("destination_path"));
                    }
                    field_destination_path = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_COPY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentCopyDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| de::Error::missing_field("shared_content_access_level"))?,
            destination_path: field_destination_path.ok_or_else(|| de::Error::missing_field("destination_path"))?,
            shared_content_owner: field_shared_content_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("destination_path", &self.destination_path)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentCopyDetails", SHARED_CONTENT_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentCopyDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentCopyType {
    pub description: String,
}

impl SharedContentCopyType {
    pub fn new(description: String) -> Self {
        SharedContentCopyType {
            description,
        }
    }

}

const SHARED_CONTENT_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentCopyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_COPY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentCopyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentCopyType", SHARED_CONTENT_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded the shared file or folder.
#[derive(Debug)]
pub struct SharedContentDownloadDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentDownloadDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
    ) -> Self {
        SharedContentDownloadDetails {
            shared_content_link,
            shared_content_access_level,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                          "shared_content_access_level",
                                                          "shared_content_owner"];
impl SharedContentDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentDownloadDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentDownloadDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| de::Error::missing_field("shared_content_access_level"))?,
            shared_content_owner: field_shared_content_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentDownloadDetails", SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentDownloadDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentDownloadType {
    pub description: String,
}

impl SharedContentDownloadType {
    pub fn new(description: String) -> Self {
        SharedContentDownloadType {
            description,
        }
    }

}

const SHARED_CONTENT_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentDownloadType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_DOWNLOAD_TYPE_FIELDS))
            }
        }
        Ok(SharedContentDownloadType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentDownloadType", SHARED_CONTENT_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Left the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRelinquishMembershipDetails {
}

impl Default for SharedContentRelinquishMembershipDetails {
    fn default() -> Self {
        SharedContentRelinquishMembershipDetails {
        }
    }
}

const SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentRelinquishMembershipDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRelinquishMembershipDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS));
        }
        Ok(SharedContentRelinquishMembershipDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRelinquishMembershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRelinquishMembershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRelinquishMembershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRelinquishMembershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRelinquishMembershipDetails", SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRelinquishMembershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentRelinquishMembershipDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRelinquishMembershipType {
    pub description: String,
}

impl SharedContentRelinquishMembershipType {
    pub fn new(description: String) -> Self {
        SharedContentRelinquishMembershipType {
            description,
        }
    }

}

const SHARED_CONTENT_RELINQUISH_MEMBERSHIP_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRelinquishMembershipType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRelinquishMembershipType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_RELINQUISH_MEMBERSHIP_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRelinquishMembershipType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRelinquishMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRelinquishMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRelinquishMembershipType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRelinquishMembershipType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRelinquishMembershipType", SHARED_CONTENT_RELINQUISH_MEMBERSHIP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRelinquishMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRelinquishMembershipType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed an invitee from the membership of a shared file or folder before it was claimed.
#[derive(Debug)]
pub struct SharedContentRemoveInviteesDetails {
    /// A list of invitees.
    pub invitees: Vec<EmailAddress>,
}

impl SharedContentRemoveInviteesDetails {
    pub fn new(invitees: Vec<EmailAddress>) -> Self {
        SharedContentRemoveInviteesDetails {
            invitees,
        }
    }

}

const SHARED_CONTENT_REMOVE_INVITEES_DETAILS_FIELDS: &[&str] = &["invitees"];
impl SharedContentRemoveInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveInviteesDetails, V::Error> {
        use serde::de;
        let mut field_invitees = None;
        while let Some(key) = map.next_key()? {
            match key {
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_INVITEES_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveInviteesDetails {
            invitees: field_invitees.ok_or_else(|| de::Error::missing_field("invitees"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("invitees", &self.invitees)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveInviteesDetails", SHARED_CONTENT_REMOVE_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveInviteesDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveInviteesType {
    pub description: String,
}

impl SharedContentRemoveInviteesType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveInviteesType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_INVITEES_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveInviteesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveInviteesType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_INVITEES_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRemoveInviteesType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveInviteesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveInviteesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveInviteesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveInviteesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveInviteesType", SHARED_CONTENT_REMOVE_INVITEES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveInviteesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveInviteesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the expiry of the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkExpiryDetails {
    /// Previous shared content link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentRemoveLinkExpiryDetails {
    fn default() -> Self {
        SharedContentRemoveLinkExpiryDetails {
            previous_value: None,
        }
    }
}

const SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SharedContentRemoveLinkExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkExpiryDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveLinkExpiryDetails {
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkExpiryDetails", SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveLinkExpiryType {
    pub description: String,
}

impl SharedContentRemoveLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRemoveLinkExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkExpiryType", SHARED_CONTENT_REMOVE_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the password on the link for the shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkPasswordDetails {
}

impl Default for SharedContentRemoveLinkPasswordDetails {
    fn default() -> Self {
        SharedContentRemoveLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentRemoveLinkPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkPasswordDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS));
        }
        Ok(SharedContentRemoveLinkPasswordDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkPasswordDetails", SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentRemoveLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveLinkPasswordType {
    pub description: String,
}

impl SharedContentRemoveLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkPasswordType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_LINK_PASSWORD_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRemoveLinkPasswordType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkPasswordType", SHARED_CONTENT_REMOVE_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a user or a group from the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRemoveMemberDetails {
    /// Shared content access level.
    pub shared_content_access_level: Option<super::sharing::AccessLevel>,
}

impl Default for SharedContentRemoveMemberDetails {
    fn default() -> Self {
        SharedContentRemoveMemberDetails {
            shared_content_access_level: None,
        }
    }
}

const SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &["shared_content_access_level"];
impl SharedContentRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveMemberDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRemoveMemberDetails {
            shared_content_access_level: field_shared_content_access_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveMemberDetails", SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveMemberType {
    pub description: String,
}

impl SharedContentRemoveMemberType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveMemberType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveMemberType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REMOVE_MEMBER_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRemoveMemberType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveMemberType", SHARED_CONTENT_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to be on the membership of a shared file or folder.
#[derive(Debug)]
pub struct SharedContentRequestAccessDetails {
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl Default for SharedContentRequestAccessDetails {
    fn default() -> Self {
        SharedContentRequestAccessDetails {
            shared_content_link: None,
        }
    }
}

const SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS: &[&str] = &["shared_content_link"];
impl SharedContentRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRequestAccessDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentRequestAccessDetails {
            shared_content_link: field_shared_content_link,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRequestAccessDetails", SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRequestAccessType {
    pub description: String,
}

impl SharedContentRequestAccessType {
    pub fn new(description: String) -> Self {
        SharedContentRequestAccessType {
            description,
        }
    }

}

const SHARED_CONTENT_REQUEST_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRequestAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRequestAccessType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_REQUEST_ACCESS_TYPE_FIELDS))
            }
        }
        Ok(SharedContentRequestAccessType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRequestAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRequestAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentRequestAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRequestAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRequestAccessType", SHARED_CONTENT_REQUEST_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRequestAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRequestAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared a shared file or folder by clearing its membership and turning off its link.
#[derive(Debug)]
pub struct SharedContentUnshareDetails {
}

impl Default for SharedContentUnshareDetails {
    fn default() -> Self {
        SharedContentUnshareDetails {
        }
    }
}

const SHARED_CONTENT_UNSHARE_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentUnshareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentUnshareDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_CONTENT_UNSHARE_DETAILS_FIELDS));
        }
        Ok(SharedContentUnshareDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentUnshareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentUnshareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentUnshareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentUnshareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentUnshareDetails", SHARED_CONTENT_UNSHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentUnshareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentUnshareDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentUnshareType {
    pub description: String,
}

impl SharedContentUnshareType {
    pub fn new(description: String) -> Self {
        SharedContentUnshareType {
            description,
        }
    }

}

const SHARED_CONTENT_UNSHARE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentUnshareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentUnshareType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_UNSHARE_TYPE_FIELDS))
            }
        }
        Ok(SharedContentUnshareType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentUnshareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentUnshareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentUnshareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentUnshareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentUnshareType", SHARED_CONTENT_UNSHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentUnshareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentUnshareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Previewed the shared file or folder.
#[derive(Debug)]
pub struct SharedContentViewDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentViewDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
    ) -> Self {
        SharedContentViewDetails {
            shared_content_link,
            shared_content_access_level,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_VIEW_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                      "shared_content_access_level",
                                                      "shared_content_owner"];
impl SharedContentViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentViewDetails, V::Error> {
        use serde::de;
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_VIEW_DETAILS_FIELDS))
            }
        }
        Ok(SharedContentViewDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| de::Error::missing_field("shared_content_access_level"))?,
            shared_content_owner: field_shared_content_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentViewDetails", SHARED_CONTENT_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentViewDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentViewType {
    pub description: String,
}

impl SharedContentViewType {
    pub fn new(description: String) -> Self {
        SharedContentViewType {
            description,
        }
    }

}

const SHARED_CONTENT_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentViewType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_VIEW_TYPE_FIELDS))
            }
        }
        Ok(SharedContentViewType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentViewType", SHARED_CONTENT_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can access the shared folder via a link.
#[derive(Debug)]
pub struct SharedFolderChangeLinkPolicyDetails {
    /// New shared folder link policy.
    pub new_value: super::sharing::SharedLinkPolicy,
    /// Previous shared folder link policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::SharedLinkPolicy>,
}

impl SharedFolderChangeLinkPolicyDetails {
    pub fn new(new_value: super::sharing::SharedLinkPolicy) -> Self {
        SharedFolderChangeLinkPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::SharedLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl SharedFolderChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeLinkPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeLinkPolicyDetails", SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeLinkPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeLinkPolicyType {
    pub description: String,
}

impl SharedFolderChangeLinkPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeLinkPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeLinkPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_LINK_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderChangeLinkPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeLinkPolicyType", SHARED_FOLDER_CHANGE_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Specify if the shared folder inherits its members from the parent folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersInheritancePolicyDetails {
    /// New member inheritance policy.
    pub new_value: SharedFolderMembersInheritancePolicy,
    /// Previous member inheritance policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedFolderMembersInheritancePolicy>,
}

impl SharedFolderChangeMembersInheritancePolicyDetails {
    pub fn new(new_value: SharedFolderMembersInheritancePolicy) -> Self {
        SharedFolderChangeMembersInheritancePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<SharedFolderMembersInheritancePolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                                  "previous_value"];
impl SharedFolderChangeMembersInheritancePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersInheritancePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersInheritancePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersInheritancePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersInheritancePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersInheritancePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersInheritancePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersInheritancePolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersInheritancePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersInheritancePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersInheritancePolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersInheritancePolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersInheritancePolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersInheritancePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersInheritancePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersInheritancePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersInheritancePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersInheritancePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersInheritancePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersInheritancePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersInheritancePolicyType", SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersInheritancePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersInheritancePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can add or remove members of a shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersManagementPolicyDetails {
    /// New members management policy.
    pub new_value: super::sharing::AclUpdatePolicy,
    /// Previous members management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::AclUpdatePolicy>,
}

impl SharedFolderChangeMembersManagementPolicyDetails {
    pub fn new(new_value: super::sharing::AclUpdatePolicy) -> Self {
        SharedFolderChangeMembersManagementPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::AclUpdatePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                                 "previous_value"];
impl SharedFolderChangeMembersManagementPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersManagementPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersManagementPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersManagementPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersManagementPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersManagementPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersManagementPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersManagementPolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersManagementPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersManagementPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersManagementPolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersManagementPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersManagementPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersManagementPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersManagementPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersManagementPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersManagementPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersManagementPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersManagementPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersManagementPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersManagementPolicyType", SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersManagementPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersManagementPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can become a member of the shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersPolicyDetails {
    /// New external invite policy.
    pub new_value: super::sharing::MemberPolicy,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::MemberPolicy>,
}

impl SharedFolderChangeMembersPolicyDetails {
    pub fn new(new_value: super::sharing::MemberPolicy) -> Self {
        SharedFolderChangeMembersPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::MemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl SharedFolderChangeMembersPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersPolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersPolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderChangeMembersPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CHANGE_MEMBERS_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderChangeMembersPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersPolicyType", SHARED_FOLDER_CHANGE_MEMBERS_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a shared folder.
#[derive(Debug)]
pub struct SharedFolderCreateDetails {
    /// Target namespace ID. Might be missing due to historical data gap.
    pub target_ns_id: Option<NamespaceId>,
}

impl Default for SharedFolderCreateDetails {
    fn default() -> Self {
        SharedFolderCreateDetails {
            target_ns_id: None,
        }
    }
}

const SHARED_FOLDER_CREATE_DETAILS_FIELDS: &[&str] = &["target_ns_id"];
impl SharedFolderCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderCreateDetails, V::Error> {
        use serde::de;
        let mut field_target_ns_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_ns_id" => {
                    if field_target_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("target_ns_id"));
                    }
                    field_target_ns_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderCreateDetails {
            target_ns_id: field_target_ns_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_ns_id", &self.target_ns_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderCreateDetails", SHARED_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderCreateType {
    pub description: String,
}

impl SharedFolderCreateType {
    pub fn new(description: String) -> Self {
        SharedFolderCreateType {
            description,
        }
    }

}

const SHARED_FOLDER_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_CREATE_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderCreateType", SHARED_FOLDER_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Declined a team member's invitation to a shared folder.
#[derive(Debug)]
pub struct SharedFolderDeclineInvitationDetails {
}

impl Default for SharedFolderDeclineInvitationDetails {
    fn default() -> Self {
        SharedFolderDeclineInvitationDetails {
        }
    }
}

const SHARED_FOLDER_DECLINE_INVITATION_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderDeclineInvitationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderDeclineInvitationDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_FOLDER_DECLINE_INVITATION_DETAILS_FIELDS));
        }
        Ok(SharedFolderDeclineInvitationDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderDeclineInvitationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderDeclineInvitationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderDeclineInvitationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderDeclineInvitationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderDeclineInvitationDetails", SHARED_FOLDER_DECLINE_INVITATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderDeclineInvitationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderDeclineInvitationDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderDeclineInvitationType {
    pub description: String,
}

impl SharedFolderDeclineInvitationType {
    pub fn new(description: String) -> Self {
        SharedFolderDeclineInvitationType {
            description,
        }
    }

}

const SHARED_FOLDER_DECLINE_INVITATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderDeclineInvitationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderDeclineInvitationType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_DECLINE_INVITATION_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderDeclineInvitationType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderDeclineInvitationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderDeclineInvitationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderDeclineInvitationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderDeclineInvitationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderDeclineInvitationType", SHARED_FOLDER_DECLINE_INVITATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderDeclineInvitationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderDeclineInvitationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Specifies if a shared folder inherits its members from the parent folder.
#[derive(Debug)]
pub enum SharedFolderMembersInheritancePolicy {
    InheritMembers,
    DontInheritMembers,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMembersInheritancePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderMembersInheritancePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMembersInheritancePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "inherit_members" => Ok(SharedFolderMembersInheritancePolicy::InheritMembers),
                    "dont_inherit_members" => Ok(SharedFolderMembersInheritancePolicy::DontInheritMembers),
                    _ => Ok(SharedFolderMembersInheritancePolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["inherit_members",
                                    "dont_inherit_members",
                                    "other"];
        deserializer.deserialize_struct("SharedFolderMembersInheritancePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMembersInheritancePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderMembersInheritancePolicy::InheritMembers => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembersInheritancePolicy", 1)?;
                s.serialize_field(".tag", "inherit_members")?;
                s.end()
            }
            SharedFolderMembersInheritancePolicy::DontInheritMembers => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembersInheritancePolicy", 1)?;
                s.serialize_field(".tag", "dont_inherit_members")?;
                s.end()
            }
            SharedFolderMembersInheritancePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added a shared folder to own Dropbox.
#[derive(Debug)]
pub struct SharedFolderMountDetails {
}

impl Default for SharedFolderMountDetails {
    fn default() -> Self {
        SharedFolderMountDetails {
        }
    }
}

const SHARED_FOLDER_MOUNT_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderMountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderMountDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_FOLDER_MOUNT_DETAILS_FIELDS));
        }
        Ok(SharedFolderMountDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMountDetails", SHARED_FOLDER_MOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderMountDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderMountType {
    pub description: String,
}

impl SharedFolderMountType {
    pub fn new(description: String) -> Self {
        SharedFolderMountType {
            description,
        }
    }

}

const SHARED_FOLDER_MOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderMountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderMountType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_MOUNT_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderMountType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMountType", SHARED_FOLDER_MOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the parent of a shared folder.
#[derive(Debug)]
pub struct SharedFolderNestDetails {
    /// Previous parent namespace ID. Might be missing due to historical data gap.
    pub previous_parent_ns_id: Option<NamespaceId>,
    /// New parent namespace ID. Might be missing due to historical data gap.
    pub new_parent_ns_id: Option<NamespaceId>,
}

impl Default for SharedFolderNestDetails {
    fn default() -> Self {
        SharedFolderNestDetails {
            previous_parent_ns_id: None,
            new_parent_ns_id: None,
        }
    }
}

const SHARED_FOLDER_NEST_DETAILS_FIELDS: &[&str] = &["previous_parent_ns_id",
                                                     "new_parent_ns_id"];
impl SharedFolderNestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderNestDetails, V::Error> {
        use serde::de;
        let mut field_previous_parent_ns_id = None;
        let mut field_new_parent_ns_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_parent_ns_id" => {
                    if field_previous_parent_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("previous_parent_ns_id"));
                    }
                    field_previous_parent_ns_id = Some(map.next_value()?);
                }
                "new_parent_ns_id" => {
                    if field_new_parent_ns_id.is_some() {
                        return Err(de::Error::duplicate_field("new_parent_ns_id"));
                    }
                    field_new_parent_ns_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_NEST_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderNestDetails {
            previous_parent_ns_id: field_previous_parent_ns_id,
            new_parent_ns_id: field_new_parent_ns_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_parent_ns_id", &self.previous_parent_ns_id)?;
        s.serialize_field("new_parent_ns_id", &self.new_parent_ns_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderNestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderNestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderNestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderNestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderNestDetails", SHARED_FOLDER_NEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderNestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderNestDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderNestType {
    pub description: String,
}

impl SharedFolderNestType {
    pub fn new(description: String) -> Self {
        SharedFolderNestType {
            description,
        }
    }

}

const SHARED_FOLDER_NEST_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderNestType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderNestType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_NEST_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderNestType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderNestType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderNestType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderNestType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderNestType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderNestType", SHARED_FOLDER_NEST_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderNestType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderNestType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transferred the ownership of a shared folder to another member.
#[derive(Debug)]
pub struct SharedFolderTransferOwnershipDetails {
    /// The email address of the new shared folder owner.
    pub new_owner_email: EmailAddress,
    /// The email address of the previous shared folder owner.
    pub previous_owner_email: Option<EmailAddress>,
}

impl SharedFolderTransferOwnershipDetails {
    pub fn new(new_owner_email: EmailAddress) -> Self {
        SharedFolderTransferOwnershipDetails {
            new_owner_email,
            previous_owner_email: None,
        }
    }

    pub fn with_previous_owner_email(mut self, value: Option<EmailAddress>) -> Self {
        self.previous_owner_email = value;
        self
    }

}

const SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS: &[&str] = &["new_owner_email",
                                                                   "previous_owner_email"];
impl SharedFolderTransferOwnershipDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderTransferOwnershipDetails, V::Error> {
        use serde::de;
        let mut field_new_owner_email = None;
        let mut field_previous_owner_email = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_owner_email" => {
                    if field_new_owner_email.is_some() {
                        return Err(de::Error::duplicate_field("new_owner_email"));
                    }
                    field_new_owner_email = Some(map.next_value()?);
                }
                "previous_owner_email" => {
                    if field_previous_owner_email.is_some() {
                        return Err(de::Error::duplicate_field("previous_owner_email"));
                    }
                    field_previous_owner_email = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS))
            }
        }
        Ok(SharedFolderTransferOwnershipDetails {
            new_owner_email: field_new_owner_email.ok_or_else(|| de::Error::missing_field("new_owner_email"))?,
            previous_owner_email: field_previous_owner_email,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_owner_email", &self.new_owner_email)?;
        s.serialize_field("previous_owner_email", &self.previous_owner_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderTransferOwnershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderTransferOwnershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderTransferOwnershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderTransferOwnershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderTransferOwnershipDetails", SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderTransferOwnershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderTransferOwnershipDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderTransferOwnershipType {
    pub description: String,
}

impl SharedFolderTransferOwnershipType {
    pub fn new(description: String) -> Self {
        SharedFolderTransferOwnershipType {
            description,
        }
    }

}

const SHARED_FOLDER_TRANSFER_OWNERSHIP_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderTransferOwnershipType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderTransferOwnershipType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_TRANSFER_OWNERSHIP_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderTransferOwnershipType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderTransferOwnershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderTransferOwnershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderTransferOwnershipType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderTransferOwnershipType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderTransferOwnershipType", SHARED_FOLDER_TRANSFER_OWNERSHIP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderTransferOwnershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderTransferOwnershipType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted a shared folder from Dropbox.
#[derive(Debug)]
pub struct SharedFolderUnmountDetails {
}

impl Default for SharedFolderUnmountDetails {
    fn default() -> Self {
        SharedFolderUnmountDetails {
        }
    }
}

const SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderUnmountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderUnmountDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS));
        }
        Ok(SharedFolderUnmountDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderUnmountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderUnmountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderUnmountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderUnmountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderUnmountDetails", SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderUnmountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderUnmountDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderUnmountType {
    pub description: String,
}

impl SharedFolderUnmountType {
    pub fn new(description: String) -> Self {
        SharedFolderUnmountType {
            description,
        }
    }

}

const SHARED_FOLDER_UNMOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderUnmountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderUnmountType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_UNMOUNT_TYPE_FIELDS))
            }
        }
        Ok(SharedFolderUnmountType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderUnmountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderUnmountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderUnmountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderUnmountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderUnmountType", SHARED_FOLDER_UNMOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderUnmountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderUnmountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared link access level.
#[derive(Debug)]
pub enum SharedLinkAccessLevel {
    None,
    Reader,
    Writer,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAccessLevel {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkAccessLevel;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAccessLevel structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "none" => Ok(SharedLinkAccessLevel::None),
                    "reader" => Ok(SharedLinkAccessLevel::Reader),
                    "writer" => Ok(SharedLinkAccessLevel::Writer),
                    _ => Ok(SharedLinkAccessLevel::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["none",
                                    "reader",
                                    "writer",
                                    "other"];
        deserializer.deserialize_struct("SharedLinkAccessLevel", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAccessLevel {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkAccessLevel::None => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "none")?;
                s.end()
            }
            SharedLinkAccessLevel::Reader => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "reader")?;
                s.end()
            }
            SharedLinkAccessLevel::Writer => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "writer")?;
                s.end()
            }
            SharedLinkAccessLevel::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added a shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkAddExpiryDetails {
    /// New shared link expiration date.
    pub new_value: super::common::DropboxTimestamp,
}

impl SharedLinkAddExpiryDetails {
    pub fn new(new_value: super::common::DropboxTimestamp) -> Self {
        SharedLinkAddExpiryDetails {
            new_value,
        }
    }

}

const SHARED_LINK_ADD_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SharedLinkAddExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkAddExpiryDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_ADD_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkAddExpiryDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAddExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkAddExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAddExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkAddExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkAddExpiryDetails", SHARED_LINK_ADD_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAddExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkAddExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkAddExpiryType {
    pub description: String,
}

impl SharedLinkAddExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkAddExpiryType {
            description,
        }
    }

}

const SHARED_LINK_ADD_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkAddExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkAddExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_ADD_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkAddExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAddExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkAddExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAddExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkAddExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkAddExpiryType", SHARED_LINK_ADD_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAddExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkAddExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkChangeExpiryDetails {
    /// New shared link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
    /// Previous shared link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedLinkChangeExpiryDetails {
    fn default() -> Self {
        SharedLinkChangeExpiryDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SHARED_LINK_CHANGE_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl SharedLinkChangeExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkChangeExpiryDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CHANGE_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkChangeExpiryDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeExpiryDetails", SHARED_LINK_CHANGE_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeExpiryDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkChangeExpiryType {
    pub description: String,
}

impl SharedLinkChangeExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkChangeExpiryType {
            description,
        }
    }

}

const SHARED_LINK_CHANGE_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkChangeExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkChangeExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CHANGE_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkChangeExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeExpiryType", SHARED_LINK_CHANGE_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the visibility of a shared link.
#[derive(Debug)]
pub struct SharedLinkChangeVisibilityDetails {
    /// New shared link visibility.
    pub new_value: SharedLinkVisibility,
    /// Previous shared link visibility. Might be missing due to historical data gap.
    pub previous_value: Option<SharedLinkVisibility>,
}

impl SharedLinkChangeVisibilityDetails {
    pub fn new(new_value: SharedLinkVisibility) -> Self {
        SharedLinkChangeVisibilityDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharedLinkVisibility>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_LINK_CHANGE_VISIBILITY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl SharedLinkChangeVisibilityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkChangeVisibilityDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CHANGE_VISIBILITY_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkChangeVisibilityDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeVisibilityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeVisibilityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeVisibilityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeVisibilityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeVisibilityDetails", SHARED_LINK_CHANGE_VISIBILITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeVisibilityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeVisibilityDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkChangeVisibilityType {
    pub description: String,
}

impl SharedLinkChangeVisibilityType {
    pub fn new(description: String) -> Self {
        SharedLinkChangeVisibilityType {
            description,
        }
    }

}

const SHARED_LINK_CHANGE_VISIBILITY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkChangeVisibilityType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkChangeVisibilityType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CHANGE_VISIBILITY_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkChangeVisibilityType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeVisibilityType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeVisibilityType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeVisibilityType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeVisibilityType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeVisibilityType", SHARED_LINK_CHANGE_VISIBILITY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeVisibilityType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeVisibilityType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a file/folder to their Dropbox from a shared link.
#[derive(Debug)]
pub struct SharedLinkCopyDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkCopyDetails {
    fn default() -> Self {
        SharedLinkCopyDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_COPY_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCopyDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_COPY_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkCopyDetails {
            shared_link_owner: field_shared_link_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCopyDetails", SHARED_LINK_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCopyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkCopyType {
    pub description: String,
}

impl SharedLinkCopyType {
    pub fn new(description: String) -> Self {
        SharedLinkCopyType {
            description,
        }
    }

}

const SHARED_LINK_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCopyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_COPY_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkCopyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCopyType", SHARED_LINK_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a new shared link.
#[derive(Debug)]
pub struct SharedLinkCreateDetails {
    /// Defines who can access the shared link. Might be missing due to historical data gap.
    pub shared_link_access_level: Option<SharedLinkAccessLevel>,
}

impl Default for SharedLinkCreateDetails {
    fn default() -> Self {
        SharedLinkCreateDetails {
            shared_link_access_level: None,
        }
    }
}

const SHARED_LINK_CREATE_DETAILS_FIELDS: &[&str] = &["shared_link_access_level"];
impl SharedLinkCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCreateDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_access_level" => {
                    if field_shared_link_access_level.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_access_level"));
                    }
                    field_shared_link_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CREATE_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkCreateDetails {
            shared_link_access_level: field_shared_link_access_level,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_access_level", &self.shared_link_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCreateDetails", SHARED_LINK_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkCreateType {
    pub description: String,
}

impl SharedLinkCreateType {
    pub fn new(description: String) -> Self {
        SharedLinkCreateType {
            description,
        }
    }

}

const SHARED_LINK_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_CREATE_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCreateType", SHARED_LINK_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a shared link.
#[derive(Debug)]
pub struct SharedLinkDisableDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkDisableDetails {
    fn default() -> Self {
        SharedLinkDisableDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_DISABLE_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkDisableDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDisableDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_DISABLE_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkDisableDetails {
            shared_link_owner: field_shared_link_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDisableDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDisableDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDisableDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDisableDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDisableDetails", SHARED_LINK_DISABLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDisableDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDisableDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkDisableType {
    pub description: String,
}

impl SharedLinkDisableType {
    pub fn new(description: String) -> Self {
        SharedLinkDisableType {
            description,
        }
    }

}

const SHARED_LINK_DISABLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkDisableType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDisableType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_DISABLE_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkDisableType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDisableType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDisableType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDisableType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDisableType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDisableType", SHARED_LINK_DISABLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDisableType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDisableType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded a file/folder from a shared link.
#[derive(Debug)]
pub struct SharedLinkDownloadDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkDownloadDetails {
    fn default() -> Self {
        SharedLinkDownloadDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDownloadDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_DOWNLOAD_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkDownloadDetails {
            shared_link_owner: field_shared_link_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDownloadDetails", SHARED_LINK_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDownloadDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkDownloadType {
    pub description: String,
}

impl SharedLinkDownloadType {
    pub fn new(description: String) -> Self {
        SharedLinkDownloadType {
            description,
        }
    }

}

const SHARED_LINK_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDownloadType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_DOWNLOAD_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkDownloadType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDownloadType", SHARED_LINK_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkRemoveExpiryDetails {
    /// Previous shared link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedLinkRemoveExpiryDetails {
    fn default() -> Self {
        SharedLinkRemoveExpiryDetails {
            previous_value: None,
        }
    }
}

const SHARED_LINK_REMOVE_EXPIRY_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SharedLinkRemoveExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkRemoveExpiryDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_REMOVE_EXPIRY_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkRemoveExpiryDetails {
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkRemoveExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkRemoveExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkRemoveExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkRemoveExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkRemoveExpiryDetails", SHARED_LINK_REMOVE_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkRemoveExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkRemoveExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkRemoveExpiryType {
    pub description: String,
}

impl SharedLinkRemoveExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkRemoveExpiryType {
            description,
        }
    }

}

const SHARED_LINK_REMOVE_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkRemoveExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkRemoveExpiryType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_REMOVE_EXPIRY_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkRemoveExpiryType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkRemoveExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkRemoveExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkRemoveExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkRemoveExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkRemoveExpiryType", SHARED_LINK_REMOVE_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkRemoveExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkRemoveExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added new members as the audience of a shared link.
#[derive(Debug)]
pub struct SharedLinkShareDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
    /// Users without a Dropbox account that were added as shared link audience.
    pub external_users: Option<Vec<ExternalUserLogInfo>>,
}

impl Default for SharedLinkShareDetails {
    fn default() -> Self {
        SharedLinkShareDetails {
            shared_link_owner: None,
            external_users: None,
        }
    }
}

const SHARED_LINK_SHARE_DETAILS_FIELDS: &[&str] = &["shared_link_owner",
                                                    "external_users"];
impl SharedLinkShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkShareDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_owner = None;
        let mut field_external_users = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                "external_users" => {
                    if field_external_users.is_some() {
                        return Err(de::Error::duplicate_field("external_users"));
                    }
                    field_external_users = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_SHARE_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkShareDetails {
            shared_link_owner: field_shared_link_owner,
            external_users: field_external_users,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)?;
        s.serialize_field("external_users", &self.external_users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkShareDetails", SHARED_LINK_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkShareDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkShareType {
    pub description: String,
}

impl SharedLinkShareType {
    pub fn new(description: String) -> Self {
        SharedLinkShareType {
            description,
        }
    }

}

const SHARED_LINK_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkShareType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_SHARE_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkShareType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkShareType", SHARED_LINK_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opened a shared link.
#[derive(Debug)]
pub struct SharedLinkViewDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkViewDetails {
    fn default() -> Self {
        SharedLinkViewDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_VIEW_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkViewDetails, V::Error> {
        use serde::de;
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_VIEW_DETAILS_FIELDS))
            }
        }
        Ok(SharedLinkViewDetails {
            shared_link_owner: field_shared_link_owner,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkViewDetails", SHARED_LINK_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkViewType {
    pub description: String,
}

impl SharedLinkViewType {
    pub fn new(description: String) -> Self {
        SharedLinkViewType {
            description,
        }
    }

}

const SHARED_LINK_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkViewType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_VIEW_TYPE_FIELDS))
            }
        }
        Ok(SharedLinkViewType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkViewType", SHARED_LINK_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Defines who has access to a shared link.
#[derive(Debug)]
pub enum SharedLinkVisibility {
    Password,
    Public,
    TeamOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkVisibility {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkVisibility;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkVisibility structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "password" => Ok(SharedLinkVisibility::Password),
                    "public" => Ok(SharedLinkVisibility::Public),
                    "team_only" => Ok(SharedLinkVisibility::TeamOnly),
                    _ => Ok(SharedLinkVisibility::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["password",
                                    "public",
                                    "team_only",
                                    "other"];
        deserializer.deserialize_struct("SharedLinkVisibility", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkVisibility {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkVisibility::Password => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            SharedLinkVisibility::Public => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            SharedLinkVisibility::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharedLinkVisibility::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Shared Paper document was opened.
#[derive(Debug)]
pub struct SharedNoteOpenedDetails {
}

impl Default for SharedNoteOpenedDetails {
    fn default() -> Self {
        SharedNoteOpenedDetails {
        }
    }
}

const SHARED_NOTE_OPENED_DETAILS_FIELDS: &[&str] = &[];
impl SharedNoteOpenedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedNoteOpenedDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHARED_NOTE_OPENED_DETAILS_FIELDS));
        }
        Ok(SharedNoteOpenedDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedNoteOpenedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedNoteOpenedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedNoteOpenedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedNoteOpenedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedNoteOpenedDetails", SHARED_NOTE_OPENED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedNoteOpenedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedNoteOpenedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedNoteOpenedType {
    pub description: String,
}

impl SharedNoteOpenedType {
    pub fn new(description: String) -> Self {
        SharedNoteOpenedType {
            description,
        }
    }

}

const SHARED_NOTE_OPENED_TYPE_FIELDS: &[&str] = &["description"];
impl SharedNoteOpenedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedNoteOpenedType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_NOTE_OPENED_TYPE_FIELDS))
            }
        }
        Ok(SharedNoteOpenedType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedNoteOpenedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedNoteOpenedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedNoteOpenedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedNoteOpenedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedNoteOpenedType", SHARED_NOTE_OPENED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedNoteOpenedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedNoteOpenedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can join shared folders owned externally (i.e. outside the team).
#[derive(Debug)]
pub struct SharingChangeFolderJoinPolicyDetails {
    /// New external join policy.
    pub new_value: SharingFolderJoinPolicy,
    /// Previous external join policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingFolderJoinPolicy>,
}

impl SharingChangeFolderJoinPolicyDetails {
    pub fn new(new_value: SharingFolderJoinPolicy) -> Self {
        SharingChangeFolderJoinPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingFolderJoinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                    "previous_value"];
impl SharingChangeFolderJoinPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeFolderJoinPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeFolderJoinPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeFolderJoinPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeFolderJoinPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeFolderJoinPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeFolderJoinPolicyDetails", SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeFolderJoinPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeFolderJoinPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeFolderJoinPolicyType {
    pub description: String,
}

impl SharingChangeFolderJoinPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeFolderJoinPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_FOLDER_JOIN_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeFolderJoinPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeFolderJoinPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_FOLDER_JOIN_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharingChangeFolderJoinPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeFolderJoinPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeFolderJoinPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeFolderJoinPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeFolderJoinPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeFolderJoinPolicyType", SHARING_CHANGE_FOLDER_JOIN_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeFolderJoinPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeFolderJoinPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share links externally (i.e. outside the team), and if so,
/// whether links should be accessible only by team members or anyone by default.
#[derive(Debug)]
pub struct SharingChangeLinkPolicyDetails {
    /// New external link accessibility policy.
    pub new_value: SharingLinkPolicy,
    /// Previous external link accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingLinkPolicy>,
}

impl SharingChangeLinkPolicyDetails {
    pub fn new(new_value: SharingLinkPolicy) -> Self {
        SharingChangeLinkPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                             "previous_value"];
impl SharingChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeLinkPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeLinkPolicyDetails", SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeLinkPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeLinkPolicyType {
    pub description: String,
}

impl SharingChangeLinkPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeLinkPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeLinkPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_LINK_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharingChangeLinkPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeLinkPolicyType", SHARING_CHANGE_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can share files and folders externally (i.e. outside the team).
#[derive(Debug)]
pub struct SharingChangeMemberPolicyDetails {
    /// New external invite policy.
    pub new_value: SharingMemberPolicy,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingMemberPolicy>,
}

impl SharingChangeMemberPolicyDetails {
    pub fn new(new_value: SharingMemberPolicy) -> Self {
        SharingChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                               "previous_value"];
impl SharingChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeMemberPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SharingChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeMemberPolicyDetails", SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeMemberPolicyType {
    pub description: String,
}

impl SharingChangeMemberPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeMemberPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_MEMBER_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeMemberPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharingChangeMemberPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARING_CHANGE_MEMBER_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SharingChangeMemberPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeMemberPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeMemberPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingChangeMemberPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeMemberPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeMemberPolicyType", SHARING_CHANGE_MEMBER_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeMemberPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeMemberPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can join shared folders owned by non team members.
#[derive(Debug)]
pub enum SharingFolderJoinPolicy {
    FromAnyone,
    FromTeamOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingFolderJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingFolderJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingFolderJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "from_anyone" => Ok(SharingFolderJoinPolicy::FromAnyone),
                    "from_team_only" => Ok(SharingFolderJoinPolicy::FromTeamOnly),
                    _ => Ok(SharingFolderJoinPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["from_anyone",
                                    "from_team_only",
                                    "other"];
        deserializer.deserialize_struct("SharingFolderJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingFolderJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingFolderJoinPolicy::FromAnyone => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "from_anyone")?;
                s.end()
            }
            SharingFolderJoinPolicy::FromTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "from_team_only")?;
                s.end()
            }
            SharingFolderJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling if team members can share links externally
#[derive(Debug)]
pub enum SharingLinkPolicy {
    DefaultPrivate,
    DefaultPublic,
    OnlyPrivate,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingLinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingLinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingLinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "default_private" => Ok(SharingLinkPolicy::DefaultPrivate),
                    "default_public" => Ok(SharingLinkPolicy::DefaultPublic),
                    "only_private" => Ok(SharingLinkPolicy::OnlyPrivate),
                    _ => Ok(SharingLinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["default_private",
                                    "default_public",
                                    "only_private",
                                    "other"];
        deserializer.deserialize_struct("SharingLinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingLinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingLinkPolicy::DefaultPrivate => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_private")?;
                s.end()
            }
            SharingLinkPolicy::DefaultPublic => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_public")?;
                s.end()
            }
            SharingLinkPolicy::OnlyPrivate => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "only_private")?;
                s.end()
            }
            SharingLinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// External sharing policy
#[derive(Debug)]
pub enum SharingMemberPolicy {
    Allow,
    Forbid,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "allow" => Ok(SharingMemberPolicy::Allow),
                    "forbid" => Ok(SharingMemberPolicy::Forbid),
                    _ => Ok(SharingMemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["allow",
                                    "forbid",
                                    "other"];
        deserializer.deserialize_struct("SharingMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingMemberPolicy::Allow => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            SharingMemberPolicy::Forbid => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "forbid")?;
                s.end()
            }
            SharingMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Shared a link with a group.
#[derive(Debug)]
pub struct ShmodelGroupShareDetails {
}

impl Default for ShmodelGroupShareDetails {
    fn default() -> Self {
        ShmodelGroupShareDetails {
        }
    }
}

const SHMODEL_GROUP_SHARE_DETAILS_FIELDS: &[&str] = &[];
impl ShmodelGroupShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ShmodelGroupShareDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SHMODEL_GROUP_SHARE_DETAILS_FIELDS));
        }
        Ok(ShmodelGroupShareDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelGroupShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelGroupShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelGroupShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelGroupShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelGroupShareDetails", SHMODEL_GROUP_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelGroupShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelGroupShareDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ShmodelGroupShareType {
    pub description: String,
}

impl ShmodelGroupShareType {
    pub fn new(description: String) -> Self {
        ShmodelGroupShareType {
            description,
        }
    }

}

const SHMODEL_GROUP_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl ShmodelGroupShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ShmodelGroupShareType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHMODEL_GROUP_SHARE_TYPE_FIELDS))
            }
        }
        Ok(ShmodelGroupShareType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelGroupShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelGroupShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShmodelGroupShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelGroupShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelGroupShareType", SHMODEL_GROUP_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelGroupShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelGroupShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionEndDetails {
}

impl Default for SignInAsSessionEndDetails {
    fn default() -> Self {
        SignInAsSessionEndDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_END_DETAILS_FIELDS: &[&str] = &[];
impl SignInAsSessionEndDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionEndDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_END_DETAILS_FIELDS));
        }
        Ok(SignInAsSessionEndDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionEndDetails", SIGN_IN_AS_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionEndDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SignInAsSessionEndType {
    pub description: String,
}

impl SignInAsSessionEndType {
    pub fn new(description: String) -> Self {
        SignInAsSessionEndType {
            description,
        }
    }

}

const SIGN_IN_AS_SESSION_END_TYPE_FIELDS: &[&str] = &["description"];
impl SignInAsSessionEndType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionEndType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_END_TYPE_FIELDS))
            }
        }
        Ok(SignInAsSessionEndType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionEndType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionEndType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionEndType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionEndType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionEndType", SIGN_IN_AS_SESSION_END_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionEndType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SignInAsSessionEndType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionStartDetails {
}

impl Default for SignInAsSessionStartDetails {
    fn default() -> Self {
        SignInAsSessionStartDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_START_DETAILS_FIELDS: &[&str] = &[];
impl SignInAsSessionStartDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionStartDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_START_DETAILS_FIELDS));
        }
        Ok(SignInAsSessionStartDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionStartDetails", SIGN_IN_AS_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SignInAsSessionStartType {
    pub description: String,
}

impl SignInAsSessionStartType {
    pub fn new(description: String) -> Self {
        SignInAsSessionStartType {
            description,
        }
    }

}

const SIGN_IN_AS_SESSION_START_TYPE_FIELDS: &[&str] = &["description"];
impl SignInAsSessionStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionStartType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SIGN_IN_AS_SESSION_START_TYPE_FIELDS))
            }
        }
        Ok(SignInAsSessionStartType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionStartType", SIGN_IN_AS_SESSION_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SignInAsSessionStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the default Smart Sync policy for team members.
#[derive(Debug)]
pub struct SmartSyncChangePolicyDetails {
    /// New smart sync policy.
    pub new_value: Option<super::team_policies::SmartSyncPolicy>,
    /// Previous smart sync policy.
    pub previous_value: Option<super::team_policies::SmartSyncPolicy>,
}

impl Default for SmartSyncChangePolicyDetails {
    fn default() -> Self {
        SmartSyncChangePolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl SmartSyncChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncChangePolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncChangePolicyDetails", SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncChangePolicyType {
    pub description: String,
}

impl SmartSyncChangePolicyType {
    pub fn new(description: String) -> Self {
        SmartSyncChangePolicyType {
            description,
        }
    }

}

const SMART_SYNC_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SmartSyncChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncChangePolicyType", SMART_SYNC_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Smart Sync non-admin devices report created.
#[derive(Debug)]
pub struct SmartSyncCreateAdminPrivilegeReportDetails {
}

impl Default for SmartSyncCreateAdminPrivilegeReportDetails {
    fn default() -> Self {
        SmartSyncCreateAdminPrivilegeReportDetails {
        }
    }
}

const SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl SmartSyncCreateAdminPrivilegeReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncCreateAdminPrivilegeReportDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS));
        }
        Ok(SmartSyncCreateAdminPrivilegeReportDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncCreateAdminPrivilegeReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncCreateAdminPrivilegeReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncCreateAdminPrivilegeReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncCreateAdminPrivilegeReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncCreateAdminPrivilegeReportType {
    pub description: String,
}

impl SmartSyncCreateAdminPrivilegeReportType {
    pub fn new(description: String) -> Self {
        SmartSyncCreateAdminPrivilegeReportType {
            description,
        }
    }

}

const SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncCreateAdminPrivilegeReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncCreateAdminPrivilegeReportType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_TYPE_FIELDS))
            }
        }
        Ok(SmartSyncCreateAdminPrivilegeReportType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncCreateAdminPrivilegeReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncCreateAdminPrivilegeReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncCreateAdminPrivilegeReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncCreateAdminPrivilegeReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncCreateAdminPrivilegeReportType", SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncCreateAdminPrivilegeReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncCreateAdminPrivilegeReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opted team into Smart Sync.
#[derive(Debug)]
pub struct SmartSyncNotOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncNotOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncNotOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                         "new_value"];
impl SmartSyncNotOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncNotOptOutDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncNotOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncNotOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncNotOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncNotOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncNotOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncNotOptOutDetails", SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncNotOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncNotOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncNotOptOutType {
    pub description: String,
}

impl SmartSyncNotOptOutType {
    pub fn new(description: String) -> Self {
        SmartSyncNotOptOutType {
            description,
        }
    }

}

const SMART_SYNC_NOT_OPT_OUT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncNotOptOutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncNotOptOutType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_NOT_OPT_OUT_TYPE_FIELDS))
            }
        }
        Ok(SmartSyncNotOptOutType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncNotOptOutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncNotOptOutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncNotOptOutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncNotOptOutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncNotOptOutType", SMART_SYNC_NOT_OPT_OUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncNotOptOutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncNotOptOutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opted team out of Smart Sync.
#[derive(Debug)]
pub struct SmartSyncOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_OPT_OUT_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                     "new_value"];
impl SmartSyncOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncOptOutDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_OPT_OUT_DETAILS_FIELDS))
            }
        }
        Ok(SmartSyncOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncOptOutDetails", SMART_SYNC_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SmartSyncOptOutPolicy {
    Default,
    OptedOut,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SmartSyncOptOutPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "default" => Ok(SmartSyncOptOutPolicy::Default),
                    "opted_out" => Ok(SmartSyncOptOutPolicy::OptedOut),
                    _ => Ok(SmartSyncOptOutPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["default",
                                    "opted_out",
                                    "other"];
        deserializer.deserialize_struct("SmartSyncOptOutPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SmartSyncOptOutPolicy::Default => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "default")?;
                s.end()
            }
            SmartSyncOptOutPolicy::OptedOut => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "opted_out")?;
                s.end()
            }
            SmartSyncOptOutPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct SmartSyncOptOutType {
    pub description: String,
}

impl SmartSyncOptOutType {
    pub fn new(description: String) -> Self {
        SmartSyncOptOutType {
            description,
        }
    }

}

const SMART_SYNC_OPT_OUT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncOptOutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncOptOutType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SMART_SYNC_OPT_OUT_TYPE_FIELDS))
            }
        }
        Ok(SmartSyncOptOutType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncOptOutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncOptOutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncOptOutType", SMART_SYNC_OPT_OUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncOptOutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Space limit alert policy
#[derive(Debug)]
pub enum SpaceCapsType {
    Hard,
    Off,
    Soft,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceCapsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceCapsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceCapsType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "hard" => Ok(SpaceCapsType::Hard),
                    "off" => Ok(SpaceCapsType::Off),
                    "soft" => Ok(SpaceCapsType::Soft),
                    _ => Ok(SpaceCapsType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["hard",
                                    "off",
                                    "soft",
                                    "other"];
        deserializer.deserialize_struct("SpaceCapsType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceCapsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceCapsType::Hard => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "hard")?;
                s.end()
            }
            SpaceCapsType::Off => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "off")?;
                s.end()
            }
            SpaceCapsType::Soft => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "soft")?;
                s.end()
            }
            SpaceCapsType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SpaceLimitsStatus {
    WithinQuota,
    NearQuota,
    OverQuota,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceLimitsStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceLimitsStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SpaceLimitsStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "within_quota" => Ok(SpaceLimitsStatus::WithinQuota),
                    "near_quota" => Ok(SpaceLimitsStatus::NearQuota),
                    "over_quota" => Ok(SpaceLimitsStatus::OverQuota),
                    _ => Ok(SpaceLimitsStatus::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["within_quota",
                                    "near_quota",
                                    "over_quota",
                                    "other"];
        deserializer.deserialize_struct("SpaceLimitsStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceLimitsStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceLimitsStatus::WithinQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "within_quota")?;
                s.end()
            }
            SpaceLimitsStatus::NearQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "near_quota")?;
                s.end()
            }
            SpaceLimitsStatus::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            SpaceLimitsStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added the X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoAddCertDetails {
    /// SSO certificate details.
    pub certificate_details: Certificate,
}

impl SsoAddCertDetails {
    pub fn new(certificate_details: Certificate) -> Self {
        SsoAddCertDetails {
            certificate_details,
        }
    }

}

const SSO_ADD_CERT_DETAILS_FIELDS: &[&str] = &["certificate_details"];
impl SsoAddCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddCertDetails, V::Error> {
        use serde::de;
        let mut field_certificate_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "certificate_details" => {
                    if field_certificate_details.is_some() {
                        return Err(de::Error::duplicate_field("certificate_details"));
                    }
                    field_certificate_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_CERT_DETAILS_FIELDS))
            }
        }
        Ok(SsoAddCertDetails {
            certificate_details: field_certificate_details.ok_or_else(|| de::Error::missing_field("certificate_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("certificate_details", &self.certificate_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddCertDetails", SSO_ADD_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddCertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddCertType {
    pub description: String,
}

impl SsoAddCertType {
    pub fn new(description: String) -> Self {
        SsoAddCertType {
            description,
        }
    }

}

const SSO_ADD_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddCertType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_CERT_TYPE_FIELDS))
            }
        }
        Ok(SsoAddCertType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddCertType", SSO_ADD_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoAddLoginUrlDetails {
    /// New single sign-on login URL.
    pub new_value: String,
}

impl SsoAddLoginUrlDetails {
    pub fn new(new_value: String) -> Self {
        SsoAddLoginUrlDetails {
            new_value,
        }
    }

}

const SSO_ADD_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SsoAddLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddLoginUrlDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_LOGIN_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoAddLoginUrlDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLoginUrlDetails", SSO_ADD_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLoginUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddLoginUrlType {
    pub description: String,
}

impl SsoAddLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoAddLoginUrlType {
            description,
        }
    }

}

const SSO_ADD_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddLoginUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_LOGIN_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoAddLoginUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLoginUrlType", SSO_ADD_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoAddLogoutUrlDetails {
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl Default for SsoAddLogoutUrlDetails {
    fn default() -> Self {
        SsoAddLogoutUrlDetails {
            new_value: None,
        }
    }
}

const SSO_ADD_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SsoAddLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddLogoutUrlDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_LOGOUT_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoAddLogoutUrlDetails {
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLogoutUrlDetails", SSO_ADD_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLogoutUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddLogoutUrlType {
    pub description: String,
}

impl SsoAddLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoAddLogoutUrlType {
            description,
        }
    }

}

const SSO_ADD_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddLogoutUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ADD_LOGOUT_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoAddLogoutUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoAddLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLogoutUrlType", SSO_ADD_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoChangeCertDetails {
    /// New SSO certificate details.
    pub new_certificate_details: Certificate,
    /// Previous SSO certificate details. Might be missing due to historical data gap.
    pub previous_certificate_details: Option<Certificate>,
}

impl SsoChangeCertDetails {
    pub fn new(new_certificate_details: Certificate) -> Self {
        SsoChangeCertDetails {
            new_certificate_details,
            previous_certificate_details: None,
        }
    }

    pub fn with_previous_certificate_details(mut self, value: Option<Certificate>) -> Self {
        self.previous_certificate_details = value;
        self
    }

}

const SSO_CHANGE_CERT_DETAILS_FIELDS: &[&str] = &["new_certificate_details",
                                                  "previous_certificate_details"];
impl SsoChangeCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeCertDetails, V::Error> {
        use serde::de;
        let mut field_new_certificate_details = None;
        let mut field_previous_certificate_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_certificate_details" => {
                    if field_new_certificate_details.is_some() {
                        return Err(de::Error::duplicate_field("new_certificate_details"));
                    }
                    field_new_certificate_details = Some(map.next_value()?);
                }
                "previous_certificate_details" => {
                    if field_previous_certificate_details.is_some() {
                        return Err(de::Error::duplicate_field("previous_certificate_details"));
                    }
                    field_previous_certificate_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_CERT_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeCertDetails {
            new_certificate_details: field_new_certificate_details.ok_or_else(|| de::Error::missing_field("new_certificate_details"))?,
            previous_certificate_details: field_previous_certificate_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_certificate_details", &self.new_certificate_details)?;
        s.serialize_field("previous_certificate_details", &self.previous_certificate_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeCertDetails", SSO_CHANGE_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeCertDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeCertType {
    pub description: String,
}

impl SsoChangeCertType {
    pub fn new(description: String) -> Self {
        SsoChangeCertType {
            description,
        }
    }

}

const SSO_CHANGE_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeCertType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_CERT_TYPE_FIELDS))
            }
        }
        Ok(SsoChangeCertType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeCertType", SSO_CHANGE_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLoginUrlDetails {
    /// Previous single sign-on login URL.
    pub previous_value: String,
    /// New single sign-on login URL.
    pub new_value: String,
}

impl SsoChangeLoginUrlDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        SsoChangeLoginUrlDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                       "new_value"];
impl SsoChangeLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeLoginUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeLoginUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLoginUrlDetails", SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLoginUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeLoginUrlType {
    pub description: String,
}

impl SsoChangeLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoChangeLoginUrlType {
            description,
        }
    }

}

const SSO_CHANGE_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeLoginUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGIN_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoChangeLoginUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLoginUrlType", SSO_CHANGE_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLogoutUrlDetails {
    /// Previous single sign-on logout URL. Might be missing due to historical data gap.
    pub previous_value: Option<String>,
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl Default for SsoChangeLogoutUrlDetails {
    fn default() -> Self {
        SsoChangeLogoutUrlDetails {
            previous_value: None,
            new_value: None,
        }
    }
}

const SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                        "new_value"];
impl SsoChangeLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeLogoutUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeLogoutUrlDetails {
            previous_value: field_previous_value,
            new_value: field_new_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLogoutUrlDetails", SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLogoutUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeLogoutUrlType {
    pub description: String,
}

impl SsoChangeLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoChangeLogoutUrlType {
            description,
        }
    }

}

const SSO_CHANGE_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeLogoutUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_LOGOUT_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoChangeLogoutUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLogoutUrlType", SSO_CHANGE_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change the single sign-on policy for the team.
#[derive(Debug)]
pub struct SsoChangePolicyDetails {
    /// New single sign-on policy.
    pub new_value: super::team_policies::SsoPolicy,
    /// Previous single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::SsoPolicy>,
}

impl SsoChangePolicyDetails {
    pub fn new(new_value: super::team_policies::SsoPolicy) -> Self {
        SsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team_policies::SsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SSO_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl SsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangePolicyDetails", SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangePolicyType {
    pub description: String,
}

impl SsoChangePolicyType {
    pub fn new(description: String) -> Self {
        SsoChangePolicyType {
            description,
        }
    }

}

const SSO_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(SsoChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangePolicyType", SSO_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the SAML identity mode for SSO.
#[derive(Debug)]
pub struct SsoChangeSamlIdentityModeDetails {
    /// Previous single sign-on identity mode.
    pub previous_value: i64,
    /// New single sign-on identity mode.
    pub new_value: i64,
}

impl SsoChangeSamlIdentityModeDetails {
    pub fn new(previous_value: i64, new_value: i64) -> Self {
        SsoChangeSamlIdentityModeDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                "new_value"];
impl SsoChangeSamlIdentityModeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeSamlIdentityModeDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS))
            }
        }
        Ok(SsoChangeSamlIdentityModeDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeSamlIdentityModeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeSamlIdentityModeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeSamlIdentityModeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeSamlIdentityModeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeSamlIdentityModeDetails", SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeSamlIdentityModeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeSamlIdentityModeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeSamlIdentityModeType {
    pub description: String,
}

impl SsoChangeSamlIdentityModeType {
    pub fn new(description: String) -> Self {
        SsoChangeSamlIdentityModeType {
            description,
        }
    }

}

const SSO_CHANGE_SAML_IDENTITY_MODE_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeSamlIdentityModeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeSamlIdentityModeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_CHANGE_SAML_IDENTITY_MODE_TYPE_FIELDS))
            }
        }
        Ok(SsoChangeSamlIdentityModeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeSamlIdentityModeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeSamlIdentityModeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoChangeSamlIdentityModeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeSamlIdentityModeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeSamlIdentityModeType", SSO_CHANGE_SAML_IDENTITY_MODE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeSamlIdentityModeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeSamlIdentityModeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in via SSO.
#[derive(Debug)]
pub struct SsoErrorDetails {
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
}

impl SsoErrorDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        SsoErrorDetails {
            error_details,
        }
    }

}

const SSO_ERROR_DETAILS_FIELDS: &[&str] = &["error_details"];
impl SsoErrorDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoErrorDetails, V::Error> {
        use serde::de;
        let mut field_error_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ERROR_DETAILS_FIELDS))
            }
        }
        Ok(SsoErrorDetails {
            error_details: field_error_details.ok_or_else(|| de::Error::missing_field("error_details"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoErrorDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoErrorDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoErrorDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoErrorDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoErrorDetails", SSO_ERROR_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoErrorDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoErrorDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoErrorType {
    pub description: String,
}

impl SsoErrorType {
    pub fn new(description: String) -> Self {
        SsoErrorType {
            description,
        }
    }

}

const SSO_ERROR_TYPE_FIELDS: &[&str] = &["description"];
impl SsoErrorType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoErrorType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_ERROR_TYPE_FIELDS))
            }
        }
        Ok(SsoErrorType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoErrorType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoErrorType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoErrorType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoErrorType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoErrorType", SSO_ERROR_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoErrorType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoErrorType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoRemoveCertDetails {
}

impl Default for SsoRemoveCertDetails {
    fn default() -> Self {
        SsoRemoveCertDetails {
        }
    }
}

const SSO_REMOVE_CERT_DETAILS_FIELDS: &[&str] = &[];
impl SsoRemoveCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveCertDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, SSO_REMOVE_CERT_DETAILS_FIELDS));
        }
        Ok(SsoRemoveCertDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveCertDetails", SSO_REMOVE_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SsoRemoveCertDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveCertType {
    pub description: String,
}

impl SsoRemoveCertType {
    pub fn new(description: String) -> Self {
        SsoRemoveCertType {
            description,
        }
    }

}

const SSO_REMOVE_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveCertType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_REMOVE_CERT_TYPE_FIELDS))
            }
        }
        Ok(SsoRemoveCertType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveCertType", SSO_REMOVE_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoRemoveLoginUrlDetails {
    /// Previous single sign-on login URL.
    pub previous_value: String,
}

impl SsoRemoveLoginUrlDetails {
    pub fn new(previous_value: String) -> Self {
        SsoRemoveLoginUrlDetails {
            previous_value,
        }
    }

}

const SSO_REMOVE_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SsoRemoveLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveLoginUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_REMOVE_LOGIN_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoRemoveLoginUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLoginUrlDetails", SSO_REMOVE_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLoginUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveLoginUrlType {
    pub description: String,
}

impl SsoRemoveLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoRemoveLoginUrlType {
            description,
        }
    }

}

const SSO_REMOVE_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveLoginUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_REMOVE_LOGIN_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoRemoveLoginUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLoginUrlType", SSO_REMOVE_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed single sign-on logout URL.
#[derive(Debug)]
pub struct SsoRemoveLogoutUrlDetails {
    /// Previous single sign-on logout URL.
    pub previous_value: String,
}

impl SsoRemoveLogoutUrlDetails {
    pub fn new(previous_value: String) -> Self {
        SsoRemoveLogoutUrlDetails {
            previous_value,
        }
    }

}

const SSO_REMOVE_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SsoRemoveLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveLogoutUrlDetails, V::Error> {
        use serde::de;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_REMOVE_LOGOUT_URL_DETAILS_FIELDS))
            }
        }
        Ok(SsoRemoveLogoutUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLogoutUrlDetails", SSO_REMOVE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLogoutUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveLogoutUrlType {
    pub description: String,
}

impl SsoRemoveLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoRemoveLogoutUrlType {
            description,
        }
    }

}

const SSO_REMOVE_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveLogoutUrlType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SSO_REMOVE_LOGOUT_URL_TYPE_FIELDS))
            }
        }
        Ok(SsoRemoveLogoutUrlType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLogoutUrlType", SSO_REMOVE_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a team activity report.
#[derive(Debug)]
pub struct TeamActivityCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl TeamActivityCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        TeamActivityCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                              "end_date"];
impl TeamActivityCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamActivityCreateReportDetails, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_end_date = None;
        while let Some(key) = map.next_key()? {
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS))
            }
        }
        Ok(TeamActivityCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| de::Error::missing_field("end_date"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportDetails", TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamActivityCreateReportType {
    pub description: String,
}

impl TeamActivityCreateReportType {
    pub fn new(description: String) -> Self {
        TeamActivityCreateReportType {
            description,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl TeamActivityCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamActivityCreateReportType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_ACTIVITY_CREATE_REPORT_TYPE_FIELDS))
            }
        }
        Ok(TeamActivityCreateReportType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportType", TEAM_ACTIVITY_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// An audit log event.
#[derive(Debug)]
pub struct TeamEvent {
    /// The Dropbox timestamp representing when the action was taken.
    pub timestamp: super::common::DropboxTimestamp,
    /// The category that this type of action belongs to.
    pub event_category: EventCategory,
    /// The particular type of action taken.
    pub event_type: EventType,
    /// The variable event schema applicable to this type of action, instantiated with respect to
    /// this particular action.
    pub details: EventDetails,
    /// The entity who actually performed the action. Might be missing due to historical data gap.
    pub actor: Option<ActorLogInfo>,
    /// The origin from which the actor performed the action including information about host, ip
    /// address, location, session, etc. If the action was performed programmatically via the API
    /// the origin represents the API client.
    pub origin: Option<OriginLogInfo>,
    /// True if the action involved a non team member either as the actor or as one of the affected
    /// users. Might be missing due to historical data gap.
    pub involve_non_team_member: Option<bool>,
    /// The user or team on whose behalf the actor performed the action. Might be missing due to
    /// historical data gap.
    pub context: Option<ContextLogInfo>,
    /// Zero or more users and/or groups that are affected by the action. Note that this list
    /// doesn't include any actors or users in context.
    pub participants: Option<Vec<ParticipantLogInfo>>,
    /// Zero or more content assets involved in the action. Currently these include Dropbox files
    /// and folders but in the future we might add other asset types such as Paper documents,
    /// folders, projects, etc.
    pub assets: Option<Vec<AssetLogInfo>>,
}

impl TeamEvent {
    pub fn new(
        timestamp: super::common::DropboxTimestamp,
        event_category: EventCategory,
        event_type: EventType,
        details: EventDetails,
    ) -> Self {
        TeamEvent {
            timestamp,
            event_category,
            event_type,
            details,
            actor: None,
            origin: None,
            involve_non_team_member: None,
            context: None,
            participants: None,
            assets: None,
        }
    }

    pub fn with_actor(mut self, value: Option<ActorLogInfo>) -> Self {
        self.actor = value;
        self
    }

    pub fn with_origin(mut self, value: Option<OriginLogInfo>) -> Self {
        self.origin = value;
        self
    }

    pub fn with_involve_non_team_member(mut self, value: Option<bool>) -> Self {
        self.involve_non_team_member = value;
        self
    }

    pub fn with_context(mut self, value: Option<ContextLogInfo>) -> Self {
        self.context = value;
        self
    }

    pub fn with_participants(mut self, value: Option<Vec<ParticipantLogInfo>>) -> Self {
        self.participants = value;
        self
    }

    pub fn with_assets(mut self, value: Option<Vec<AssetLogInfo>>) -> Self {
        self.assets = value;
        self
    }

}

const TEAM_EVENT_FIELDS: &[&str] = &["timestamp",
                                     "event_category",
                                     "event_type",
                                     "details",
                                     "actor",
                                     "origin",
                                     "involve_non_team_member",
                                     "context",
                                     "participants",
                                     "assets"];
impl TeamEvent {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamEvent, V::Error> {
        use serde::de;
        let mut field_timestamp = None;
        let mut field_event_category = None;
        let mut field_event_type = None;
        let mut field_details = None;
        let mut field_actor = None;
        let mut field_origin = None;
        let mut field_involve_non_team_member = None;
        let mut field_context = None;
        let mut field_participants = None;
        let mut field_assets = None;
        while let Some(key) = map.next_key()? {
            match key {
                "timestamp" => {
                    if field_timestamp.is_some() {
                        return Err(de::Error::duplicate_field("timestamp"));
                    }
                    field_timestamp = Some(map.next_value()?);
                }
                "event_category" => {
                    if field_event_category.is_some() {
                        return Err(de::Error::duplicate_field("event_category"));
                    }
                    field_event_category = Some(map.next_value()?);
                }
                "event_type" => {
                    if field_event_type.is_some() {
                        return Err(de::Error::duplicate_field("event_type"));
                    }
                    field_event_type = Some(map.next_value()?);
                }
                "details" => {
                    if field_details.is_some() {
                        return Err(de::Error::duplicate_field("details"));
                    }
                    field_details = Some(map.next_value()?);
                }
                "actor" => {
                    if field_actor.is_some() {
                        return Err(de::Error::duplicate_field("actor"));
                    }
                    field_actor = Some(map.next_value()?);
                }
                "origin" => {
                    if field_origin.is_some() {
                        return Err(de::Error::duplicate_field("origin"));
                    }
                    field_origin = Some(map.next_value()?);
                }
                "involve_non_team_member" => {
                    if field_involve_non_team_member.is_some() {
                        return Err(de::Error::duplicate_field("involve_non_team_member"));
                    }
                    field_involve_non_team_member = Some(map.next_value()?);
                }
                "context" => {
                    if field_context.is_some() {
                        return Err(de::Error::duplicate_field("context"));
                    }
                    field_context = Some(map.next_value()?);
                }
                "participants" => {
                    if field_participants.is_some() {
                        return Err(de::Error::duplicate_field("participants"));
                    }
                    field_participants = Some(map.next_value()?);
                }
                "assets" => {
                    if field_assets.is_some() {
                        return Err(de::Error::duplicate_field("assets"));
                    }
                    field_assets = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_EVENT_FIELDS))
            }
        }
        Ok(TeamEvent {
            timestamp: field_timestamp.ok_or_else(|| de::Error::missing_field("timestamp"))?,
            event_category: field_event_category.ok_or_else(|| de::Error::missing_field("event_category"))?,
            event_type: field_event_type.ok_or_else(|| de::Error::missing_field("event_type"))?,
            details: field_details.ok_or_else(|| de::Error::missing_field("details"))?,
            actor: field_actor,
            origin: field_origin,
            involve_non_team_member: field_involve_non_team_member,
            context: field_context,
            participants: field_participants,
            assets: field_assets,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("timestamp", &self.timestamp)?;
        s.serialize_field("event_category", &self.event_category)?;
        s.serialize_field("event_type", &self.event_type)?;
        s.serialize_field("details", &self.details)?;
        s.serialize_field("actor", &self.actor)?;
        s.serialize_field("origin", &self.origin)?;
        s.serialize_field("involve_non_team_member", &self.involve_non_team_member)?;
        s.serialize_field("context", &self.context)?;
        s.serialize_field("participants", &self.participants)?;
        s.serialize_field("assets", &self.assets)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamEvent {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamEvent;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamEvent struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamEvent::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamEvent", TEAM_EVENT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamEvent {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamEvent", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the archival status of a team folder.
#[derive(Debug)]
pub struct TeamFolderChangeStatusDetails {
    /// New team folder status.
    pub new_value: super::team::TeamFolderStatus,
    /// Previous team folder status. Might be missing due to historical data gap.
    pub previous_value: Option<super::team::TeamFolderStatus>,
}

impl TeamFolderChangeStatusDetails {
    pub fn new(new_value: super::team::TeamFolderStatus) -> Self {
        TeamFolderChangeStatusDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team::TeamFolderStatus>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl TeamFolderChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderChangeStatusDetails", TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderChangeStatusType {
    pub description: String,
}

impl TeamFolderChangeStatusType {
    pub fn new(description: String) -> Self {
        TeamFolderChangeStatusType {
            description,
        }
    }

}

const TEAM_FOLDER_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderChangeStatusType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_CHANGE_STATUS_TYPE_FIELDS))
            }
        }
        Ok(TeamFolderChangeStatusType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderChangeStatusType", TEAM_FOLDER_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a new team folder in active status.
#[derive(Debug)]
pub struct TeamFolderCreateDetails {
}

impl Default for TeamFolderCreateDetails {
    fn default() -> Self {
        TeamFolderCreateDetails {
        }
    }
}

const TEAM_FOLDER_CREATE_DETAILS_FIELDS: &[&str] = &[];
impl TeamFolderCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderCreateDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_FOLDER_CREATE_DETAILS_FIELDS));
        }
        Ok(TeamFolderCreateDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateDetails", TEAM_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderCreateDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderCreateType {
    pub description: String,
}

impl TeamFolderCreateType {
    pub fn new(description: String) -> Self {
        TeamFolderCreateType {
            description,
        }
    }

}

const TEAM_FOLDER_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderCreateType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_CREATE_TYPE_FIELDS))
            }
        }
        Ok(TeamFolderCreateType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateType", TEAM_FOLDER_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downgraded a team folder to a regular shared folder.
#[derive(Debug)]
pub struct TeamFolderDowngradeDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
}

impl TeamFolderDowngradeDetails {
    pub fn new(target_asset_index: u64) -> Self {
        TeamFolderDowngradeDetails {
            target_asset_index,
        }
    }

}

const TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS: &[&str] = &["target_asset_index"];
impl TeamFolderDowngradeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderDowngradeDetails, V::Error> {
        use serde::de;
        let mut field_target_asset_index = None;
        while let Some(key) = map.next_key()? {
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderDowngradeDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| de::Error::missing_field("target_asset_index"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderDowngradeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderDowngradeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderDowngradeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderDowngradeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderDowngradeDetails", TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderDowngradeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderDowngradeDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderDowngradeType {
    pub description: String,
}

impl TeamFolderDowngradeType {
    pub fn new(description: String) -> Self {
        TeamFolderDowngradeType {
            description,
        }
    }

}

const TEAM_FOLDER_DOWNGRADE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderDowngradeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderDowngradeType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_DOWNGRADE_TYPE_FIELDS))
            }
        }
        Ok(TeamFolderDowngradeType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderDowngradeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderDowngradeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderDowngradeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderDowngradeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderDowngradeType", TEAM_FOLDER_DOWNGRADE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderDowngradeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderDowngradeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted an archived team folder.
#[derive(Debug)]
pub struct TeamFolderPermanentlyDeleteDetails {
}

impl Default for TeamFolderPermanentlyDeleteDetails {
    fn default() -> Self {
        TeamFolderPermanentlyDeleteDetails {
        }
    }
}

const TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl TeamFolderPermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderPermanentlyDeleteDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS));
        }
        Ok(TeamFolderPermanentlyDeleteDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteDetails", TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderPermanentlyDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderPermanentlyDeleteType {
    pub description: String,
}

impl TeamFolderPermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        TeamFolderPermanentlyDeleteType {
            description,
        }
    }

}

const TEAM_FOLDER_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderPermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderPermanentlyDeleteType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_PERMANENTLY_DELETE_TYPE_FIELDS))
            }
        }
        Ok(TeamFolderPermanentlyDeleteType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderPermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderPermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteType", TEAM_FOLDER_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderPermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed an active or archived team folder.
#[derive(Debug)]
pub struct TeamFolderRenameDetails {
    /// Previous folder name.
    pub previous_folder_name: String,
    /// New folder name.
    pub new_folder_name: String,
}

impl TeamFolderRenameDetails {
    pub fn new(previous_folder_name: String, new_folder_name: String) -> Self {
        TeamFolderRenameDetails {
            previous_folder_name,
            new_folder_name,
        }
    }

}

const TEAM_FOLDER_RENAME_DETAILS_FIELDS: &[&str] = &["previous_folder_name",
                                                     "new_folder_name"];
impl TeamFolderRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderRenameDetails, V::Error> {
        use serde::de;
        let mut field_previous_folder_name = None;
        let mut field_new_folder_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "previous_folder_name" => {
                    if field_previous_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("previous_folder_name"));
                    }
                    field_previous_folder_name = Some(map.next_value()?);
                }
                "new_folder_name" => {
                    if field_new_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("new_folder_name"));
                    }
                    field_new_folder_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_RENAME_DETAILS_FIELDS))
            }
        }
        Ok(TeamFolderRenameDetails {
            previous_folder_name: field_previous_folder_name.ok_or_else(|| de::Error::missing_field("previous_folder_name"))?,
            new_folder_name: field_new_folder_name.ok_or_else(|| de::Error::missing_field("new_folder_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_folder_name", &self.previous_folder_name)?;
        s.serialize_field("new_folder_name", &self.new_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameDetails", TEAM_FOLDER_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderRenameType {
    pub description: String,
}

impl TeamFolderRenameType {
    pub fn new(description: String) -> Self {
        TeamFolderRenameType {
            description,
        }
    }

}

const TEAM_FOLDER_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderRenameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_RENAME_TYPE_FIELDS))
            }
        }
        Ok(TeamFolderRenameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameType", TEAM_FOLDER_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team linked app
#[derive(Debug)]
pub struct TeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for TeamLinkedAppLogInfo {
    fn default() -> Self {
        TeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const TEAM_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                   "display_name"];
impl TeamLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(TeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamLinkedAppLogInfo", TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team member's logged information.
#[derive(Debug)]
pub struct TeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayNameLegacy>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<EmailAddress>,
    /// Team member ID. Might be missing due to historical data gap.
    pub team_member_id: Option<super::team_common::TeamMemberId>,
    /// Team member external ID.
    pub member_external_id: Option<super::team_common::MemberExternalId>,
}

impl Default for TeamMemberLogInfo {
    fn default() -> Self {
        TeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
            team_member_id: None,
            member_external_id: None,
        }
    }
}

const TEAM_MEMBER_LOG_INFO_FIELDS: &[&str] = &["account_id",
                                               "display_name",
                                               "email",
                                               "team_member_id",
                                               "member_external_id"];
impl TeamMemberLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMemberLogInfo, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        let mut field_team_member_id = None;
        let mut field_member_external_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "member_external_id" => {
                    if field_member_external_id.is_some() {
                        return Err(de::Error::duplicate_field("member_external_id"));
                    }
                    field_member_external_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MEMBER_LOG_INFO_FIELDS))
            }
        }
        Ok(TeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
            team_member_id: field_team_member_id,
            member_external_id: field_member_external_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("member_external_id", &self.member_external_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberLogInfo", TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberLogInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamMembershipType {
    Free,
    Full,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMembershipType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "free" => Ok(TeamMembershipType::Free),
                    "full" => Ok(TeamMembershipType::Full),
                    _ => Ok(TeamMembershipType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["free",
                                    "full",
                                    "other"];
        deserializer.deserialize_struct("TeamMembershipType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMembershipType::Free => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "free")?;
                s.end()
            }
            TeamMembershipType::Full => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "full")?;
                s.end()
            }
            TeamMembershipType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Merged another team into this team.
#[derive(Debug)]
pub struct TeamMergeFromDetails {
    /// The name of the team that was merged into this team.
    pub team_name: String,
}

impl TeamMergeFromDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeFromDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_FROM_DETAILS_FIELDS: &[&str] = &["team_name"];
impl TeamMergeFromDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMergeFromDetails, V::Error> {
        use serde::de;
        let mut field_team_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_FROM_DETAILS_FIELDS))
            }
        }
        Ok(TeamMergeFromDetails {
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeFromDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeFromDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeFromDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeFromDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeFromDetails", TEAM_MERGE_FROM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeFromDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeFromDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeFromType {
    pub description: String,
}

impl TeamMergeFromType {
    pub fn new(description: String) -> Self {
        TeamMergeFromType {
            description,
        }
    }

}

const TEAM_MERGE_FROM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeFromType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMergeFromType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_FROM_TYPE_FIELDS))
            }
        }
        Ok(TeamMergeFromType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeFromType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeFromType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeFromType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeFromType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeFromType", TEAM_MERGE_FROM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeFromType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeFromType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Merged this team into another team.
#[derive(Debug)]
pub struct TeamMergeToDetails {
    /// The name of the team that this team was merged into.
    pub team_name: String,
}

impl TeamMergeToDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeToDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_TO_DETAILS_FIELDS: &[&str] = &["team_name"];
impl TeamMergeToDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMergeToDetails, V::Error> {
        use serde::de;
        let mut field_team_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_TO_DETAILS_FIELDS))
            }
        }
        Ok(TeamMergeToDetails {
            team_name: field_team_name.ok_or_else(|| de::Error::missing_field("team_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeToDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeToDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeToDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeToDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeToDetails", TEAM_MERGE_TO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeToDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeToDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeToType {
    pub description: String,
}

impl TeamMergeToType {
    pub fn new(description: String) -> Self {
        TeamMergeToType {
            description,
        }
    }

}

const TEAM_MERGE_TO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeToType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMergeToType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MERGE_TO_TYPE_FIELDS))
            }
        }
        Ok(TeamMergeToType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeToType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeToType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMergeToType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeToType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeToType", TEAM_MERGE_TO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeToType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeToType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team name details
#[derive(Debug)]
pub struct TeamName {
    /// Team's display name.
    pub team_display_name: String,
    /// Team's legal name.
    pub team_legal_name: String,
}

impl TeamName {
    pub fn new(team_display_name: String, team_legal_name: String) -> Self {
        TeamName {
            team_display_name,
            team_legal_name,
        }
    }

}

const TEAM_NAME_FIELDS: &[&str] = &["team_display_name",
                                    "team_legal_name"];
impl TeamName {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamName, V::Error> {
        use serde::de;
        let mut field_team_display_name = None;
        let mut field_team_legal_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_display_name" => {
                    if field_team_display_name.is_some() {
                        return Err(de::Error::duplicate_field("team_display_name"));
                    }
                    field_team_display_name = Some(map.next_value()?);
                }
                "team_legal_name" => {
                    if field_team_legal_name.is_some() {
                        return Err(de::Error::duplicate_field("team_legal_name"));
                    }
                    field_team_legal_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_NAME_FIELDS))
            }
        }
        Ok(TeamName {
            team_display_name: field_team_display_name.ok_or_else(|| de::Error::missing_field("team_display_name"))?,
            team_legal_name: field_team_legal_name.ok_or_else(|| de::Error::missing_field("team_legal_name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_display_name", &self.team_display_name)?;
        s.serialize_field("team_legal_name", &self.team_legal_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamName {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamName;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamName struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamName::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamName", TEAM_NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamName {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamName", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileAddLogoDetails {
}

impl Default for TeamProfileAddLogoDetails {
    fn default() -> Self {
        TeamProfileAddLogoDetails {
        }
    }
}

const TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileAddLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileAddLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileAddLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileAddLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileAddLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileAddLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileAddLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileAddLogoDetails", TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileAddLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileAddLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileAddLogoType {
    pub description: String,
}

impl TeamProfileAddLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileAddLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_ADD_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileAddLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileAddLogoType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_ADD_LOGO_TYPE_FIELDS))
            }
        }
        Ok(TeamProfileAddLogoType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileAddLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileAddLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileAddLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileAddLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileAddLogoType", TEAM_PROFILE_ADD_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileAddLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileAddLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the default language for the team.
#[derive(Debug)]
pub struct TeamProfileChangeDefaultLanguageDetails {
    /// New team's default language.
    pub new_value: super::common::LanguageCode,
    /// Previous team's default language.
    pub previous_value: super::common::LanguageCode,
}

impl TeamProfileChangeDefaultLanguageDetails {
    pub fn new(
        new_value: super::common::LanguageCode,
        previous_value: super::common::LanguageCode,
    ) -> Self {
        TeamProfileChangeDefaultLanguageDetails {
            new_value,
            previous_value,
        }
    }

}

const TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                       "previous_value"];
impl TeamProfileChangeDefaultLanguageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeDefaultLanguageDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_DETAILS_FIELDS))
            }
        }
        Ok(TeamProfileChangeDefaultLanguageDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| de::Error::missing_field("previous_value"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeDefaultLanguageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeDefaultLanguageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeDefaultLanguageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeDefaultLanguageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeDefaultLanguageDetails", TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeDefaultLanguageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeDefaultLanguageDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeDefaultLanguageType {
    pub description: String,
}

impl TeamProfileChangeDefaultLanguageType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeDefaultLanguageType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeDefaultLanguageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeDefaultLanguageType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_TYPE_FIELDS))
            }
        }
        Ok(TeamProfileChangeDefaultLanguageType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeDefaultLanguageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeDefaultLanguageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeDefaultLanguageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeDefaultLanguageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeDefaultLanguageType", TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeDefaultLanguageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeDefaultLanguageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileChangeLogoDetails {
}

impl Default for TeamProfileChangeLogoDetails {
    fn default() -> Self {
        TeamProfileChangeLogoDetails {
        }
    }
}

const TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileChangeLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileChangeLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeLogoDetails", TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileChangeLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeLogoType {
    pub description: String,
}

impl TeamProfileChangeLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeLogoType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_LOGO_TYPE_FIELDS))
            }
        }
        Ok(TeamProfileChangeLogoType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeLogoType", TEAM_PROFILE_CHANGE_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the team name.
#[derive(Debug)]
pub struct TeamProfileChangeNameDetails {
    /// New team name.
    pub new_value: TeamName,
    /// Previous teams name. Might be missing due to historical data gap.
    pub previous_value: Option<TeamName>,
}

impl TeamProfileChangeNameDetails {
    pub fn new(new_value: TeamName) -> Self {
        TeamProfileChangeNameDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TeamName>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl TeamProfileChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeNameDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS))
            }
        }
        Ok(TeamProfileChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeNameDetails", TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeNameType {
    pub description: String,
}

impl TeamProfileChangeNameType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeNameType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeNameType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_CHANGE_NAME_TYPE_FIELDS))
            }
        }
        Ok(TeamProfileChangeNameType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeNameType", TEAM_PROFILE_CHANGE_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the team logo to be displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileRemoveLogoDetails {
}

impl Default for TeamProfileRemoveLogoDetails {
    fn default() -> Self {
        TeamProfileRemoveLogoDetails {
        }
    }
}

const TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileRemoveLogoDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileRemoveLogoDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS));
        }
        Ok(TeamProfileRemoveLogoDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileRemoveLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileRemoveLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileRemoveLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileRemoveLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileRemoveLogoDetails", TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileRemoveLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileRemoveLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileRemoveLogoType {
    pub description: String,
}

impl TeamProfileRemoveLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileRemoveLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_REMOVE_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileRemoveLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileRemoveLogoType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_PROFILE_REMOVE_LOGO_TYPE_FIELDS))
            }
        }
        Ok(TeamProfileRemoveLogoType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileRemoveLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileRemoveLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamProfileRemoveLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileRemoveLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileRemoveLogoType", TEAM_PROFILE_REMOVE_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileRemoveLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileRemoveLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaAddBackupPhoneDetails {
}

impl Default for TfaAddBackupPhoneDetails {
    fn default() -> Self {
        TfaAddBackupPhoneDetails {
        }
    }
}

const TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaAddBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaAddBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddBackupPhoneDetails", TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaAddBackupPhoneType {
    pub description: String,
}

impl TfaAddBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaAddBackupPhoneType {
            description,
        }
    }

}

const TFA_ADD_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaAddBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddBackupPhoneType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_ADD_BACKUP_PHONE_TYPE_FIELDS))
            }
        }
        Ok(TfaAddBackupPhoneType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddBackupPhoneType", TFA_ADD_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaAddBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a security key for two-step verification.
#[derive(Debug)]
pub struct TfaAddSecurityKeyDetails {
}

impl Default for TfaAddSecurityKeyDetails {
    fn default() -> Self {
        TfaAddSecurityKeyDetails {
        }
    }
}

const TFA_ADD_SECURITY_KEY_DETAILS_FIELDS: &[&str] = &[];
impl TfaAddSecurityKeyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddSecurityKeyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_ADD_SECURITY_KEY_DETAILS_FIELDS));
        }
        Ok(TfaAddSecurityKeyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddSecurityKeyDetails", TFA_ADD_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddSecurityKeyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaAddSecurityKeyType {
    pub description: String,
}

impl TfaAddSecurityKeyType {
    pub fn new(description: String) -> Self {
        TfaAddSecurityKeyType {
            description,
        }
    }

}

const TFA_ADD_SECURITY_KEY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaAddSecurityKeyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddSecurityKeyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_ADD_SECURITY_KEY_TYPE_FIELDS))
            }
        }
        Ok(TfaAddSecurityKeyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddSecurityKeyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddSecurityKeyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaAddSecurityKeyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddSecurityKeyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddSecurityKeyType", TFA_ADD_SECURITY_KEY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddSecurityKeyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaAddSecurityKeyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaChangeBackupPhoneDetails {
}

impl Default for TfaChangeBackupPhoneDetails {
    fn default() -> Self {
        TfaChangeBackupPhoneDetails {
        }
    }
}

const TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaChangeBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangeBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaChangeBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeBackupPhoneDetails", TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaChangeBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaChangeBackupPhoneType {
    pub description: String,
}

impl TfaChangeBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaChangeBackupPhoneType {
            description,
        }
    }

}

const TFA_CHANGE_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangeBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangeBackupPhoneType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_BACKUP_PHONE_TYPE_FIELDS))
            }
        }
        Ok(TfaChangeBackupPhoneType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeBackupPhoneType", TFA_CHANGE_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Change two-step verification policy for the team.
#[derive(Debug)]
pub struct TfaChangePolicyDetails {
    /// New change policy.
    pub new_value: super::team_policies::TwoStepVerificationPolicy,
    /// Previous change policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::TwoStepVerificationPolicy>,
}

impl TfaChangePolicyDetails {
    pub fn new(new_value: super::team_policies::TwoStepVerificationPolicy) -> Self {
        TfaChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::TwoStepVerificationPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const TFA_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl TfaChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(TfaChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangePolicyDetails", TFA_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TfaChangePolicyType {
    pub description: String,
}

impl TfaChangePolicyType {
    pub fn new(description: String) -> Self {
        TfaChangePolicyType {
            description,
        }
    }

}

const TFA_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(TfaChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangePolicyType", TFA_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled, disabled or changed the configuration for two-step verification.
#[derive(Debug)]
pub struct TfaChangeStatusDetails {
    /// The new two factor authentication configuration.
    pub new_value: TfaConfiguration,
    /// The previous two factor authentication configuration. Might be missing due to historical
    /// data gap.
    pub previous_value: Option<TfaConfiguration>,
    /// Used two factor authentication rescue code. This flag is relevant when the two factor
    /// authentication configuration is disabled.
    pub used_rescue_code: Option<bool>,
}

impl TfaChangeStatusDetails {
    pub fn new(new_value: TfaConfiguration) -> Self {
        TfaChangeStatusDetails {
            new_value,
            previous_value: None,
            used_rescue_code: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TfaConfiguration>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_used_rescue_code(mut self, value: Option<bool>) -> Self {
        self.used_rescue_code = value;
        self
    }

}

const TFA_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value",
                                                    "used_rescue_code"];
impl TfaChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangeStatusDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_used_rescue_code = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "used_rescue_code" => {
                    if field_used_rescue_code.is_some() {
                        return Err(de::Error::duplicate_field("used_rescue_code"));
                    }
                    field_used_rescue_code = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_STATUS_DETAILS_FIELDS))
            }
        }
        Ok(TfaChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            used_rescue_code: field_used_rescue_code,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("used_rescue_code", &self.used_rescue_code)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeStatusDetails", TFA_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TfaChangeStatusType {
    pub description: String,
}

impl TfaChangeStatusType {
    pub fn new(description: String) -> Self {
        TfaChangeStatusType {
            description,
        }
    }

}

const TFA_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangeStatusType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_CHANGE_STATUS_TYPE_FIELDS))
            }
        }
        Ok(TfaChangeStatusType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeStatusType", TFA_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Two factor authentication configuration. Note: the enabled option is deprecated.
#[derive(Debug)]
pub enum TfaConfiguration {
    Disabled,
    Enabled,
    Sms,
    Authenticator,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TfaConfiguration {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TfaConfiguration;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaConfiguration structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(TfaConfiguration::Disabled),
                    "enabled" => Ok(TfaConfiguration::Enabled),
                    "sms" => Ok(TfaConfiguration::Sms),
                    "authenticator" => Ok(TfaConfiguration::Authenticator),
                    _ => Ok(TfaConfiguration::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "sms",
                                    "authenticator",
                                    "other"];
        deserializer.deserialize_struct("TfaConfiguration", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TfaConfiguration {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TfaConfiguration::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TfaConfiguration::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TfaConfiguration::Sms => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "sms")?;
                s.end()
            }
            TfaConfiguration::Authenticator => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "authenticator")?;
                s.end()
            }
            TfaConfiguration::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Removed the backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveBackupPhoneDetails {
}

impl Default for TfaRemoveBackupPhoneDetails {
    fn default() -> Self {
        TfaRemoveBackupPhoneDetails {
        }
    }
}

const TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaRemoveBackupPhoneDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveBackupPhoneDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS));
        }
        Ok(TfaRemoveBackupPhoneDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveBackupPhoneDetails", TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaRemoveBackupPhoneType {
    pub description: String,
}

impl TfaRemoveBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaRemoveBackupPhoneType {
            description,
        }
    }

}

const TFA_REMOVE_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaRemoveBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveBackupPhoneType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_REMOVE_BACKUP_PHONE_TYPE_FIELDS))
            }
        }
        Ok(TfaRemoveBackupPhoneType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveBackupPhoneType", TFA_REMOVE_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaRemoveBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed a security key for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveSecurityKeyDetails {
}

impl Default for TfaRemoveSecurityKeyDetails {
    fn default() -> Self {
        TfaRemoveSecurityKeyDetails {
        }
    }
}

const TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS: &[&str] = &[];
impl TfaRemoveSecurityKeyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveSecurityKeyDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS));
        }
        Ok(TfaRemoveSecurityKeyDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveSecurityKeyDetails", TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveSecurityKeyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaRemoveSecurityKeyType {
    pub description: String,
}

impl TfaRemoveSecurityKeyType {
    pub fn new(description: String) -> Self {
        TfaRemoveSecurityKeyType {
            description,
        }
    }

}

const TFA_REMOVE_SECURITY_KEY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaRemoveSecurityKeyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveSecurityKeyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_REMOVE_SECURITY_KEY_TYPE_FIELDS))
            }
        }
        Ok(TfaRemoveSecurityKeyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveSecurityKeyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveSecurityKeyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveSecurityKeyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveSecurityKeyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveSecurityKeyType", TFA_REMOVE_SECURITY_KEY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveSecurityKeyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaRemoveSecurityKeyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset two-step verification for team member.
#[derive(Debug)]
pub struct TfaResetDetails {
}

impl Default for TfaResetDetails {
    fn default() -> Self {
        TfaResetDetails {
        }
    }
}

const TFA_RESET_DETAILS_FIELDS: &[&str] = &[];
impl TfaResetDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaResetDetails, V::Error> {
        use serde::de;
        if let Some(key) = map.next_key()? {
            return Err(de::Error::unknown_field(key, TFA_RESET_DETAILS_FIELDS));
        }
        Ok(TfaResetDetails {
        })
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaResetDetails", TFA_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaResetDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaResetType {
    pub description: String,
}

impl TfaResetType {
    pub fn new(description: String) -> Self {
        TfaResetType {
            description,
        }
    }

}

const TFA_RESET_TYPE_FIELDS: &[&str] = &["description"];
impl TfaResetType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaResetType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TFA_RESET_TYPE_FIELDS))
            }
        }
        Ok(TfaResetType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaResetType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaResetType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TfaResetType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaResetType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaResetType", TFA_RESET_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaResetType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaResetType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TimeUnit {
    Milliseconds,
    Seconds,
    Minutes,
    Hours,
    Days,
    Weeks,
    Months,
    Years,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TimeUnit {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TimeUnit;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TimeUnit structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "milliseconds" => Ok(TimeUnit::Milliseconds),
                    "seconds" => Ok(TimeUnit::Seconds),
                    "minutes" => Ok(TimeUnit::Minutes),
                    "hours" => Ok(TimeUnit::Hours),
                    "days" => Ok(TimeUnit::Days),
                    "weeks" => Ok(TimeUnit::Weeks),
                    "months" => Ok(TimeUnit::Months),
                    "years" => Ok(TimeUnit::Years),
                    _ => Ok(TimeUnit::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["milliseconds",
                                    "seconds",
                                    "minutes",
                                    "hours",
                                    "days",
                                    "weeks",
                                    "months",
                                    "years",
                                    "other"];
        deserializer.deserialize_struct("TimeUnit", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TimeUnit {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TimeUnit::Milliseconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "milliseconds")?;
                s.end()
            }
            TimeUnit::Seconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "seconds")?;
                s.end()
            }
            TimeUnit::Minutes => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "minutes")?;
                s.end()
            }
            TimeUnit::Hours => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "hours")?;
                s.end()
            }
            TimeUnit::Days => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "days")?;
                s.end()
            }
            TimeUnit::Weeks => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "weeks")?;
                s.end()
            }
            TimeUnit::Months => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "months")?;
                s.end()
            }
            TimeUnit::Years => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "years")?;
                s.end()
            }
            TimeUnit::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled or disabled the option for team members to link a personal Dropbox account in addition
/// to their work account to the same computer.
#[derive(Debug)]
pub struct TwoAccountChangePolicyDetails {
    /// New two account policy.
    pub new_value: TwoAccountPolicy,
    /// Previous two account policy. Might be missing due to historical data gap.
    pub previous_value: Option<TwoAccountPolicy>,
}

impl TwoAccountChangePolicyDetails {
    pub fn new(new_value: TwoAccountPolicy) -> Self {
        TwoAccountChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TwoAccountPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl TwoAccountChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TwoAccountChangePolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(TwoAccountChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TwoAccountChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TwoAccountChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TwoAccountChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TwoAccountChangePolicyDetails", TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TwoAccountChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TwoAccountChangePolicyType {
    pub description: String,
}

impl TwoAccountChangePolicyType {
    pub fn new(description: String) -> Self {
        TwoAccountChangePolicyType {
            description,
        }
    }

}

const TWO_ACCOUNT_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl TwoAccountChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TwoAccountChangePolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TWO_ACCOUNT_CHANGE_POLICY_TYPE_FIELDS))
            }
        }
        Ok(TwoAccountChangePolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TwoAccountChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TwoAccountChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TwoAccountChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TwoAccountChangePolicyType", TWO_ACCOUNT_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TwoAccountChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for pairing personal account to work account
#[derive(Debug)]
pub enum TwoAccountPolicy {
    Disabled,
    Enabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TwoAccountPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TwoAccountPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => Ok(TwoAccountPolicy::Disabled),
                    "enabled" => Ok(TwoAccountPolicy::Enabled),
                    _ => Ok(TwoAccountPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("TwoAccountPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TwoAccountPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TwoAccountPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TwoAccountPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User linked app
#[derive(Debug)]
pub struct UserLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserLinkedAppLogInfo {
    fn default() -> Self {
        UserLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                   "display_name"];
impl UserLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(UserLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserLinkedAppLogInfo", USER_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User's logged information.
#[derive(Debug)]
pub enum UserLogInfo {
    TeamMember(TeamMemberLogInfo),
    NonTeamMember(NonTeamMemberLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for UserLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UserLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(UserLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(UserLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    _ => Ok(UserLogInfo::_Unknown)
                }
            }
        }
        const VARIANTS: &[&str] = &["non_team_member",
                                    "non_team_member"];
        deserializer.deserialize_struct("UserLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UserLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            UserLogInfo::TeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 6)?;
                s.serialize_field(".tag", "team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.serialize_field("team_member_id", &x.team_member_id)?;
                s.serialize_field("member_external_id", &x.member_external_id)?;
                s.end()
            }
            UserLogInfo::NonTeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.end()
            }
            UserLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// User's name logged information
#[derive(Debug)]
pub struct UserNameLogInfo {
    /// Given name.
    pub given_name: String,
    /// Surname.
    pub surname: String,
    /// Locale. Might be missing due to historical data gap.
    pub locale: Option<String>,
}

impl UserNameLogInfo {
    pub fn new(given_name: String, surname: String) -> Self {
        UserNameLogInfo {
            given_name,
            surname,
            locale: None,
        }
    }

    pub fn with_locale(mut self, value: Option<String>) -> Self {
        self.locale = value;
        self
    }

}

const USER_NAME_LOG_INFO_FIELDS: &[&str] = &["given_name",
                                             "surname",
                                             "locale"];
impl UserNameLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserNameLogInfo, V::Error> {
        use serde::de;
        let mut field_given_name = None;
        let mut field_surname = None;
        let mut field_locale = None;
        while let Some(key) = map.next_key()? {
            match key {
                "given_name" => {
                    if field_given_name.is_some() {
                        return Err(de::Error::duplicate_field("given_name"));
                    }
                    field_given_name = Some(map.next_value()?);
                }
                "surname" => {
                    if field_surname.is_some() {
                        return Err(de::Error::duplicate_field("surname"));
                    }
                    field_surname = Some(map.next_value()?);
                }
                "locale" => {
                    if field_locale.is_some() {
                        return Err(de::Error::duplicate_field("locale"));
                    }
                    field_locale = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_NAME_LOG_INFO_FIELDS))
            }
        }
        Ok(UserNameLogInfo {
            given_name: field_given_name.ok_or_else(|| de::Error::missing_field("given_name"))?,
            surname: field_surname.ok_or_else(|| de::Error::missing_field("surname"))?,
            locale: field_locale,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("given_name", &self.given_name)?;
        s.serialize_field("surname", &self.surname)?;
        s.serialize_field("locale", &self.locale)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserNameLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserNameLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserNameLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserNameLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserNameLogInfo", USER_NAME_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserNameLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserNameLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User or team linked app. Used when linked type is missing due to historical data gap.
#[derive(Debug)]
pub struct UserOrTeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserOrTeamLinkedAppLogInfo {
    fn default() -> Self {
        UserOrTeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                           "display_name"];
impl UserOrTeamLinkedAppLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserOrTeamLinkedAppLogInfo, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS))
            }
        }
        Ok(UserOrTeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserOrTeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserOrTeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserOrTeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserOrTeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserOrTeamLinkedAppLogInfo", USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserOrTeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserOrTeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information on active web sessions
#[derive(Debug)]
pub struct WebDeviceSessionLogInfo {
    /// Information on the hosting device.
    pub user_agent: String,
    /// Information on the hosting operating system.
    pub os: String,
    /// Information on the browser used for this web session.
    pub browser: String,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_id: Option<DeviceSessionId>,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
}

impl WebDeviceSessionLogInfo {
    pub fn new(user_agent: String, os: String, browser: String) -> Self {
        WebDeviceSessionLogInfo {
            user_agent,
            os,
            browser,
            session_id: None,
            ip_address: None,
            created: None,
            updated: None,
        }
    }

    pub fn with_session_id(mut self, value: Option<DeviceSessionId>) -> Self {
        self.session_id = value;
        self
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

}

const WEB_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["user_agent",
                                                      "os",
                                                      "browser",
                                                      "session_id",
                                                      "ip_address",
                                                      "created",
                                                      "updated"];
impl WebDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebDeviceSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_user_agent = None;
        let mut field_os = None;
        let mut field_browser = None;
        let mut field_session_id = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        while let Some(key) = map.next_key()? {
            match key {
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                "os" => {
                    if field_os.is_some() {
                        return Err(de::Error::duplicate_field("os"));
                    }
                    field_os = Some(map.next_value()?);
                }
                "browser" => {
                    if field_browser.is_some() {
                        return Err(de::Error::duplicate_field("browser"));
                    }
                    field_browser = Some(map.next_value()?);
                }
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_DEVICE_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(WebDeviceSessionLogInfo {
            user_agent: field_user_agent.ok_or_else(|| de::Error::missing_field("user_agent"))?,
            os: field_os.ok_or_else(|| de::Error::missing_field("os"))?,
            browser: field_browser.ok_or_else(|| de::Error::missing_field("browser"))?,
            session_id: field_session_id,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_agent", &self.user_agent)?;
        s.serialize_field("os", &self.os)?;
        s.serialize_field("browser", &self.browser)?;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebDeviceSessionLogInfo", WEB_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebDeviceSessionLogInfo", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web session.
#[derive(Debug)]
pub struct WebSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for WebSessionLogInfo {
    fn default() -> Self {
        WebSessionLogInfo {
            session_id: None,
        }
    }
}

const WEB_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl WebSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionLogInfo, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSION_LOG_INFO_FIELDS))
            }
        }
        Ok(WebSessionLogInfo {
            session_id: field_session_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionLogInfo", WEB_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long team members can stay signed in to Dropbox on the web.
#[derive(Debug)]
pub struct WebSessionsChangeFixedLengthPolicyDetails {
    /// New session length policy. Might be missing due to historical data gap.
    pub new_value: Option<WebSessionsFixedLengthPolicy>,
    /// Previous session length policy. Might be missing due to historical data gap.
    pub previous_value: Option<WebSessionsFixedLengthPolicy>,
}

impl Default for WebSessionsChangeFixedLengthPolicyDetails {
    fn default() -> Self {
        WebSessionsChangeFixedLengthPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                          "previous_value"];
impl WebSessionsChangeFixedLengthPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeFixedLengthPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(WebSessionsChangeFixedLengthPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeFixedLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeFixedLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeFixedLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeFixedLengthPolicyDetails", WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeFixedLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeFixedLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WebSessionsChangeFixedLengthPolicyType {
    pub description: String,
}

impl WebSessionsChangeFixedLengthPolicyType {
    pub fn new(description: String) -> Self {
        WebSessionsChangeFixedLengthPolicyType {
            description,
        }
    }

}

const WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl WebSessionsChangeFixedLengthPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeFixedLengthPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_TYPE_FIELDS))
            }
        }
        Ok(WebSessionsChangeFixedLengthPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeFixedLengthPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeFixedLengthPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeFixedLengthPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeFixedLengthPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeFixedLengthPolicyType", WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeFixedLengthPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeFixedLengthPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long team members can be idle while signed in to Dropbox on the web.
#[derive(Debug)]
pub struct WebSessionsChangeIdleLengthPolicyDetails {
    /// New idle length policy. Might be missing due to historical data gap.
    pub new_value: Option<WebSessionsIdleLengthPolicy>,
    /// Previous idle length policy. Might be missing due to historical data gap.
    pub previous_value: Option<WebSessionsIdleLengthPolicy>,
}

impl Default for WebSessionsChangeIdleLengthPolicyDetails {
    fn default() -> Self {
        WebSessionsChangeIdleLengthPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl WebSessionsChangeIdleLengthPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeIdleLengthPolicyDetails, V::Error> {
        use serde::de;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS))
            }
        }
        Ok(WebSessionsChangeIdleLengthPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeIdleLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeIdleLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeIdleLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeIdleLengthPolicyDetails", WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeIdleLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeIdleLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WebSessionsChangeIdleLengthPolicyType {
    pub description: String,
}

impl WebSessionsChangeIdleLengthPolicyType {
    pub fn new(description: String) -> Self {
        WebSessionsChangeIdleLengthPolicyType {
            description,
        }
    }

}

const WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl WebSessionsChangeIdleLengthPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeIdleLengthPolicyType, V::Error> {
        use serde::de;
        let mut field_description = None;
        while let Some(key) = map.next_key()? {
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_TYPE_FIELDS))
            }
        }
        Ok(WebSessionsChangeIdleLengthPolicyType {
            description: field_description.ok_or_else(|| de::Error::missing_field("description"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeIdleLengthPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeIdleLengthPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeIdleLengthPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeIdleLengthPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeIdleLengthPolicyType", WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeIdleLengthPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeIdleLengthPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web sessions fixed length policy.
#[derive(Debug)]
pub enum WebSessionsFixedLengthPolicy {
    /// Defined fixed session length.
    Defined(DurationLogInfo),
    /// Undefined fixed session length.
    Undefined,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsFixedLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsFixedLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsFixedLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsFixedLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => Ok(WebSessionsFixedLengthPolicy::Undefined),
                    _ => Ok(WebSessionsFixedLengthPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["defined",
                                    "undefined",
                                    "other"];
        deserializer.deserialize_struct("WebSessionsFixedLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsFixedLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsFixedLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Web sessions idle length policy.
#[derive(Debug)]
pub enum WebSessionsIdleLengthPolicy {
    /// Defined idle session length.
    Defined(DurationLogInfo),
    /// Undefined idle session length.
    Undefined,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsIdleLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsIdleLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a WebSessionsIdleLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsIdleLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => Ok(WebSessionsIdleLengthPolicy::Undefined),
                    _ => Ok(WebSessionsIdleLengthPolicy::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["defined",
                                    "undefined",
                                    "other"];
        deserializer.deserialize_struct("WebSessionsIdleLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsIdleLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsIdleLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

