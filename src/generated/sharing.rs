// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

//! This namespace contains endpoints and data types for creating and managing shared links and
//! shared folders.

pub type DropboxId = String;
pub type FileId = String;
pub type GetSharedLinkFileArg = GetSharedLinkMetadataArg;
pub type Id = super::files::Id;
pub type Path = super::files::Path;
pub type PathOrId = String;
pub type ReadPath = super::files::ReadPath;
pub type Rev = super::files::Rev;
pub type TeamInfo = super::users::Team;

/// Adds specified members to a file.
pub fn add_file_member(client: &::client_trait::HttpClient, arg: &AddFileMemberArgs) -> ::Result<Result<Vec<FileMemberActionResult>, AddFileMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/add_file_member", arg, None)
}

/// Allows an owner or editor (if the ACL update policy allows) of a shared folder to add another
/// member. For the new member to get access to all the functionality for this folder, you will need
/// to call :route:`mount_folder` on their behalf. Apps must have full Dropbox access to use this
/// endpoint.
pub fn add_folder_member(client: &::client_trait::HttpClient, arg: &AddFolderMemberArg) -> ::Result<Result<(), AddFolderMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/add_folder_member", arg, None)
}

/// Identical to update_file_member but with less information returned.
pub fn change_file_member_access(client: &::client_trait::HttpClient, arg: &ChangeFileMemberAccessArgs) -> ::Result<Result<FileMemberActionResult, FileMemberActionError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/change_file_member_access", arg, None)
}

/// Returns the status of an asynchronous job. Apps must have full Dropbox access to use this
/// endpoint.
pub fn check_job_status(client: &::client_trait::HttpClient, arg: &super::async::PollArg) -> ::Result<Result<JobStatus, super::async::PollError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/check_job_status", arg, None)
}

/// Returns the status of an asynchronous job for sharing a folder. Apps must have full Dropbox
/// access to use this endpoint.
pub fn check_remove_member_job_status(client: &::client_trait::HttpClient, arg: &super::async::PollArg) -> ::Result<Result<RemoveMemberJobStatus, super::async::PollError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/check_remove_member_job_status", arg, None)
}

/// Returns the status of an asynchronous job for sharing a folder. Apps must have full Dropbox
/// access to use this endpoint.
pub fn check_share_job_status(client: &::client_trait::HttpClient, arg: &super::async::PollArg) -> ::Result<Result<ShareFolderJobStatus, super::async::PollError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/check_share_job_status", arg, None)
}

/// Create a shared link. If a shared link already exists for the given path, that link is returned.
/// Note that in the returned :type:`PathLinkMetadata`, the :field:`PathLinkMetadata.url` field is
/// the shortened URL if :field:`CreateSharedLinkArg.short_url` argument is set to :val:`true`.
/// Previously, it was technically possible to break a shared link by moving or renaming the
/// corresponding file or folder. In the future, this will no longer be the case, so your app
/// shouldn't rely on this behavior. Instead, if your app needs to revoke a shared link, use
/// :route:`revoke_shared_link`.
pub fn create_shared_link(client: &::client_trait::HttpClient, arg: &CreateSharedLinkArg) -> ::Result<Result<PathLinkMetadata, CreateSharedLinkError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/create_shared_link", arg, None)
}

/// Create a shared link with custom settings. If no settings are given then the default visibility
/// is :field:`RequestedVisibility.public` (The resolved visibility, though, may depend on other
/// aspects such as team and shared folder settings).
pub fn create_shared_link_with_settings(client: &::client_trait::HttpClient, arg: &CreateSharedLinkWithSettingsArg) -> ::Result<Result<SharedLinkMetadata, CreateSharedLinkWithSettingsError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/create_shared_link_with_settings", arg, None)
}

/// Returns shared file metadata.
pub fn get_file_metadata(client: &::client_trait::HttpClient, arg: &GetFileMetadataArg) -> ::Result<Result<SharedFileMetadata, GetFileMetadataError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/get_file_metadata", arg, None)
}

/// Returns shared file metadata.
pub fn get_file_metadata_batch(client: &::client_trait::HttpClient, arg: &GetFileMetadataBatchArg) -> ::Result<Result<Vec<GetFileMetadataBatchResult>, SharingUserError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/get_file_metadata/batch", arg, None)
}

/// Returns shared folder metadata by its folder ID. Apps must have full Dropbox access to use this
/// endpoint.
pub fn get_folder_metadata(client: &::client_trait::HttpClient, arg: &GetMetadataArgs) -> ::Result<Result<SharedFolderMetadata, SharedFolderAccessError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/get_folder_metadata", arg, None)
}

/// Download the shared link's file from a user's Dropbox.
pub fn get_shared_link_file(client: &::client_trait::HttpClient, arg: &GetSharedLinkFileArg, range_start: Option<u64>, range_end: Option<u64>) -> ::Result<Result<::client_trait::HttpRequestResult<SharedLinkMetadata>, GetSharedLinkFileError>> {
    ::client_helpers::request_with_body(client, ::client_trait::Endpoint::Content, "sharing/get_shared_link_file", arg, None, range_start, range_end)
}

/// Get the shared link's metadata.
pub fn get_shared_link_metadata(client: &::client_trait::HttpClient, arg: &GetSharedLinkMetadataArg) -> ::Result<Result<SharedLinkMetadata, SharedLinkError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/get_shared_link_metadata", arg, None)
}

/// Returns a list of :type:`LinkMetadata` objects for this user, including collection links. If no
/// path is given, returns a list of all shared links for the current user, including collection
/// links, up to a maximum of 1000 links. If a non-empty path is given, returns a list of all shared
/// links that allow access to the given path.  Collection links are never returned in this case.
/// Note that the url field in the response is never the shortened URL.
pub fn get_shared_links(client: &::client_trait::HttpClient, arg: &GetSharedLinksArg) -> ::Result<Result<GetSharedLinksResult, GetSharedLinksError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/get_shared_links", arg, None)
}

/// Use to obtain the members who have been invited to a file, both inherited and uninherited
/// members.
pub fn list_file_members(client: &::client_trait::HttpClient, arg: &ListFileMembersArg) -> ::Result<Result<SharedFileMembers, ListFileMembersError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_file_members", arg, None)
}

/// Get members of multiple files at once. The arguments to this route are more limited, and the
/// limit on query result size per file is more strict. To customize the results more, use the
/// individual file endpoint. Inherited users and groups are not included in the result, and
/// permissions are not returned for this endpoint.
pub fn list_file_members_batch(client: &::client_trait::HttpClient, arg: &ListFileMembersBatchArg) -> ::Result<Result<Vec<ListFileMembersBatchResult>, SharingUserError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_file_members/batch", arg, None)
}

/// Once a cursor has been retrieved from :route:`list_file_members` or
/// :route:`list_file_members/batch`, use this to paginate through all shared file members.
pub fn list_file_members_continue(client: &::client_trait::HttpClient, arg: &ListFileMembersContinueArg) -> ::Result<Result<SharedFileMembers, ListFileMembersContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_file_members/continue", arg, None)
}

/// Returns shared folder membership by its folder ID. Apps must have full Dropbox access to use
/// this endpoint.
pub fn list_folder_members(client: &::client_trait::HttpClient, arg: &ListFolderMembersArgs) -> ::Result<Result<SharedFolderMembers, SharedFolderAccessError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_folder_members", arg, None)
}

/// Once a cursor has been retrieved from :route:`list_folder_members`, use this to paginate through
/// all shared folder members. Apps must have full Dropbox access to use this endpoint.
pub fn list_folder_members_continue(client: &::client_trait::HttpClient, arg: &ListFolderMembersContinueArg) -> ::Result<Result<SharedFolderMembers, ListFolderMembersContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_folder_members/continue", arg, None)
}

/// Return the list of all shared folders the current user has access to. Apps must have full
/// Dropbox access to use this endpoint.
pub fn list_folders(client: &::client_trait::HttpClient, arg: &ListFoldersArgs) -> ::Result<Result<ListFoldersResult, ()>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_folders", arg, None)
}

/// Once a cursor has been retrieved from :route:`list_folders`, use this to paginate through all
/// shared folders. The cursor must come from a previous call to :route:`list_folders` or
/// :route:`list_folders/continue`. Apps must have full Dropbox access to use this endpoint.
pub fn list_folders_continue(client: &::client_trait::HttpClient, arg: &ListFoldersContinueArg) -> ::Result<Result<ListFoldersResult, ListFoldersContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_folders/continue", arg, None)
}

/// Return the list of all shared folders the current user can mount or unmount. Apps must have full
/// Dropbox access to use this endpoint.
pub fn list_mountable_folders(client: &::client_trait::HttpClient, arg: &ListFoldersArgs) -> ::Result<Result<ListFoldersResult, ()>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_mountable_folders", arg, None)
}

/// Once a cursor has been retrieved from :route:`list_mountable_folders`, use this to paginate
/// through all mountable shared folders. The cursor must come from a previous call to
/// :route:`list_mountable_folders` or :route:`list_mountable_folders/continue`. Apps must have full
/// Dropbox access to use this endpoint.
pub fn list_mountable_folders_continue(client: &::client_trait::HttpClient, arg: &ListFoldersContinueArg) -> ::Result<Result<ListFoldersResult, ListFoldersContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_mountable_folders/continue", arg, None)
}

/// Returns a list of all files shared with current user.  Does not include files the user has
/// received via shared folders, and does  not include unclaimed invitations.
pub fn list_received_files(client: &::client_trait::HttpClient, arg: &ListFilesArg) -> ::Result<Result<ListFilesResult, SharingUserError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_received_files", arg, None)
}

/// Get more results with a cursor from :route:`list_received_files`.
pub fn list_received_files_continue(client: &::client_trait::HttpClient, arg: &ListFilesContinueArg) -> ::Result<Result<ListFilesResult, ListFilesContinueError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_received_files/continue", arg, None)
}

/// List shared links of this user. If no path is given, returns a list of all shared links for the
/// current user. If a non-empty path is given, returns a list of all shared links that allow access
/// to the given path - direct links to the given path and links to parent folders of the given
/// path. Links to parent folders can be suppressed by setting direct_only to true.
pub fn list_shared_links(client: &::client_trait::HttpClient, arg: &ListSharedLinksArg) -> ::Result<Result<ListSharedLinksResult, ListSharedLinksError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/list_shared_links", arg, None)
}

/// Modify the shared link's settings. If the requested visibility conflict with the shared links
/// policy of the team or the shared folder (in case the linked file is part of a shared folder)
/// then the :field:`LinkPermissions.resolved_visibility` of the returned :type:`SharedLinkMetadata`
/// will reflect the actual visibility of the shared link and the
/// :field:`LinkPermissions.requested_visibility` will reflect the requested visibility.
pub fn modify_shared_link_settings(client: &::client_trait::HttpClient, arg: &ModifySharedLinkSettingsArgs) -> ::Result<Result<SharedLinkMetadata, ModifySharedLinkSettingsError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/modify_shared_link_settings", arg, None)
}

/// The current user mounts the designated folder. Mount a shared folder for a user after they have
/// been added as a member. Once mounted, the shared folder will appear in their Dropbox. Apps must
/// have full Dropbox access to use this endpoint.
pub fn mount_folder(client: &::client_trait::HttpClient, arg: &MountFolderArg) -> ::Result<Result<SharedFolderMetadata, MountFolderError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/mount_folder", arg, None)
}

/// The current user relinquishes their membership in the designated file. Note that the current
/// user may still have inherited access to this file through the parent folder. Apps must have full
/// Dropbox access to use this endpoint.
pub fn relinquish_file_membership(client: &::client_trait::HttpClient, arg: &RelinquishFileMembershipArg) -> ::Result<Result<(), RelinquishFileMembershipError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/relinquish_file_membership", arg, None)
}

/// The current user relinquishes their membership in the designated shared folder and will no
/// longer have access to the folder.  A folder owner cannot relinquish membership in their own
/// folder. This will run synchronously if leave_a_copy is false, and asynchronously if leave_a_copy
/// is true. Apps must have full Dropbox access to use this endpoint.
pub fn relinquish_folder_membership(client: &::client_trait::HttpClient, arg: &RelinquishFolderMembershipArg) -> ::Result<Result<super::async::LaunchEmptyResult, RelinquishFolderMembershipError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/relinquish_folder_membership", arg, None)
}

/// Identical to remove_file_member_2 but with less information returned.
pub fn remove_file_member(client: &::client_trait::HttpClient, arg: &RemoveFileMemberArg) -> ::Result<Result<FileMemberActionIndividualResult, RemoveFileMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/remove_file_member", arg, None)
}

/// Removes a specified member from the file.
pub fn remove_file_member_2(client: &::client_trait::HttpClient, arg: &RemoveFileMemberArg) -> ::Result<Result<FileMemberRemoveActionResult, RemoveFileMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/remove_file_member_2", arg, None)
}

/// Allows an owner or editor (if the ACL update policy allows) of a shared folder to remove another
/// member. Apps must have full Dropbox access to use this endpoint.
pub fn remove_folder_member(client: &::client_trait::HttpClient, arg: &RemoveFolderMemberArg) -> ::Result<Result<super::async::LaunchResultBase, RemoveFolderMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/remove_folder_member", arg, None)
}

/// Revoke a shared link. Note that even after revoking a shared link to a file, the file may be
/// accessible if there are shared links leading to any of the file parent folders. To list all
/// shared links that enable access to a specific file, you can use the :route:`list_shared_links`
/// with the file as the :field:`ListSharedLinksArg.path` argument.
pub fn revoke_shared_link(client: &::client_trait::HttpClient, arg: &RevokeSharedLinkArg) -> ::Result<Result<(), RevokeSharedLinkError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/revoke_shared_link", arg, None)
}

/// Share a folder with collaborators. Most sharing will be completed synchronously. Large folders
/// will be completed asynchronously. To make testing the async case repeatable, set
/// `ShareFolderArg.force_async`. If a :field:`ShareFolderLaunch.async_job_id` is returned, you'll
/// need to call :route:`check_share_job_status` until the action completes to get the metadata for
/// the folder. Apps must have full Dropbox access to use this endpoint.
pub fn share_folder(client: &::client_trait::HttpClient, arg: &ShareFolderArg) -> ::Result<Result<ShareFolderLaunch, ShareFolderError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/share_folder", arg, None)
}

/// Transfer ownership of a shared folder to a member of the shared folder. User must have
/// :field:`AccessLevel.owner` access to the shared folder to perform a transfer. Apps must have
/// full Dropbox access to use this endpoint.
pub fn transfer_folder(client: &::client_trait::HttpClient, arg: &TransferFolderArg) -> ::Result<Result<(), TransferFolderError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/transfer_folder", arg, None)
}

/// The current user unmounts the designated folder. They can re-mount the folder at a later time
/// using :route:`mount_folder`. Apps must have full Dropbox access to use this endpoint.
pub fn unmount_folder(client: &::client_trait::HttpClient, arg: &UnmountFolderArg) -> ::Result<Result<(), UnmountFolderError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/unmount_folder", arg, None)
}

/// Remove all members from this file. Does not remove inherited members.
pub fn unshare_file(client: &::client_trait::HttpClient, arg: &UnshareFileArg) -> ::Result<Result<(), UnshareFileError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/unshare_file", arg, None)
}

/// Allows a shared folder owner to unshare the folder. You'll need to call
/// :route:`check_job_status` to determine if the action has completed successfully. Apps must have
/// full Dropbox access to use this endpoint.
pub fn unshare_folder(client: &::client_trait::HttpClient, arg: &UnshareFolderArg) -> ::Result<Result<super::async::LaunchEmptyResult, UnshareFolderError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/unshare_folder", arg, None)
}

/// Changes a member's access on a shared file.
pub fn update_file_member(client: &::client_trait::HttpClient, arg: &UpdateFileMemberArgs) -> ::Result<Result<MemberAccessLevelResult, FileMemberActionError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/update_file_member", arg, None)
}

/// Allows an owner or editor of a shared folder to update another member's permissions. Apps must
/// have full Dropbox access to use this endpoint.
pub fn update_folder_member(client: &::client_trait::HttpClient, arg: &UpdateFolderMemberArg) -> ::Result<Result<MemberAccessLevelResult, UpdateFolderMemberError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/update_folder_member", arg, None)
}

/// Update the sharing policies for a shared folder. User must have :field:`AccessLevel.owner`
/// access to the shared folder to update its policies. Apps must have full Dropbox access to use
/// this endpoint.
pub fn update_folder_policy(client: &::client_trait::HttpClient, arg: &UpdateFolderPolicyArg) -> ::Result<Result<SharedFolderMetadata, UpdateFolderPolicyError>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "sharing/update_folder_policy", arg, None)
}

/// Defines the access levels for collaborators.
#[derive(Debug)]
pub enum AccessLevel {
    /// The collaborator is the owner of the shared folder. Owners can view and edit the shared
    /// folder as well as set the folder's policies using :route:`update_folder_policy`.
    Owner,
    /// The collaborator can both view and edit the shared folder.
    Editor,
    /// The collaborator can only view the shared folder.
    Viewer,
    /// The collaborator can only view the shared folder and does not have any access to comments.
    ViewerNoComment,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccessLevel {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccessLevel;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AccessLevel structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "owner" => Ok(AccessLevel::Owner),
                    "editor" => Ok(AccessLevel::Editor),
                    "viewer" => Ok(AccessLevel::Viewer),
                    "viewer_no_comment" => Ok(AccessLevel::ViewerNoComment),
                    _ => Ok(AccessLevel::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["owner",
                                                    "editor",
                                                    "viewer",
                                                    "viewer_no_comment",
                                                    "other"];
        deserializer.deserialize_struct("AccessLevel", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccessLevel {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccessLevel::Owner => {
                // unit
                let mut s = serializer.serialize_struct("AccessLevel", 1)?;
                s.serialize_field(".tag", "owner")?;
                s.end()
            }
            AccessLevel::Editor => {
                // unit
                let mut s = serializer.serialize_struct("AccessLevel", 1)?;
                s.serialize_field(".tag", "editor")?;
                s.end()
            }
            AccessLevel::Viewer => {
                // unit
                let mut s = serializer.serialize_struct("AccessLevel", 1)?;
                s.serialize_field(".tag", "viewer")?;
                s.end()
            }
            AccessLevel::ViewerNoComment => {
                // unit
                let mut s = serializer.serialize_struct("AccessLevel", 1)?;
                s.serialize_field(".tag", "viewer_no_comment")?;
                s.end()
            }
            AccessLevel::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Who can change a shared folder's access control list (ACL). In other words, who can add, remove,
/// or change the privileges of members.
#[derive(Debug)]
pub enum AclUpdatePolicy {
    /// Only the owner can update the ACL.
    Owner,
    /// Any editor can update the ACL. This may be further restricted to editors on the same team.
    Editors,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AclUpdatePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AclUpdatePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AclUpdatePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "owner" => Ok(AclUpdatePolicy::Owner),
                    "editors" => Ok(AclUpdatePolicy::Editors),
                    _ => Ok(AclUpdatePolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["owner",
                                                    "editors",
                                                    "other"];
        deserializer.deserialize_struct("AclUpdatePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AclUpdatePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AclUpdatePolicy::Owner => {
                // unit
                let mut s = serializer.serialize_struct("AclUpdatePolicy", 1)?;
                s.serialize_field(".tag", "owner")?;
                s.end()
            }
            AclUpdatePolicy::Editors => {
                // unit
                let mut s = serializer.serialize_struct("AclUpdatePolicy", 1)?;
                s.serialize_field(".tag", "editors")?;
                s.end()
            }
            AclUpdatePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Arguments for :route:`add_file_member`.
#[derive(Debug)]
pub struct AddFileMemberArgs {
    /// File to which to add members.
    pub file: PathOrId,
    /// Members to add. Note that even an email address is given, this may result in a user being
    /// directy added to the membership if that email is the user's main account email.
    pub members: Vec<MemberSelector>,
    /// Message to send to added members in their invitation.
    pub custom_message: Option<String>,
    /// Whether added members should be notified via device notifications of their invitation.
    pub quiet: bool,
    /// AccessLevel union object, describing what access level we want to give new members.
    pub access_level: AccessLevel,
    /// If the custom message should be added as a comment on the file.
    pub add_message_as_comment: bool,
}

impl AddFileMemberArgs {
    pub fn new(file: PathOrId, members: Vec<MemberSelector>) -> Self {
        AddFileMemberArgs {
            file,
            members,
            custom_message: None,
            quiet: false,
            access_level: AccessLevel::Viewer,
            add_message_as_comment: false,
        }
    }

    pub fn with_custom_message(mut self, value: Option<String>) -> Self {
        self.custom_message = value;
        self
    }

    pub fn with_quiet(mut self, value: bool) -> Self {
        self.quiet = value;
        self
    }

    pub fn with_access_level(mut self, value: AccessLevel) -> Self {
        self.access_level = value;
        self
    }

    pub fn with_add_message_as_comment(mut self, value: bool) -> Self {
        self.add_message_as_comment = value;
        self
    }

}

const ADD_FILE_MEMBER_ARGS_FIELDS: &'static [&'static str] = &["file",
                                                               "members",
                                                               "custom_message",
                                                               "quiet",
                                                               "access_level",
                                                               "add_message_as_comment"];
impl AddFileMemberArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AddFileMemberArgs, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_members = None;
        let mut field_custom_message = None;
        let mut field_quiet = None;
        let mut field_access_level = None;
        let mut field_add_message_as_comment = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "custom_message" => {
                    if field_custom_message.is_some() {
                        return Err(de::Error::duplicate_field("custom_message"));
                    }
                    field_custom_message = Some(map.next_value()?);
                }
                "quiet" => {
                    if field_quiet.is_some() {
                        return Err(de::Error::duplicate_field("quiet"));
                    }
                    field_quiet = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "add_message_as_comment" => {
                    if field_add_message_as_comment.is_some() {
                        return Err(de::Error::duplicate_field("add_message_as_comment"));
                    }
                    field_add_message_as_comment = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ADD_FILE_MEMBER_ARGS_FIELDS))
            }
        }
        Ok(AddFileMemberArgs {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            custom_message: field_custom_message,
            quiet: field_quiet.unwrap_or(false),
            access_level: field_access_level.unwrap_or_else(|| AccessLevel::Viewer),
            add_message_as_comment: field_add_message_as_comment.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("custom_message", &self.custom_message)?;
        s.serialize_field("quiet", &self.quiet)?;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("add_message_as_comment", &self.add_message_as_comment)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AddFileMemberArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AddFileMemberArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddFileMemberArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AddFileMemberArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AddFileMemberArgs", ADD_FILE_MEMBER_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AddFileMemberArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AddFileMemberArgs", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors for :route:`add_file_member`.
#[derive(Debug)]
pub enum AddFileMemberError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    /// The user has reached the rate limit for invitations.
    RateLimit,
    /// The custom message did not pass comment permissions checks.
    InvalidComment,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AddFileMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AddFileMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddFileMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(AddFileMemberError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(AddFileMemberError::AccessError(map.next_value()?))
                    }
                    "rate_limit" => Ok(AddFileMemberError::RateLimit),
                    "invalid_comment" => Ok(AddFileMemberError::InvalidComment),
                    _ => Ok(AddFileMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "rate_limit",
                                                    "invalid_comment",
                                                    "other"];
        deserializer.deserialize_struct("AddFileMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AddFileMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AddFileMemberError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            AddFileMemberError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            AddFileMemberError::RateLimit => {
                // unit
                let mut s = serializer.serialize_struct("AddFileMemberError", 1)?;
                s.serialize_field(".tag", "rate_limit")?;
                s.end()
            }
            AddFileMemberError::InvalidComment => {
                // unit
                let mut s = serializer.serialize_struct("AddFileMemberError", 1)?;
                s.serialize_field(".tag", "invalid_comment")?;
                s.end()
            }
            AddFileMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for AddFileMemberError {
    fn description(&self) -> &str {
        "AddFileMemberError"
    }
}

impl ::std::fmt::Display for AddFileMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct AddFolderMemberArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// The intended list of members to add.  Added members will receive invites to join the shared
    /// folder.
    pub members: Vec<AddMember>,
    /// Whether added members should be notified via email and device notifications of their invite.
    pub quiet: bool,
    /// Optional message to display to added members in their invitation.
    pub custom_message: Option<String>,
}

impl AddFolderMemberArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId, members: Vec<AddMember>) -> Self {
        AddFolderMemberArg {
            shared_folder_id,
            members,
            quiet: false,
            custom_message: None,
        }
    }

    pub fn with_quiet(mut self, value: bool) -> Self {
        self.quiet = value;
        self
    }

    pub fn with_custom_message(mut self, value: Option<String>) -> Self {
        self.custom_message = value;
        self
    }

}

const ADD_FOLDER_MEMBER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                "members",
                                                                "quiet",
                                                                "custom_message"];
impl AddFolderMemberArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AddFolderMemberArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_members = None;
        let mut field_quiet = None;
        let mut field_custom_message = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "quiet" => {
                    if field_quiet.is_some() {
                        return Err(de::Error::duplicate_field("quiet"));
                    }
                    field_quiet = Some(map.next_value()?);
                }
                "custom_message" => {
                    if field_custom_message.is_some() {
                        return Err(de::Error::duplicate_field("custom_message"));
                    }
                    field_custom_message = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ADD_FOLDER_MEMBER_ARG_FIELDS))
            }
        }
        Ok(AddFolderMemberArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            quiet: field_quiet.unwrap_or(false),
            custom_message: field_custom_message,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("quiet", &self.quiet)?;
        s.serialize_field("custom_message", &self.custom_message)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AddFolderMemberArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AddFolderMemberArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddFolderMemberArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AddFolderMemberArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AddFolderMemberArg", ADD_FOLDER_MEMBER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AddFolderMemberArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AddFolderMemberArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AddFolderMemberError {
    /// Unable to access shared folder.
    AccessError(SharedFolderAccessError),
    /// The current user's e-mail address is unverified.
    EmailUnverified,
    /// :field:`AddFolderMemberArg.members` contains a bad invitation recipient.
    BadMember(AddMemberSelectorError),
    /// Your team policy does not allow sharing outside of the team.
    CantShareOutsideTeam,
    /// The value is the member limit that was reached.
    TooManyMembers(u64),
    /// The value is the pending invite limit that was reached.
    TooManyPendingInvites(u64),
    /// The current user has hit the limit of invites they can send per day. Try again in 24 hours.
    RateLimit,
    /// The current user is trying to share with too many people at once.
    TooManyInvitees,
    /// The current user's account doesn't support this action. An example of this is when adding a
    /// read-only member. This action can only be performed by users that have upgraded to a Pro or
    /// Business plan.
    InsufficientPlan,
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    /// The current user does not have permission to perform this action.
    NoPermission,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AddFolderMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AddFolderMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddFolderMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(AddFolderMemberError::AccessError(map.next_value()?))
                    }
                    "email_unverified" => Ok(AddFolderMemberError::EmailUnverified),
                    "bad_member" => {
                        if map.next_key()? != Some("bad_member") {
                            return Err(de::Error::missing_field("bad_member"));
                        }
                        Ok(AddFolderMemberError::BadMember(map.next_value()?))
                    }
                    "cant_share_outside_team" => Ok(AddFolderMemberError::CantShareOutsideTeam),
                    "too_many_members" => {
                        if map.next_key()? != Some("too_many_members") {
                            return Err(de::Error::missing_field("too_many_members"));
                        }
                        Ok(AddFolderMemberError::TooManyMembers(map.next_value()?))
                    }
                    "too_many_pending_invites" => {
                        if map.next_key()? != Some("too_many_pending_invites") {
                            return Err(de::Error::missing_field("too_many_pending_invites"));
                        }
                        Ok(AddFolderMemberError::TooManyPendingInvites(map.next_value()?))
                    }
                    "rate_limit" => Ok(AddFolderMemberError::RateLimit),
                    "too_many_invitees" => Ok(AddFolderMemberError::TooManyInvitees),
                    "insufficient_plan" => Ok(AddFolderMemberError::InsufficientPlan),
                    "team_folder" => Ok(AddFolderMemberError::TeamFolder),
                    "no_permission" => Ok(AddFolderMemberError::NoPermission),
                    _ => Ok(AddFolderMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "email_unverified",
                                                    "bad_member",
                                                    "cant_share_outside_team",
                                                    "too_many_members",
                                                    "too_many_pending_invites",
                                                    "rate_limit",
                                                    "too_many_invitees",
                                                    "insufficient_plan",
                                                    "team_folder",
                                                    "no_permission",
                                                    "other"];
        deserializer.deserialize_struct("AddFolderMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AddFolderMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AddFolderMemberError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            AddFolderMemberError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            AddFolderMemberError::BadMember(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "bad_member")?;
                s.serialize_field("bad_member", x)?;
                s.end()
            }
            AddFolderMemberError::CantShareOutsideTeam => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "cant_share_outside_team")?;
                s.end()
            }
            AddFolderMemberError::TooManyMembers(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "too_many_members")?;
                s.serialize_field("too_many_members", x)?;
                s.end()
            }
            AddFolderMemberError::TooManyPendingInvites(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "too_many_pending_invites")?;
                s.serialize_field("too_many_pending_invites", x)?;
                s.end()
            }
            AddFolderMemberError::RateLimit => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "rate_limit")?;
                s.end()
            }
            AddFolderMemberError::TooManyInvitees => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "too_many_invitees")?;
                s.end()
            }
            AddFolderMemberError::InsufficientPlan => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "insufficient_plan")?;
                s.end()
            }
            AddFolderMemberError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            AddFolderMemberError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AddFolderMemberError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AddFolderMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for AddFolderMemberError {
    fn description(&self) -> &str {
        "AddFolderMemberError"
    }
}

impl ::std::fmt::Display for AddFolderMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// The member and type of access the member should have when added to a shared folder.
#[derive(Debug)]
pub struct AddMember {
    /// The member to add to the shared folder.
    pub member: MemberSelector,
    /// The access level to grant :field:`member` to the shared folder.  :field:`AccessLevel.owner`
    /// is disallowed.
    pub access_level: AccessLevel,
}

impl AddMember {
    pub fn new(member: MemberSelector) -> Self {
        AddMember {
            member,
            access_level: AccessLevel::Viewer,
        }
    }

    pub fn with_access_level(mut self, value: AccessLevel) -> Self {
        self.access_level = value;
        self
    }

}

const ADD_MEMBER_FIELDS: &'static [&'static str] = &["member",
                                                     "access_level"];
impl AddMember {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AddMember, V::Error> {
        use serde::de;
        let mut field_member = None;
        let mut field_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ADD_MEMBER_FIELDS))
            }
        }
        Ok(AddMember {
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            access_level: field_access_level.unwrap_or_else(|| AccessLevel::Viewer),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("access_level", &self.access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AddMember {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AddMember;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddMember struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AddMember::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AddMember", ADD_MEMBER_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AddMember {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AddMember", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AddMemberSelectorError {
    /// Automatically created groups can only be added to team folders.
    AutomaticGroup,
    /// The value is the ID that could not be identified.
    InvalidDropboxId(DropboxId),
    /// The value is the e-email address that is malformed.
    InvalidEmail(super::common::EmailAddress),
    /// The value is the ID of the Dropbox user with an unverified e-mail address.  Invite
    /// unverified users by e-mail address instead of by their Dropbox ID.
    UnverifiedDropboxId(DropboxId),
    /// At least one of the specified groups in :field:`AddFolderMemberArg.members` is deleted.
    GroupDeleted,
    /// Sharing to a group that is not on the current user's team.
    GroupNotOnTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AddMemberSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AddMemberSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AddMemberSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "automatic_group" => Ok(AddMemberSelectorError::AutomaticGroup),
                    "invalid_dropbox_id" => {
                        if map.next_key()? != Some("invalid_dropbox_id") {
                            return Err(de::Error::missing_field("invalid_dropbox_id"));
                        }
                        Ok(AddMemberSelectorError::InvalidDropboxId(map.next_value()?))
                    }
                    "invalid_email" => {
                        if map.next_key()? != Some("invalid_email") {
                            return Err(de::Error::missing_field("invalid_email"));
                        }
                        Ok(AddMemberSelectorError::InvalidEmail(map.next_value()?))
                    }
                    "unverified_dropbox_id" => {
                        if map.next_key()? != Some("unverified_dropbox_id") {
                            return Err(de::Error::missing_field("unverified_dropbox_id"));
                        }
                        Ok(AddMemberSelectorError::UnverifiedDropboxId(map.next_value()?))
                    }
                    "group_deleted" => Ok(AddMemberSelectorError::GroupDeleted),
                    "group_not_on_team" => Ok(AddMemberSelectorError::GroupNotOnTeam),
                    _ => Ok(AddMemberSelectorError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["automatic_group",
                                                    "invalid_dropbox_id",
                                                    "invalid_email",
                                                    "unverified_dropbox_id",
                                                    "group_deleted",
                                                    "group_not_on_team",
                                                    "other"];
        deserializer.deserialize_struct("AddMemberSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AddMemberSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AddMemberSelectorError::AutomaticGroup => {
                // unit
                let mut s = serializer.serialize_struct("AddMemberSelectorError", 1)?;
                s.serialize_field(".tag", "automatic_group")?;
                s.end()
            }
            AddMemberSelectorError::InvalidDropboxId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "invalid_dropbox_id")?;
                s.serialize_field("invalid_dropbox_id", x)?;
                s.end()
            }
            AddMemberSelectorError::InvalidEmail(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "invalid_email")?;
                s.serialize_field("invalid_email", x)?;
                s.end()
            }
            AddMemberSelectorError::UnverifiedDropboxId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "unverified_dropbox_id")?;
                s.serialize_field("unverified_dropbox_id", x)?;
                s.end()
            }
            AddMemberSelectorError::GroupDeleted => {
                // unit
                let mut s = serializer.serialize_struct("AddMemberSelectorError", 1)?;
                s.serialize_field(".tag", "group_deleted")?;
                s.end()
            }
            AddMemberSelectorError::GroupNotOnTeam => {
                // unit
                let mut s = serializer.serialize_struct("AddMemberSelectorError", 1)?;
                s.serialize_field(".tag", "group_not_on_team")?;
                s.end()
            }
            AddMemberSelectorError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for AddMemberSelectorError {
    fn description(&self) -> &str {
        "AddMemberSelectorError"
    }
}

impl ::std::fmt::Display for AddMemberSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Information about the content that has a link audience different than that of this folder.
#[derive(Debug)]
pub struct AudienceExceptionContentInfo {
    /// The name of the content, which is either a file or a folder.
    pub name: String,
}

impl AudienceExceptionContentInfo {
    pub fn new(name: String) -> Self {
        AudienceExceptionContentInfo {
            name,
        }
    }

}

const AUDIENCE_EXCEPTION_CONTENT_INFO_FIELDS: &'static [&'static str] = &["name"];
impl AudienceExceptionContentInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AudienceExceptionContentInfo, V::Error> {
        use serde::de;
        let mut field_name = None;
        while let Some(key) = map.next_key()? {
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, AUDIENCE_EXCEPTION_CONTENT_INFO_FIELDS))
            }
        }
        Ok(AudienceExceptionContentInfo {
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AudienceExceptionContentInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AudienceExceptionContentInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AudienceExceptionContentInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AudienceExceptionContentInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AudienceExceptionContentInfo", AUDIENCE_EXCEPTION_CONTENT_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AudienceExceptionContentInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AudienceExceptionContentInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The total count and truncated list of information of content inside this folder that has a
/// different audience than the link on this folder. This is only returned for folders.
#[derive(Debug)]
pub struct AudienceExceptions {
    pub count: u32,
    /// A truncated list of some of the content that is an exception. The length of this list could
    /// be smaller than the count since it is only a sample but will not be empty as long as count
    /// is not 0.
    pub exceptions: Vec<AudienceExceptionContentInfo>,
}

impl AudienceExceptions {
    pub fn new(count: u32, exceptions: Vec<AudienceExceptionContentInfo>) -> Self {
        AudienceExceptions {
            count,
            exceptions,
        }
    }

}

const AUDIENCE_EXCEPTIONS_FIELDS: &'static [&'static str] = &["count",
                                                              "exceptions"];
impl AudienceExceptions {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AudienceExceptions, V::Error> {
        use serde::de;
        let mut field_count = None;
        let mut field_exceptions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "count" => {
                    if field_count.is_some() {
                        return Err(de::Error::duplicate_field("count"));
                    }
                    field_count = Some(map.next_value()?);
                }
                "exceptions" => {
                    if field_exceptions.is_some() {
                        return Err(de::Error::duplicate_field("exceptions"));
                    }
                    field_exceptions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, AUDIENCE_EXCEPTIONS_FIELDS))
            }
        }
        Ok(AudienceExceptions {
            count: field_count.ok_or_else(|| de::Error::missing_field("count"))?,
            exceptions: field_exceptions.ok_or_else(|| de::Error::missing_field("exceptions"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("count", &self.count)?;
        s.serialize_field("exceptions", &self.exceptions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AudienceExceptions {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AudienceExceptions;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AudienceExceptions struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AudienceExceptions::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AudienceExceptions", AUDIENCE_EXCEPTIONS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AudienceExceptions {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AudienceExceptions", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about the shared folder that prevents the link audience for this link from being
/// more restrictive.
#[derive(Debug)]
pub struct AudienceRestrictingSharedFolder {
    /// The ID of the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// The name of the shared folder.
    pub name: String,
    /// The link audience of the shared folder.
    pub audience: LinkAudience,
}

impl AudienceRestrictingSharedFolder {
    pub fn new(shared_folder_id: super::common::SharedFolderId, name: String, audience: LinkAudience) -> Self {
        AudienceRestrictingSharedFolder {
            shared_folder_id,
            name,
            audience,
        }
    }

}

const AUDIENCE_RESTRICTING_SHARED_FOLDER_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                             "name",
                                                                             "audience"];
impl AudienceRestrictingSharedFolder {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<AudienceRestrictingSharedFolder, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_name = None;
        let mut field_audience = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "audience" => {
                    if field_audience.is_some() {
                        return Err(de::Error::duplicate_field("audience"));
                    }
                    field_audience = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, AUDIENCE_RESTRICTING_SHARED_FOLDER_FIELDS))
            }
        }
        Ok(AudienceRestrictingSharedFolder {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            audience: field_audience.ok_or_else(|| de::Error::missing_field("audience"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("audience", &self.audience)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AudienceRestrictingSharedFolder {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AudienceRestrictingSharedFolder;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AudienceRestrictingSharedFolder struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AudienceRestrictingSharedFolder::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AudienceRestrictingSharedFolder", AUDIENCE_RESTRICTING_SHARED_FOLDER_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AudienceRestrictingSharedFolder {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AudienceRestrictingSharedFolder", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for :route:`change_file_member_access`.
#[derive(Debug)]
pub struct ChangeFileMemberAccessArgs {
    /// File for which we are changing a member's access.
    pub file: PathOrId,
    /// The member whose access we are changing.
    pub member: MemberSelector,
    /// The new access level for the member.
    pub access_level: AccessLevel,
}

impl ChangeFileMemberAccessArgs {
    pub fn new(file: PathOrId, member: MemberSelector, access_level: AccessLevel) -> Self {
        ChangeFileMemberAccessArgs {
            file,
            member,
            access_level,
        }
    }

}

const CHANGE_FILE_MEMBER_ACCESS_ARGS_FIELDS: &'static [&'static str] = &["file",
                                                                         "member",
                                                                         "access_level"];
impl ChangeFileMemberAccessArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ChangeFileMemberAccessArgs, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_member = None;
        let mut field_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CHANGE_FILE_MEMBER_ACCESS_ARGS_FIELDS))
            }
        }
        Ok(ChangeFileMemberAccessArgs {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            access_level: field_access_level.ok_or_else(|| de::Error::missing_field("access_level"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("access_level", &self.access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ChangeFileMemberAccessArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ChangeFileMemberAccessArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ChangeFileMemberAccessArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ChangeFileMemberAccessArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ChangeFileMemberAccessArgs", CHANGE_FILE_MEMBER_ACCESS_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ChangeFileMemberAccessArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ChangeFileMemberAccessArgs", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Metadata for a collection-based shared link.
#[derive(Debug)]
pub struct CollectionLinkMetadata {
    /// URL of the shared link.
    pub url: String,
    /// Who can access the link.
    pub visibility: Visibility,
    /// Expiration time, if set. By default the link won't expire.
    pub expires: Option<super::common::DropboxTimestamp>,
}

impl CollectionLinkMetadata {
    pub fn new(url: String, visibility: Visibility) -> Self {
        CollectionLinkMetadata {
            url,
            visibility,
            expires: None,
        }
    }

    pub fn with_expires(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expires = value;
        self
    }

}

const COLLECTION_LINK_METADATA_FIELDS: &'static [&'static str] = &["url",
                                                                   "visibility",
                                                                   "expires"];
impl CollectionLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<CollectionLinkMetadata, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_visibility = None;
        let mut field_expires = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "visibility" => {
                    if field_visibility.is_some() {
                        return Err(de::Error::duplicate_field("visibility"));
                    }
                    field_visibility = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, COLLECTION_LINK_METADATA_FIELDS))
            }
        }
        Ok(CollectionLinkMetadata {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            visibility: field_visibility.ok_or_else(|| de::Error::missing_field("visibility"))?,
            expires: field_expires,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("visibility", &self.visibility)?;
        s.serialize_field("expires", &self.expires)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CollectionLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionLinkMetadata", COLLECTION_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionLinkMetadata", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct CreateSharedLinkArg {
    /// The path to share.
    pub path: String,
    /// Whether to return a shortened URL.
    pub short_url: bool,
    /// If it's okay to share a path that does not yet exist, set this to either
    /// :field:`PendingUploadMode.file` or :field:`PendingUploadMode.folder` to indicate whether to
    /// assume it's a file or folder.
    pub pending_upload: Option<PendingUploadMode>,
}

impl CreateSharedLinkArg {
    pub fn new(path: String) -> Self {
        CreateSharedLinkArg {
            path,
            short_url: false,
            pending_upload: None,
        }
    }

    pub fn with_short_url(mut self, value: bool) -> Self {
        self.short_url = value;
        self
    }

    pub fn with_pending_upload(mut self, value: Option<PendingUploadMode>) -> Self {
        self.pending_upload = value;
        self
    }

}

const CREATE_SHARED_LINK_ARG_FIELDS: &'static [&'static str] = &["path",
                                                                 "short_url",
                                                                 "pending_upload"];
impl CreateSharedLinkArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<CreateSharedLinkArg, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_short_url = None;
        let mut field_pending_upload = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "short_url" => {
                    if field_short_url.is_some() {
                        return Err(de::Error::duplicate_field("short_url"));
                    }
                    field_short_url = Some(map.next_value()?);
                }
                "pending_upload" => {
                    if field_pending_upload.is_some() {
                        return Err(de::Error::duplicate_field("pending_upload"));
                    }
                    field_pending_upload = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CREATE_SHARED_LINK_ARG_FIELDS))
            }
        }
        Ok(CreateSharedLinkArg {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            short_url: field_short_url.unwrap_or(false),
            pending_upload: field_pending_upload,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("short_url", &self.short_url)?;
        s.serialize_field("pending_upload", &self.pending_upload)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateSharedLinkArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateSharedLinkArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateSharedLinkArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateSharedLinkArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateSharedLinkArg", CREATE_SHARED_LINK_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateSharedLinkArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateSharedLinkArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum CreateSharedLinkError {
    Path(super::files::LookupError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for CreateSharedLinkError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CreateSharedLinkError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateSharedLinkError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "path" => {
                        if map.next_key()? != Some("path") {
                            return Err(de::Error::missing_field("path"));
                        }
                        Ok(CreateSharedLinkError::Path(map.next_value()?))
                    }
                    _ => Ok(CreateSharedLinkError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["path",
                                                    "other"];
        deserializer.deserialize_struct("CreateSharedLinkError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CreateSharedLinkError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CreateSharedLinkError::Path(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "path")?;
                s.serialize_field("path", x)?;
                s.end()
            }
            CreateSharedLinkError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for CreateSharedLinkError {
    fn description(&self) -> &str {
        "CreateSharedLinkError"
    }
}

impl ::std::fmt::Display for CreateSharedLinkError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct CreateSharedLinkWithSettingsArg {
    /// The path to be shared by the shared link
    pub path: ReadPath,
    /// The requested settings for the newly created shared link
    pub settings: Option<SharedLinkSettings>,
}

impl CreateSharedLinkWithSettingsArg {
    pub fn new(path: ReadPath) -> Self {
        CreateSharedLinkWithSettingsArg {
            path,
            settings: None,
        }
    }

    pub fn with_settings(mut self, value: Option<SharedLinkSettings>) -> Self {
        self.settings = value;
        self
    }

}

const CREATE_SHARED_LINK_WITH_SETTINGS_ARG_FIELDS: &'static [&'static str] = &["path",
                                                                               "settings"];
impl CreateSharedLinkWithSettingsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<CreateSharedLinkWithSettingsArg, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_settings = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "settings" => {
                    if field_settings.is_some() {
                        return Err(de::Error::duplicate_field("settings"));
                    }
                    field_settings = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CREATE_SHARED_LINK_WITH_SETTINGS_ARG_FIELDS))
            }
        }
        Ok(CreateSharedLinkWithSettingsArg {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            settings: field_settings,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("settings", &self.settings)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateSharedLinkWithSettingsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateSharedLinkWithSettingsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateSharedLinkWithSettingsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateSharedLinkWithSettingsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateSharedLinkWithSettingsArg", CREATE_SHARED_LINK_WITH_SETTINGS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateSharedLinkWithSettingsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateSharedLinkWithSettingsArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum CreateSharedLinkWithSettingsError {
    Path(super::files::LookupError),
    /// User's email should be verified
    EmailNotVerified,
    /// The shared link already exists. You can call :route:`list_shared_links` to get the existing
    /// link.
    SharedLinkAlreadyExists,
    /// There is an error with the given settings
    SettingsError(SharedLinkSettingsError),
    /// Access to the requested path is forbidden
    AccessDenied,
}

impl<'de> ::serde::de::Deserialize<'de> for CreateSharedLinkWithSettingsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CreateSharedLinkWithSettingsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateSharedLinkWithSettingsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "path" => {
                        if map.next_key()? != Some("path") {
                            return Err(de::Error::missing_field("path"));
                        }
                        Ok(CreateSharedLinkWithSettingsError::Path(map.next_value()?))
                    }
                    "email_not_verified" => Ok(CreateSharedLinkWithSettingsError::EmailNotVerified),
                    "shared_link_already_exists" => Ok(CreateSharedLinkWithSettingsError::SharedLinkAlreadyExists),
                    "settings_error" => {
                        if map.next_key()? != Some("settings_error") {
                            return Err(de::Error::missing_field("settings_error"));
                        }
                        Ok(CreateSharedLinkWithSettingsError::SettingsError(map.next_value()?))
                    }
                    "access_denied" => Ok(CreateSharedLinkWithSettingsError::AccessDenied),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["path",
                                                    "email_not_verified",
                                                    "shared_link_already_exists",
                                                    "settings_error",
                                                    "access_denied"];
        deserializer.deserialize_struct("CreateSharedLinkWithSettingsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CreateSharedLinkWithSettingsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CreateSharedLinkWithSettingsError::Path(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "path")?;
                s.serialize_field("path", x)?;
                s.end()
            }
            CreateSharedLinkWithSettingsError::EmailNotVerified => {
                // unit
                let mut s = serializer.serialize_struct("CreateSharedLinkWithSettingsError", 1)?;
                s.serialize_field(".tag", "email_not_verified")?;
                s.end()
            }
            CreateSharedLinkWithSettingsError::SharedLinkAlreadyExists => {
                // unit
                let mut s = serializer.serialize_struct("CreateSharedLinkWithSettingsError", 1)?;
                s.serialize_field(".tag", "shared_link_already_exists")?;
                s.end()
            }
            CreateSharedLinkWithSettingsError::SettingsError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "settings_error")?;
                s.serialize_field("settings_error", x)?;
                s.end()
            }
            CreateSharedLinkWithSettingsError::AccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("CreateSharedLinkWithSettingsError", 1)?;
                s.serialize_field(".tag", "access_denied")?;
                s.end()
            }
        }
    }
}

impl ::std::error::Error for CreateSharedLinkWithSettingsError {
    fn description(&self) -> &str {
        "CreateSharedLinkWithSettingsError"
    }
}

impl ::std::fmt::Display for CreateSharedLinkWithSettingsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// The expected metadata of a shared link for a file or folder when a link is first created for the
/// content. Absent if the link already exists.
#[derive(Debug)]
pub struct ExpectedSharedContentLinkMetadata {
    /// The audience options that are available for the content. Some audience options may be
    /// unavailable. For example, team_only may be unavailable if the content is not owned by a user
    /// on a team. The 'default' audience option is always available if the user can modify link
    /// settings.
    pub audience_options: Vec<LinkAudience>,
    /// The current audience of the link.
    pub current_audience: LinkAudience,
    /// A list of permissions for actions you can perform on the link.
    pub link_permissions: Vec<LinkPermission>,
    /// Whether the link is protected by a password.
    pub password_protected: bool,
    /// The access level on the link for this file.
    pub access_level: Option<AccessLevel>,
    /// The shared folder that prevents the link audience for this link from being more restrictive.
    pub audience_restricting_shared_folder: Option<AudienceRestrictingSharedFolder>,
    /// Whether the link has an expiry set on it. A link with an expiry will have its  audience
    /// changed to members when the expiry is reached.
    pub expiry: Option<super::common::DropboxTimestamp>,
}

impl ExpectedSharedContentLinkMetadata {
    pub fn new(audience_options: Vec<LinkAudience>, current_audience: LinkAudience, link_permissions: Vec<LinkPermission>, password_protected: bool) -> Self {
        ExpectedSharedContentLinkMetadata {
            audience_options,
            current_audience,
            link_permissions,
            password_protected,
            access_level: None,
            audience_restricting_shared_folder: None,
            expiry: None,
        }
    }

    pub fn with_access_level(mut self, value: Option<AccessLevel>) -> Self {
        self.access_level = value;
        self
    }

    pub fn with_audience_restricting_shared_folder(mut self, value: Option<AudienceRestrictingSharedFolder>) -> Self {
        self.audience_restricting_shared_folder = value;
        self
    }

    pub fn with_expiry(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expiry = value;
        self
    }

}

const EXPECTED_SHARED_CONTENT_LINK_METADATA_FIELDS: &'static [&'static str] = &["audience_options",
                                                                                "current_audience",
                                                                                "link_permissions",
                                                                                "password_protected",
                                                                                "access_level",
                                                                                "audience_restricting_shared_folder",
                                                                                "expiry"];
impl ExpectedSharedContentLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ExpectedSharedContentLinkMetadata, V::Error> {
        use serde::de;
        let mut field_audience_options = None;
        let mut field_current_audience = None;
        let mut field_link_permissions = None;
        let mut field_password_protected = None;
        let mut field_access_level = None;
        let mut field_audience_restricting_shared_folder = None;
        let mut field_expiry = None;
        while let Some(key) = map.next_key()? {
            match key {
                "audience_options" => {
                    if field_audience_options.is_some() {
                        return Err(de::Error::duplicate_field("audience_options"));
                    }
                    field_audience_options = Some(map.next_value()?);
                }
                "current_audience" => {
                    if field_current_audience.is_some() {
                        return Err(de::Error::duplicate_field("current_audience"));
                    }
                    field_current_audience = Some(map.next_value()?);
                }
                "link_permissions" => {
                    if field_link_permissions.is_some() {
                        return Err(de::Error::duplicate_field("link_permissions"));
                    }
                    field_link_permissions = Some(map.next_value()?);
                }
                "password_protected" => {
                    if field_password_protected.is_some() {
                        return Err(de::Error::duplicate_field("password_protected"));
                    }
                    field_password_protected = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "audience_restricting_shared_folder" => {
                    if field_audience_restricting_shared_folder.is_some() {
                        return Err(de::Error::duplicate_field("audience_restricting_shared_folder"));
                    }
                    field_audience_restricting_shared_folder = Some(map.next_value()?);
                }
                "expiry" => {
                    if field_expiry.is_some() {
                        return Err(de::Error::duplicate_field("expiry"));
                    }
                    field_expiry = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXPECTED_SHARED_CONTENT_LINK_METADATA_FIELDS))
            }
        }
        Ok(ExpectedSharedContentLinkMetadata {
            audience_options: field_audience_options.ok_or_else(|| de::Error::missing_field("audience_options"))?,
            current_audience: field_current_audience.ok_or_else(|| de::Error::missing_field("current_audience"))?,
            link_permissions: field_link_permissions.ok_or_else(|| de::Error::missing_field("link_permissions"))?,
            password_protected: field_password_protected.ok_or_else(|| de::Error::missing_field("password_protected"))?,
            access_level: field_access_level,
            audience_restricting_shared_folder: field_audience_restricting_shared_folder,
            expiry: field_expiry,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("audience_options", &self.audience_options)?;
        s.serialize_field("current_audience", &self.current_audience)?;
        s.serialize_field("link_permissions", &self.link_permissions)?;
        s.serialize_field("password_protected", &self.password_protected)?;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("audience_restricting_shared_folder", &self.audience_restricting_shared_folder)?;
        s.serialize_field("expiry", &self.expiry)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExpectedSharedContentLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExpectedSharedContentLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExpectedSharedContentLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExpectedSharedContentLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExpectedSharedContentLinkMetadata", EXPECTED_SHARED_CONTENT_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExpectedSharedContentLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExpectedSharedContentLinkMetadata", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sharing actions that may be taken on files.
#[derive(Debug)]
pub enum FileAction {
    /// Disable viewer information on the file.
    DisableViewerInfo,
    /// Change or edit contents of the file.
    EditContents,
    /// Enable viewer information on the file.
    EnableViewerInfo,
    /// Add a member with view permissions.
    InviteViewer,
    /// Add a member with view permissions but no comment permissions.
    InviteViewerNoComment,
    /// Stop sharing this file.
    Unshare,
    /// Relinquish one's own membership to the file.
    RelinquishMembership,
    /// This action is deprecated. Use create_link instead.
    ShareLink,
    /// Create a shared link to the file.
    CreateLink,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disable_viewer_info" => Ok(FileAction::DisableViewerInfo),
                    "edit_contents" => Ok(FileAction::EditContents),
                    "enable_viewer_info" => Ok(FileAction::EnableViewerInfo),
                    "invite_viewer" => Ok(FileAction::InviteViewer),
                    "invite_viewer_no_comment" => Ok(FileAction::InviteViewerNoComment),
                    "unshare" => Ok(FileAction::Unshare),
                    "relinquish_membership" => Ok(FileAction::RelinquishMembership),
                    "share_link" => Ok(FileAction::ShareLink),
                    "create_link" => Ok(FileAction::CreateLink),
                    _ => Ok(FileAction::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["disable_viewer_info",
                                                    "edit_contents",
                                                    "enable_viewer_info",
                                                    "invite_viewer",
                                                    "invite_viewer_no_comment",
                                                    "unshare",
                                                    "relinquish_membership",
                                                    "share_link",
                                                    "create_link",
                                                    "other"];
        deserializer.deserialize_struct("FileAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileAction::DisableViewerInfo => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "disable_viewer_info")?;
                s.end()
            }
            FileAction::EditContents => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "edit_contents")?;
                s.end()
            }
            FileAction::EnableViewerInfo => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "enable_viewer_info")?;
                s.end()
            }
            FileAction::InviteViewer => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "invite_viewer")?;
                s.end()
            }
            FileAction::InviteViewerNoComment => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "invite_viewer_no_comment")?;
                s.end()
            }
            FileAction::Unshare => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "unshare")?;
                s.end()
            }
            FileAction::RelinquishMembership => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "relinquish_membership")?;
                s.end()
            }
            FileAction::ShareLink => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "share_link")?;
                s.end()
            }
            FileAction::CreateLink => {
                // unit
                let mut s = serializer.serialize_struct("FileAction", 1)?;
                s.serialize_field(".tag", "create_link")?;
                s.end()
            }
            FileAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum FileErrorResult {
    /// File specified by id was not found.
    FileNotFoundError(super::files::Id),
    /// User does not have permission to take the specified action on the file.
    InvalidFileActionError(super::files::Id),
    /// User does not have permission to access file specified by file.Id.
    PermissionDeniedError(super::files::Id),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileErrorResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileErrorResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileErrorResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file_not_found_error" => {
                        if map.next_key()? != Some("file_not_found_error") {
                            return Err(de::Error::missing_field("file_not_found_error"));
                        }
                        Ok(FileErrorResult::FileNotFoundError(map.next_value()?))
                    }
                    "invalid_file_action_error" => {
                        if map.next_key()? != Some("invalid_file_action_error") {
                            return Err(de::Error::missing_field("invalid_file_action_error"));
                        }
                        Ok(FileErrorResult::InvalidFileActionError(map.next_value()?))
                    }
                    "permission_denied_error" => {
                        if map.next_key()? != Some("permission_denied_error") {
                            return Err(de::Error::missing_field("permission_denied_error"));
                        }
                        Ok(FileErrorResult::PermissionDeniedError(map.next_value()?))
                    }
                    _ => Ok(FileErrorResult::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["file_not_found_error",
                                                    "invalid_file_action_error",
                                                    "permission_denied_error",
                                                    "other"];
        deserializer.deserialize_struct("FileErrorResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileErrorResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileErrorResult::FileNotFoundError(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "file_not_found_error")?;
                s.serialize_field("file_not_found_error", x)?;
                s.end()
            }
            FileErrorResult::InvalidFileActionError(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "invalid_file_action_error")?;
                s.serialize_field("invalid_file_action_error", x)?;
                s.end()
            }
            FileErrorResult::PermissionDeniedError(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "permission_denied_error")?;
                s.serialize_field("permission_denied_error", x)?;
                s.end()
            }
            FileErrorResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The metadata of a file shared link
#[derive(Debug)]
pub struct FileLinkMetadata {
    /// URL of the shared link.
    pub url: String,
    /// The linked file name (including extension). This never contains a slash.
    pub name: String,
    /// The link's access permissions.
    pub link_permissions: LinkPermissions,
    /// The modification time set by the desktop client when the file was added to Dropbox. Since
    /// this time is not verified (the Dropbox server stores whatever the desktop client sends up),
    /// this should only be used for display purposes (such as sorting) and not, for example, to
    /// determine if a file has changed or not.
    pub client_modified: super::common::DropboxTimestamp,
    /// The last time the file was modified on Dropbox.
    pub server_modified: super::common::DropboxTimestamp,
    /// A unique identifier for the current revision of a file. This field is the same rev as
    /// elsewhere in the API and can be used to detect changes and avoid conflicts.
    pub rev: Rev,
    /// The file size in bytes.
    pub size: u64,
    /// A unique identifier for the linked file.
    pub id: Option<Id>,
    /// Expiration time, if set. By default the link won't expire.
    pub expires: Option<super::common::DropboxTimestamp>,
    /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field
    /// will only be present only if the linked file is in the authenticated user's  dropbox.
    pub path_lower: Option<String>,
    /// The team membership information of the link's owner.  This field will only be present  if
    /// the link's owner is a team member.
    pub team_member_info: Option<TeamMemberInfo>,
    /// The team information of the content's owner. This field will only be present if the
    /// content's owner is a team member and the content's owner team is different from the link's
    /// owner team.
    pub content_owner_team_info: Option<TeamInfo>,
}

impl FileLinkMetadata {
    pub fn new(url: String, name: String, link_permissions: LinkPermissions, client_modified: super::common::DropboxTimestamp, server_modified: super::common::DropboxTimestamp, rev: Rev, size: u64) -> Self {
        FileLinkMetadata {
            url,
            name,
            link_permissions,
            client_modified,
            server_modified,
            rev,
            size,
            id: None,
            expires: None,
            path_lower: None,
            team_member_info: None,
            content_owner_team_info: None,
        }
    }

    pub fn with_id(mut self, value: Option<Id>) -> Self {
        self.id = value;
        self
    }

    pub fn with_expires(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expires = value;
        self
    }

    pub fn with_path_lower(mut self, value: Option<String>) -> Self {
        self.path_lower = value;
        self
    }

    pub fn with_team_member_info(mut self, value: Option<TeamMemberInfo>) -> Self {
        self.team_member_info = value;
        self
    }

    pub fn with_content_owner_team_info(mut self, value: Option<TeamInfo>) -> Self {
        self.content_owner_team_info = value;
        self
    }

}

const FILE_LINK_METADATA_FIELDS: &'static [&'static str] = &["url",
                                                             "name",
                                                             "link_permissions",
                                                             "client_modified",
                                                             "server_modified",
                                                             "rev",
                                                             "size",
                                                             "id",
                                                             "expires",
                                                             "path_lower",
                                                             "team_member_info",
                                                             "content_owner_team_info"];
impl FileLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileLinkMetadata, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_name = None;
        let mut field_link_permissions = None;
        let mut field_client_modified = None;
        let mut field_server_modified = None;
        let mut field_rev = None;
        let mut field_size = None;
        let mut field_id = None;
        let mut field_expires = None;
        let mut field_path_lower = None;
        let mut field_team_member_info = None;
        let mut field_content_owner_team_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "link_permissions" => {
                    if field_link_permissions.is_some() {
                        return Err(de::Error::duplicate_field("link_permissions"));
                    }
                    field_link_permissions = Some(map.next_value()?);
                }
                "client_modified" => {
                    if field_client_modified.is_some() {
                        return Err(de::Error::duplicate_field("client_modified"));
                    }
                    field_client_modified = Some(map.next_value()?);
                }
                "server_modified" => {
                    if field_server_modified.is_some() {
                        return Err(de::Error::duplicate_field("server_modified"));
                    }
                    field_server_modified = Some(map.next_value()?);
                }
                "rev" => {
                    if field_rev.is_some() {
                        return Err(de::Error::duplicate_field("rev"));
                    }
                    field_rev = Some(map.next_value()?);
                }
                "size" => {
                    if field_size.is_some() {
                        return Err(de::Error::duplicate_field("size"));
                    }
                    field_size = Some(map.next_value()?);
                }
                "id" => {
                    if field_id.is_some() {
                        return Err(de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                "path_lower" => {
                    if field_path_lower.is_some() {
                        return Err(de::Error::duplicate_field("path_lower"));
                    }
                    field_path_lower = Some(map.next_value()?);
                }
                "team_member_info" => {
                    if field_team_member_info.is_some() {
                        return Err(de::Error::duplicate_field("team_member_info"));
                    }
                    field_team_member_info = Some(map.next_value()?);
                }
                "content_owner_team_info" => {
                    if field_content_owner_team_info.is_some() {
                        return Err(de::Error::duplicate_field("content_owner_team_info"));
                    }
                    field_content_owner_team_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_LINK_METADATA_FIELDS))
            }
        }
        Ok(FileLinkMetadata {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            link_permissions: field_link_permissions.ok_or_else(|| de::Error::missing_field("link_permissions"))?,
            client_modified: field_client_modified.ok_or_else(|| de::Error::missing_field("client_modified"))?,
            server_modified: field_server_modified.ok_or_else(|| de::Error::missing_field("server_modified"))?,
            rev: field_rev.ok_or_else(|| de::Error::missing_field("rev"))?,
            size: field_size.ok_or_else(|| de::Error::missing_field("size"))?,
            id: field_id,
            expires: field_expires,
            path_lower: field_path_lower,
            team_member_info: field_team_member_info,
            content_owner_team_info: field_content_owner_team_info,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("link_permissions", &self.link_permissions)?;
        s.serialize_field("client_modified", &self.client_modified)?;
        s.serialize_field("server_modified", &self.server_modified)?;
        s.serialize_field("rev", &self.rev)?;
        s.serialize_field("size", &self.size)?;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("expires", &self.expires)?;
        s.serialize_field("path_lower", &self.path_lower)?;
        s.serialize_field("team_member_info", &self.team_member_info)?;
        s.serialize_field("content_owner_team_info", &self.content_owner_team_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLinkMetadata", FILE_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLinkMetadata", 12)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum FileMemberActionError {
    /// Specified member was not found.
    InvalidMember,
    /// User does not have permission to perform this action on this member.
    NoPermission,
    /// Specified file was invalid or user does not have access.
    AccessError(SharingFileAccessError),
    /// The action cannot be completed because the target member does not have explicit access to
    /// the file. The return value is the access that the member has to the file from a parent
    /// folder.
    NoExplicitAccess(MemberAccessLevelResult),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileMemberActionError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileMemberActionError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMemberActionError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_member" => Ok(FileMemberActionError::InvalidMember),
                    "no_permission" => Ok(FileMemberActionError::NoPermission),
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(FileMemberActionError::AccessError(map.next_value()?))
                    }
                    "no_explicit_access" => Ok(FileMemberActionError::NoExplicitAccess(MemberAccessLevelResult::internal_deserialize(map)?)),
                    _ => Ok(FileMemberActionError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["invalid_member",
                                                    "no_permission",
                                                    "access_error",
                                                    "no_explicit_access",
                                                    "other"];
        deserializer.deserialize_struct("FileMemberActionError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileMemberActionError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileMemberActionError::InvalidMember => {
                // unit
                let mut s = serializer.serialize_struct("FileMemberActionError", 1)?;
                s.serialize_field(".tag", "invalid_member")?;
                s.end()
            }
            FileMemberActionError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("FileMemberActionError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            FileMemberActionError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            FileMemberActionError::NoExplicitAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FileMemberActionError", 4)?;
                s.serialize_field(".tag", "no_explicit_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FileMemberActionError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for FileMemberActionError {
    fn description(&self) -> &str {
        "FileMemberActionError"
    }
}

impl ::std::fmt::Display for FileMemberActionError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum FileMemberActionIndividualResult {
    /// Member was successfully removed from this file. If AccessLevel is given, the member still
    /// has access via a parent shared folder.
    Success(Option<AccessLevel>),
    /// User was not able to perform this action.
    MemberError(FileMemberActionError),
}

impl<'de> ::serde::de::Deserialize<'de> for FileMemberActionIndividualResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileMemberActionIndividualResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMemberActionIndividualResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => {
                        if map.next_key()? != Some("success") {
                            return Err(de::Error::missing_field("success"));
                        }
                        Ok(FileMemberActionIndividualResult::Success(map.next_value()?))
                    }
                    "member_error" => {
                        if map.next_key()? != Some("member_error") {
                            return Err(de::Error::missing_field("member_error"));
                        }
                        Ok(FileMemberActionIndividualResult::MemberError(map.next_value()?))
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["success",
                                                    "member_error"];
        deserializer.deserialize_struct("FileMemberActionIndividualResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileMemberActionIndividualResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileMemberActionIndividualResult::Success(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "success")?;
                s.serialize_field("success", x)?;
                s.end()
            }
            FileMemberActionIndividualResult::MemberError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "member_error")?;
                s.serialize_field("member_error", x)?;
                s.end()
            }
        }
    }
}

/// Per-member result for :route:`add_file_member` or :route:`change_file_member_access`.
#[derive(Debug)]
pub struct FileMemberActionResult {
    /// One of specified input members.
    pub member: MemberSelector,
    /// The outcome of the action on this member.
    pub result: FileMemberActionIndividualResult,
}

impl FileMemberActionResult {
    pub fn new(member: MemberSelector, result: FileMemberActionIndividualResult) -> Self {
        FileMemberActionResult {
            member,
            result,
        }
    }

}

const FILE_MEMBER_ACTION_RESULT_FIELDS: &'static [&'static str] = &["member",
                                                                    "result"];
impl FileMemberActionResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FileMemberActionResult, V::Error> {
        use serde::de;
        let mut field_member = None;
        let mut field_result = None;
        while let Some(key) = map.next_key()? {
            match key {
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "result" => {
                    if field_result.is_some() {
                        return Err(de::Error::duplicate_field("result"));
                    }
                    field_result = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_MEMBER_ACTION_RESULT_FIELDS))
            }
        }
        Ok(FileMemberActionResult {
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            result: field_result.ok_or_else(|| de::Error::missing_field("result"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("result", &self.result)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMemberActionResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMemberActionResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMemberActionResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMemberActionResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMemberActionResult", FILE_MEMBER_ACTION_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMemberActionResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMemberActionResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum FileMemberRemoveActionResult {
    /// Member was successfully removed from this file.
    Success(MemberAccessLevelResult),
    /// User was not able to remove this member.
    MemberError(FileMemberActionError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileMemberRemoveActionResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileMemberRemoveActionResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileMemberRemoveActionResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => Ok(FileMemberRemoveActionResult::Success(MemberAccessLevelResult::internal_deserialize(map)?)),
                    "member_error" => {
                        if map.next_key()? != Some("member_error") {
                            return Err(de::Error::missing_field("member_error"));
                        }
                        Ok(FileMemberRemoveActionResult::MemberError(map.next_value()?))
                    }
                    _ => Ok(FileMemberRemoveActionResult::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["success",
                                                    "member_error",
                                                    "other"];
        deserializer.deserialize_struct("FileMemberRemoveActionResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileMemberRemoveActionResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileMemberRemoveActionResult::Success(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FileMemberRemoveActionResult", 4)?;
                s.serialize_field(".tag", "success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FileMemberRemoveActionResult::MemberError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "member_error")?;
                s.serialize_field("member_error", x)?;
                s.end()
            }
            FileMemberRemoveActionResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Whether the user is allowed to take the sharing action on the file.
#[derive(Debug)]
pub struct FilePermission {
    /// The action that the user may wish to take on the file.
    pub action: FileAction,
    /// True if the user is allowed to take the action.
    pub allow: bool,
    /// The reason why the user is denied the permission. Not present if the action is allowed.
    pub reason: Option<PermissionDeniedReason>,
}

impl FilePermission {
    pub fn new(action: FileAction, allow: bool) -> Self {
        FilePermission {
            action,
            allow,
            reason: None,
        }
    }

    pub fn with_reason(mut self, value: Option<PermissionDeniedReason>) -> Self {
        self.reason = value;
        self
    }

}

const FILE_PERMISSION_FIELDS: &'static [&'static str] = &["action",
                                                          "allow",
                                                          "reason"];
impl FilePermission {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FilePermission, V::Error> {
        use serde::de;
        let mut field_action = None;
        let mut field_allow = None;
        let mut field_reason = None;
        while let Some(key) = map.next_key()? {
            match key {
                "action" => {
                    if field_action.is_some() {
                        return Err(de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                "allow" => {
                    if field_allow.is_some() {
                        return Err(de::Error::duplicate_field("allow"));
                    }
                    field_allow = Some(map.next_value()?);
                }
                "reason" => {
                    if field_reason.is_some() {
                        return Err(de::Error::duplicate_field("reason"));
                    }
                    field_reason = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FILE_PERMISSION_FIELDS))
            }
        }
        Ok(FilePermission {
            action: field_action.ok_or_else(|| de::Error::missing_field("action"))?,
            allow: field_allow.ok_or_else(|| de::Error::missing_field("allow"))?,
            reason: field_reason,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("action", &self.action)?;
        s.serialize_field("allow", &self.allow)?;
        s.serialize_field("reason", &self.reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermission {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermission;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FilePermission struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermission::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermission", FILE_PERMISSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermission {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FilePermission", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Actions that may be taken on shared folders.
#[derive(Debug)]
pub enum FolderAction {
    /// Change folder options, such as who can be invited to join the folder.
    ChangeOptions,
    /// Disable viewer information for this folder.
    DisableViewerInfo,
    /// Change or edit contents of the folder.
    EditContents,
    /// Enable viewer information on the folder.
    EnableViewerInfo,
    /// Invite a user or group to join the folder with read and write permission.
    InviteEditor,
    /// Invite a user or group to join the folder with read permission.
    InviteViewer,
    /// Invite a user or group to join the folder with read permission but no comment permissions.
    InviteViewerNoComment,
    /// Relinquish one's own membership in the folder.
    RelinquishMembership,
    /// Unmount the folder.
    Unmount,
    /// Stop sharing this folder.
    Unshare,
    /// Keep a copy of the contents upon leaving or being kicked from the folder.
    LeaveACopy,
    /// This action is deprecated. Use create_link instead.
    ShareLink,
    /// Create a shared link for folder.
    CreateLink,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FolderAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FolderAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "change_options" => Ok(FolderAction::ChangeOptions),
                    "disable_viewer_info" => Ok(FolderAction::DisableViewerInfo),
                    "edit_contents" => Ok(FolderAction::EditContents),
                    "enable_viewer_info" => Ok(FolderAction::EnableViewerInfo),
                    "invite_editor" => Ok(FolderAction::InviteEditor),
                    "invite_viewer" => Ok(FolderAction::InviteViewer),
                    "invite_viewer_no_comment" => Ok(FolderAction::InviteViewerNoComment),
                    "relinquish_membership" => Ok(FolderAction::RelinquishMembership),
                    "unmount" => Ok(FolderAction::Unmount),
                    "unshare" => Ok(FolderAction::Unshare),
                    "leave_a_copy" => Ok(FolderAction::LeaveACopy),
                    "share_link" => Ok(FolderAction::ShareLink),
                    "create_link" => Ok(FolderAction::CreateLink),
                    _ => Ok(FolderAction::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["change_options",
                                                    "disable_viewer_info",
                                                    "edit_contents",
                                                    "enable_viewer_info",
                                                    "invite_editor",
                                                    "invite_viewer",
                                                    "invite_viewer_no_comment",
                                                    "relinquish_membership",
                                                    "unmount",
                                                    "unshare",
                                                    "leave_a_copy",
                                                    "share_link",
                                                    "create_link",
                                                    "other"];
        deserializer.deserialize_struct("FolderAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FolderAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FolderAction::ChangeOptions => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "change_options")?;
                s.end()
            }
            FolderAction::DisableViewerInfo => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "disable_viewer_info")?;
                s.end()
            }
            FolderAction::EditContents => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "edit_contents")?;
                s.end()
            }
            FolderAction::EnableViewerInfo => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "enable_viewer_info")?;
                s.end()
            }
            FolderAction::InviteEditor => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "invite_editor")?;
                s.end()
            }
            FolderAction::InviteViewer => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "invite_viewer")?;
                s.end()
            }
            FolderAction::InviteViewerNoComment => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "invite_viewer_no_comment")?;
                s.end()
            }
            FolderAction::RelinquishMembership => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "relinquish_membership")?;
                s.end()
            }
            FolderAction::Unmount => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "unmount")?;
                s.end()
            }
            FolderAction::Unshare => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "unshare")?;
                s.end()
            }
            FolderAction::LeaveACopy => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "leave_a_copy")?;
                s.end()
            }
            FolderAction::ShareLink => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "share_link")?;
                s.end()
            }
            FolderAction::CreateLink => {
                // unit
                let mut s = serializer.serialize_struct("FolderAction", 1)?;
                s.serialize_field(".tag", "create_link")?;
                s.end()
            }
            FolderAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The metadata of a folder shared link
#[derive(Debug)]
pub struct FolderLinkMetadata {
    /// URL of the shared link.
    pub url: String,
    /// The linked file name (including extension). This never contains a slash.
    pub name: String,
    /// The link's access permissions.
    pub link_permissions: LinkPermissions,
    /// A unique identifier for the linked file.
    pub id: Option<Id>,
    /// Expiration time, if set. By default the link won't expire.
    pub expires: Option<super::common::DropboxTimestamp>,
    /// The lowercased full path in the user's Dropbox. This always starts with a slash. This field
    /// will only be present only if the linked file is in the authenticated user's  dropbox.
    pub path_lower: Option<String>,
    /// The team membership information of the link's owner.  This field will only be present  if
    /// the link's owner is a team member.
    pub team_member_info: Option<TeamMemberInfo>,
    /// The team information of the content's owner. This field will only be present if the
    /// content's owner is a team member and the content's owner team is different from the link's
    /// owner team.
    pub content_owner_team_info: Option<TeamInfo>,
}

impl FolderLinkMetadata {
    pub fn new(url: String, name: String, link_permissions: LinkPermissions) -> Self {
        FolderLinkMetadata {
            url,
            name,
            link_permissions,
            id: None,
            expires: None,
            path_lower: None,
            team_member_info: None,
            content_owner_team_info: None,
        }
    }

    pub fn with_id(mut self, value: Option<Id>) -> Self {
        self.id = value;
        self
    }

    pub fn with_expires(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expires = value;
        self
    }

    pub fn with_path_lower(mut self, value: Option<String>) -> Self {
        self.path_lower = value;
        self
    }

    pub fn with_team_member_info(mut self, value: Option<TeamMemberInfo>) -> Self {
        self.team_member_info = value;
        self
    }

    pub fn with_content_owner_team_info(mut self, value: Option<TeamInfo>) -> Self {
        self.content_owner_team_info = value;
        self
    }

}

const FOLDER_LINK_METADATA_FIELDS: &'static [&'static str] = &["url",
                                                               "name",
                                                               "link_permissions",
                                                               "id",
                                                               "expires",
                                                               "path_lower",
                                                               "team_member_info",
                                                               "content_owner_team_info"];
impl FolderLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FolderLinkMetadata, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_name = None;
        let mut field_link_permissions = None;
        let mut field_id = None;
        let mut field_expires = None;
        let mut field_path_lower = None;
        let mut field_team_member_info = None;
        let mut field_content_owner_team_info = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "link_permissions" => {
                    if field_link_permissions.is_some() {
                        return Err(de::Error::duplicate_field("link_permissions"));
                    }
                    field_link_permissions = Some(map.next_value()?);
                }
                "id" => {
                    if field_id.is_some() {
                        return Err(de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                "path_lower" => {
                    if field_path_lower.is_some() {
                        return Err(de::Error::duplicate_field("path_lower"));
                    }
                    field_path_lower = Some(map.next_value()?);
                }
                "team_member_info" => {
                    if field_team_member_info.is_some() {
                        return Err(de::Error::duplicate_field("team_member_info"));
                    }
                    field_team_member_info = Some(map.next_value()?);
                }
                "content_owner_team_info" => {
                    if field_content_owner_team_info.is_some() {
                        return Err(de::Error::duplicate_field("content_owner_team_info"));
                    }
                    field_content_owner_team_info = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FOLDER_LINK_METADATA_FIELDS))
            }
        }
        Ok(FolderLinkMetadata {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            link_permissions: field_link_permissions.ok_or_else(|| de::Error::missing_field("link_permissions"))?,
            id: field_id,
            expires: field_expires,
            path_lower: field_path_lower,
            team_member_info: field_team_member_info,
            content_owner_team_info: field_content_owner_team_info,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("link_permissions", &self.link_permissions)?;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("expires", &self.expires)?;
        s.serialize_field("path_lower", &self.path_lower)?;
        s.serialize_field("team_member_info", &self.team_member_info)?;
        s.serialize_field("content_owner_team_info", &self.content_owner_team_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderLinkMetadata", FOLDER_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderLinkMetadata", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Whether the user is allowed to take the action on the shared folder.
#[derive(Debug)]
pub struct FolderPermission {
    /// The action that the user may wish to take on the folder.
    pub action: FolderAction,
    /// True if the user is allowed to take the action.
    pub allow: bool,
    /// The reason why the user is denied the permission. Not present if the action is allowed, or
    /// if no reason is available.
    pub reason: Option<PermissionDeniedReason>,
}

impl FolderPermission {
    pub fn new(action: FolderAction, allow: bool) -> Self {
        FolderPermission {
            action,
            allow,
            reason: None,
        }
    }

    pub fn with_reason(mut self, value: Option<PermissionDeniedReason>) -> Self {
        self.reason = value;
        self
    }

}

const FOLDER_PERMISSION_FIELDS: &'static [&'static str] = &["action",
                                                            "allow",
                                                            "reason"];
impl FolderPermission {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FolderPermission, V::Error> {
        use serde::de;
        let mut field_action = None;
        let mut field_allow = None;
        let mut field_reason = None;
        while let Some(key) = map.next_key()? {
            match key {
                "action" => {
                    if field_action.is_some() {
                        return Err(de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                "allow" => {
                    if field_allow.is_some() {
                        return Err(de::Error::duplicate_field("allow"));
                    }
                    field_allow = Some(map.next_value()?);
                }
                "reason" => {
                    if field_reason.is_some() {
                        return Err(de::Error::duplicate_field("reason"));
                    }
                    field_reason = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FOLDER_PERMISSION_FIELDS))
            }
        }
        Ok(FolderPermission {
            action: field_action.ok_or_else(|| de::Error::missing_field("action"))?,
            allow: field_allow.ok_or_else(|| de::Error::missing_field("allow"))?,
            reason: field_reason,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("action", &self.action)?;
        s.serialize_field("allow", &self.allow)?;
        s.serialize_field("reason", &self.reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderPermission {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderPermission;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderPermission struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderPermission::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderPermission", FOLDER_PERMISSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderPermission {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderPermission", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// A set of policies governing membership and privileges for a shared folder.
#[derive(Debug)]
pub struct FolderPolicy {
    /// Who can add and remove members from this shared folder.
    pub acl_update_policy: AclUpdatePolicy,
    /// Who links can be shared with.
    pub shared_link_policy: SharedLinkPolicy,
    /// Who can be a member of this shared folder, as set on the folder itself. The effective policy
    /// may differ from this value if the team-wide policy is more restrictive. Present only if the
    /// folder is owned by a team.
    pub member_policy: Option<MemberPolicy>,
    /// Who can be a member of this shared folder, taking into account both the folder and the
    /// team-wide policy. This value may differ from that of member_policy if the team-wide policy
    /// is more restrictive than the folder policy. Present only if the folder is owned by a team.
    pub resolved_member_policy: Option<MemberPolicy>,
    /// Who can enable/disable viewer info for this shared folder.
    pub viewer_info_policy: Option<ViewerInfoPolicy>,
}

impl FolderPolicy {
    pub fn new(acl_update_policy: AclUpdatePolicy, shared_link_policy: SharedLinkPolicy) -> Self {
        FolderPolicy {
            acl_update_policy,
            shared_link_policy,
            member_policy: None,
            resolved_member_policy: None,
            viewer_info_policy: None,
        }
    }

    pub fn with_member_policy(mut self, value: Option<MemberPolicy>) -> Self {
        self.member_policy = value;
        self
    }

    pub fn with_resolved_member_policy(mut self, value: Option<MemberPolicy>) -> Self {
        self.resolved_member_policy = value;
        self
    }

    pub fn with_viewer_info_policy(mut self, value: Option<ViewerInfoPolicy>) -> Self {
        self.viewer_info_policy = value;
        self
    }

}

const FOLDER_POLICY_FIELDS: &'static [&'static str] = &["acl_update_policy",
                                                        "shared_link_policy",
                                                        "member_policy",
                                                        "resolved_member_policy",
                                                        "viewer_info_policy"];
impl FolderPolicy {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<FolderPolicy, V::Error> {
        use serde::de;
        let mut field_acl_update_policy = None;
        let mut field_shared_link_policy = None;
        let mut field_member_policy = None;
        let mut field_resolved_member_policy = None;
        let mut field_viewer_info_policy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "acl_update_policy" => {
                    if field_acl_update_policy.is_some() {
                        return Err(de::Error::duplicate_field("acl_update_policy"));
                    }
                    field_acl_update_policy = Some(map.next_value()?);
                }
                "shared_link_policy" => {
                    if field_shared_link_policy.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_policy"));
                    }
                    field_shared_link_policy = Some(map.next_value()?);
                }
                "member_policy" => {
                    if field_member_policy.is_some() {
                        return Err(de::Error::duplicate_field("member_policy"));
                    }
                    field_member_policy = Some(map.next_value()?);
                }
                "resolved_member_policy" => {
                    if field_resolved_member_policy.is_some() {
                        return Err(de::Error::duplicate_field("resolved_member_policy"));
                    }
                    field_resolved_member_policy = Some(map.next_value()?);
                }
                "viewer_info_policy" => {
                    if field_viewer_info_policy.is_some() {
                        return Err(de::Error::duplicate_field("viewer_info_policy"));
                    }
                    field_viewer_info_policy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FOLDER_POLICY_FIELDS))
            }
        }
        Ok(FolderPolicy {
            acl_update_policy: field_acl_update_policy.ok_or_else(|| de::Error::missing_field("acl_update_policy"))?,
            shared_link_policy: field_shared_link_policy.ok_or_else(|| de::Error::missing_field("shared_link_policy"))?,
            member_policy: field_member_policy,
            resolved_member_policy: field_resolved_member_policy,
            viewer_info_policy: field_viewer_info_policy,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("acl_update_policy", &self.acl_update_policy)?;
        s.serialize_field("shared_link_policy", &self.shared_link_policy)?;
        s.serialize_field("member_policy", &self.member_policy)?;
        s.serialize_field("resolved_member_policy", &self.resolved_member_policy)?;
        s.serialize_field("viewer_info_policy", &self.viewer_info_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FolderPolicy struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderPolicy::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderPolicy", FOLDER_POLICY_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderPolicy", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments of :route:`get_file_metadata`.
#[derive(Debug)]
pub struct GetFileMetadataArg {
    /// The file to query.
    pub file: PathOrId,
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's :field:`SharedFileMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the file.
    pub actions: Option<Vec<FileAction>>,
}

impl GetFileMetadataArg {
    pub fn new(file: PathOrId) -> Self {
        GetFileMetadataArg {
            file,
            actions: None,
        }
    }

    pub fn with_actions(mut self, value: Option<Vec<FileAction>>) -> Self {
        self.actions = value;
        self
    }

}

const GET_FILE_METADATA_ARG_FIELDS: &'static [&'static str] = &["file",
                                                                "actions"];
impl GetFileMetadataArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetFileMetadataArg, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_FILE_METADATA_ARG_FIELDS))
            }
        }
        Ok(GetFileMetadataArg {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileMetadataArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetFileMetadataArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileMetadataArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetFileMetadataArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetFileMetadataArg", GET_FILE_METADATA_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileMetadataArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetFileMetadataArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments of :route:`get_file_metadata/batch`.
#[derive(Debug)]
pub struct GetFileMetadataBatchArg {
    /// The files to query.
    pub files: Vec<PathOrId>,
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's :field:`SharedFileMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the file.
    pub actions: Option<Vec<FileAction>>,
}

impl GetFileMetadataBatchArg {
    pub fn new(files: Vec<PathOrId>) -> Self {
        GetFileMetadataBatchArg {
            files,
            actions: None,
        }
    }

    pub fn with_actions(mut self, value: Option<Vec<FileAction>>) -> Self {
        self.actions = value;
        self
    }

}

const GET_FILE_METADATA_BATCH_ARG_FIELDS: &'static [&'static str] = &["files",
                                                                      "actions"];
impl GetFileMetadataBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetFileMetadataBatchArg, V::Error> {
        use serde::de;
        let mut field_files = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "files" => {
                    if field_files.is_some() {
                        return Err(de::Error::duplicate_field("files"));
                    }
                    field_files = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_FILE_METADATA_BATCH_ARG_FIELDS))
            }
        }
        Ok(GetFileMetadataBatchArg {
            files: field_files.ok_or_else(|| de::Error::missing_field("files"))?,
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("files", &self.files)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileMetadataBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetFileMetadataBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileMetadataBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetFileMetadataBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetFileMetadataBatchArg", GET_FILE_METADATA_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileMetadataBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetFileMetadataBatchArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Per file results of :route:`get_file_metadata/batch`.
#[derive(Debug)]
pub struct GetFileMetadataBatchResult {
    /// This is the input file identifier corresponding to one of
    /// :field:`GetFileMetadataBatchArg.files`.
    pub file: PathOrId,
    /// The result for this particular file.
    pub result: GetFileMetadataIndividualResult,
}

impl GetFileMetadataBatchResult {
    pub fn new(file: PathOrId, result: GetFileMetadataIndividualResult) -> Self {
        GetFileMetadataBatchResult {
            file,
            result,
        }
    }

}

const GET_FILE_METADATA_BATCH_RESULT_FIELDS: &'static [&'static str] = &["file",
                                                                         "result"];
impl GetFileMetadataBatchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetFileMetadataBatchResult, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_result = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "result" => {
                    if field_result.is_some() {
                        return Err(de::Error::duplicate_field("result"));
                    }
                    field_result = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_FILE_METADATA_BATCH_RESULT_FIELDS))
            }
        }
        Ok(GetFileMetadataBatchResult {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            result: field_result.ok_or_else(|| de::Error::missing_field("result"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("result", &self.result)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileMetadataBatchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetFileMetadataBatchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileMetadataBatchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetFileMetadataBatchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetFileMetadataBatchResult", GET_FILE_METADATA_BATCH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileMetadataBatchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetFileMetadataBatchResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error result for :route:`get_file_metadata`.
#[derive(Debug)]
pub enum GetFileMetadataError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileMetadataError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetFileMetadataError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileMetadataError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(GetFileMetadataError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(GetFileMetadataError::AccessError(map.next_value()?))
                    }
                    _ => Ok(GetFileMetadataError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "other"];
        deserializer.deserialize_struct("GetFileMetadataError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileMetadataError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetFileMetadataError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            GetFileMetadataError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            GetFileMetadataError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetFileMetadataError {
    fn description(&self) -> &str {
        "GetFileMetadataError"
    }
}

impl ::std::fmt::Display for GetFileMetadataError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GetFileMetadataIndividualResult {
    /// The result for this file if it was successful.
    Metadata(SharedFileMetadata),
    /// The result for this file if it was an error.
    AccessError(SharingFileAccessError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileMetadataIndividualResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetFileMetadataIndividualResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileMetadataIndividualResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "metadata" => Ok(GetFileMetadataIndividualResult::Metadata(SharedFileMetadata::internal_deserialize(map)?)),
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(GetFileMetadataIndividualResult::AccessError(map.next_value()?))
                    }
                    _ => Ok(GetFileMetadataIndividualResult::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["metadata",
                                                    "access_error",
                                                    "other"];
        deserializer.deserialize_struct("GetFileMetadataIndividualResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileMetadataIndividualResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetFileMetadataIndividualResult::Metadata(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("GetFileMetadataIndividualResult", 15)?;
                s.serialize_field(".tag", "metadata")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            GetFileMetadataIndividualResult::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            GetFileMetadataIndividualResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct GetMetadataArgs {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's :field:`SharedFolderMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the folder.
    pub actions: Option<Vec<FolderAction>>,
}

impl GetMetadataArgs {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        GetMetadataArgs {
            shared_folder_id,
            actions: None,
        }
    }

    pub fn with_actions(mut self, value: Option<Vec<FolderAction>>) -> Self {
        self.actions = value;
        self
    }

}

const GET_METADATA_ARGS_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                            "actions"];
impl GetMetadataArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetMetadataArgs, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_METADATA_ARGS_FIELDS))
            }
        }
        Ok(GetMetadataArgs {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetMetadataArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetMetadataArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetMetadataArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetMetadataArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetMetadataArgs", GET_METADATA_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetMetadataArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetMetadataArgs", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GetSharedLinkFileError {
    /// The shared link wasn't found.
    SharedLinkNotFound,
    /// The caller is not allowed to access this shared link.
    SharedLinkAccessDenied,
    /// This type of link is not supported.
    UnsupportedLinkType,
    Other,
    /// Directories cannot be retrieved by this endpoint.
    SharedLinkIsDirectory,
}

impl<'de> ::serde::de::Deserialize<'de> for GetSharedLinkFileError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetSharedLinkFileError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetSharedLinkFileError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "shared_link_not_found" => Ok(GetSharedLinkFileError::SharedLinkNotFound),
                    "shared_link_access_denied" => Ok(GetSharedLinkFileError::SharedLinkAccessDenied),
                    "unsupported_link_type" => Ok(GetSharedLinkFileError::UnsupportedLinkType),
                    "shared_link_is_directory" => Ok(GetSharedLinkFileError::SharedLinkIsDirectory),
                    _ => Ok(GetSharedLinkFileError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["shared_link_not_found",
                                                    "shared_link_access_denied",
                                                    "unsupported_link_type",
                                                    "other",
                                                    "shared_link_is_directory"];
        deserializer.deserialize_struct("GetSharedLinkFileError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetSharedLinkFileError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetSharedLinkFileError::SharedLinkNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GetSharedLinkFileError", 1)?;
                s.serialize_field(".tag", "shared_link_not_found")?;
                s.end()
            }
            GetSharedLinkFileError::SharedLinkAccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("GetSharedLinkFileError", 1)?;
                s.serialize_field(".tag", "shared_link_access_denied")?;
                s.end()
            }
            GetSharedLinkFileError::UnsupportedLinkType => {
                // unit
                let mut s = serializer.serialize_struct("GetSharedLinkFileError", 1)?;
                s.serialize_field(".tag", "unsupported_link_type")?;
                s.end()
            }
            GetSharedLinkFileError::SharedLinkIsDirectory => {
                // unit
                let mut s = serializer.serialize_struct("GetSharedLinkFileError", 1)?;
                s.serialize_field(".tag", "shared_link_is_directory")?;
                s.end()
            }
            GetSharedLinkFileError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetSharedLinkFileError {
    fn description(&self) -> &str {
        "GetSharedLinkFileError"
    }
}

impl ::std::fmt::Display for GetSharedLinkFileError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GetSharedLinkMetadataArg {
    /// URL of the shared link.
    pub url: String,
    /// If the shared link is to a folder, this parameter can be used to retrieve the metadata for a
    /// specific file or sub-folder in this folder. A relative path should be used.
    pub path: Option<Path>,
    /// If the shared link has a password, this parameter can be used.
    pub link_password: Option<String>,
}

impl GetSharedLinkMetadataArg {
    pub fn new(url: String) -> Self {
        GetSharedLinkMetadataArg {
            url,
            path: None,
            link_password: None,
        }
    }

    pub fn with_path(mut self, value: Option<Path>) -> Self {
        self.path = value;
        self
    }

    pub fn with_link_password(mut self, value: Option<String>) -> Self {
        self.link_password = value;
        self
    }

}

const GET_SHARED_LINK_METADATA_ARG_FIELDS: &'static [&'static str] = &["url",
                                                                       "path",
                                                                       "link_password"];
impl GetSharedLinkMetadataArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetSharedLinkMetadataArg, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_path = None;
        let mut field_link_password = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "link_password" => {
                    if field_link_password.is_some() {
                        return Err(de::Error::duplicate_field("link_password"));
                    }
                    field_link_password = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_SHARED_LINK_METADATA_ARG_FIELDS))
            }
        }
        Ok(GetSharedLinkMetadataArg {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            path: field_path,
            link_password: field_link_password,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("link_password", &self.link_password)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetSharedLinkMetadataArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetSharedLinkMetadataArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetSharedLinkMetadataArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetSharedLinkMetadataArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetSharedLinkMetadataArg", GET_SHARED_LINK_METADATA_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetSharedLinkMetadataArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetSharedLinkMetadataArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetSharedLinksArg {
    /// See :route:`get_shared_links` description.
    pub path: Option<String>,
}

impl Default for GetSharedLinksArg {
    fn default() -> Self {
        GetSharedLinksArg {
            path: None,
        }
    }
}

const GET_SHARED_LINKS_ARG_FIELDS: &'static [&'static str] = &["path"];
impl GetSharedLinksArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetSharedLinksArg, V::Error> {
        use serde::de;
        let mut field_path = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_SHARED_LINKS_ARG_FIELDS))
            }
        }
        Ok(GetSharedLinksArg {
            path: field_path,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetSharedLinksArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetSharedLinksArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetSharedLinksArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetSharedLinksArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetSharedLinksArg", GET_SHARED_LINKS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetSharedLinksArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetSharedLinksArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GetSharedLinksError {
    Path(super::files::MalformedPathError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetSharedLinksError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetSharedLinksError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetSharedLinksError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "path" => {
                        if map.next_key()? != Some("path") {
                            return Err(de::Error::missing_field("path"));
                        }
                        Ok(GetSharedLinksError::Path(map.next_value()?))
                    }
                    _ => Ok(GetSharedLinksError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["path",
                                                    "other"];
        deserializer.deserialize_struct("GetSharedLinksError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetSharedLinksError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetSharedLinksError::Path(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "path")?;
                s.serialize_field("path", x)?;
                s.end()
            }
            GetSharedLinksError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetSharedLinksError {
    fn description(&self) -> &str {
        "GetSharedLinksError"
    }
}

impl ::std::fmt::Display for GetSharedLinksError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GetSharedLinksResult {
    /// Shared links applicable to the path argument.
    pub links: Vec<LinkMetadata>,
}

impl GetSharedLinksResult {
    pub fn new(links: Vec<LinkMetadata>) -> Self {
        GetSharedLinksResult {
            links,
        }
    }

}

const GET_SHARED_LINKS_RESULT_FIELDS: &'static [&'static str] = &["links"];
impl GetSharedLinksResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GetSharedLinksResult, V::Error> {
        use serde::de;
        let mut field_links = None;
        while let Some(key) = map.next_key()? {
            match key {
                "links" => {
                    if field_links.is_some() {
                        return Err(de::Error::duplicate_field("links"));
                    }
                    field_links = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_SHARED_LINKS_RESULT_FIELDS))
            }
        }
        Ok(GetSharedLinksResult {
            links: field_links.ok_or_else(|| de::Error::missing_field("links"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("links", &self.links)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetSharedLinksResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetSharedLinksResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetSharedLinksResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetSharedLinksResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetSharedLinksResult", GET_SHARED_LINKS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetSharedLinksResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetSharedLinksResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The information about a group. Groups is a way to manage a list of users  who need same access
/// permission to the shared folder.
#[derive(Debug)]
pub struct GroupInfo {
    pub group_name: String,
    pub group_id: super::team_common::GroupId,
    /// Who is allowed to manage the group.
    pub group_management_type: super::team_common::GroupManagementType,
    /// The type of group.
    pub group_type: super::team_common::GroupType,
    /// If the current user is a member of the group.
    pub is_member: bool,
    /// If the current user is an owner of the group.
    pub is_owner: bool,
    /// If the group is owned by the current user's team.
    pub same_team: bool,
    /// External ID of group. This is an arbitrary ID that an admin can attach to a group.
    pub group_external_id: Option<super::team_common::GroupExternalId>,
    /// The number of members in the group.
    pub member_count: Option<u32>,
}

impl GroupInfo {
    pub fn new(group_name: String, group_id: super::team_common::GroupId, group_management_type: super::team_common::GroupManagementType, group_type: super::team_common::GroupType, is_member: bool, is_owner: bool, same_team: bool) -> Self {
        GroupInfo {
            group_name,
            group_id,
            group_management_type,
            group_type,
            is_member,
            is_owner,
            same_team,
            group_external_id: None,
            member_count: None,
        }
    }

    pub fn with_group_external_id(mut self, value: Option<super::team_common::GroupExternalId>) -> Self {
        self.group_external_id = value;
        self
    }

    pub fn with_member_count(mut self, value: Option<u32>) -> Self {
        self.member_count = value;
        self
    }

}

const GROUP_INFO_FIELDS: &'static [&'static str] = &["group_name",
                                                     "group_id",
                                                     "group_management_type",
                                                     "group_type",
                                                     "is_member",
                                                     "is_owner",
                                                     "same_team",
                                                     "group_external_id",
                                                     "member_count"];
impl GroupInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupInfo, V::Error> {
        use serde::de;
        let mut field_group_name = None;
        let mut field_group_id = None;
        let mut field_group_management_type = None;
        let mut field_group_type = None;
        let mut field_is_member = None;
        let mut field_is_owner = None;
        let mut field_same_team = None;
        let mut field_group_external_id = None;
        let mut field_member_count = None;
        while let Some(key) = map.next_key()? {
            match key {
                "group_name" => {
                    if field_group_name.is_some() {
                        return Err(de::Error::duplicate_field("group_name"));
                    }
                    field_group_name = Some(map.next_value()?);
                }
                "group_id" => {
                    if field_group_id.is_some() {
                        return Err(de::Error::duplicate_field("group_id"));
                    }
                    field_group_id = Some(map.next_value()?);
                }
                "group_management_type" => {
                    if field_group_management_type.is_some() {
                        return Err(de::Error::duplicate_field("group_management_type"));
                    }
                    field_group_management_type = Some(map.next_value()?);
                }
                "group_type" => {
                    if field_group_type.is_some() {
                        return Err(de::Error::duplicate_field("group_type"));
                    }
                    field_group_type = Some(map.next_value()?);
                }
                "is_member" => {
                    if field_is_member.is_some() {
                        return Err(de::Error::duplicate_field("is_member"));
                    }
                    field_is_member = Some(map.next_value()?);
                }
                "is_owner" => {
                    if field_is_owner.is_some() {
                        return Err(de::Error::duplicate_field("is_owner"));
                    }
                    field_is_owner = Some(map.next_value()?);
                }
                "same_team" => {
                    if field_same_team.is_some() {
                        return Err(de::Error::duplicate_field("same_team"));
                    }
                    field_same_team = Some(map.next_value()?);
                }
                "group_external_id" => {
                    if field_group_external_id.is_some() {
                        return Err(de::Error::duplicate_field("group_external_id"));
                    }
                    field_group_external_id = Some(map.next_value()?);
                }
                "member_count" => {
                    if field_member_count.is_some() {
                        return Err(de::Error::duplicate_field("member_count"));
                    }
                    field_member_count = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_INFO_FIELDS))
            }
        }
        Ok(GroupInfo {
            group_name: field_group_name.ok_or_else(|| de::Error::missing_field("group_name"))?,
            group_id: field_group_id.ok_or_else(|| de::Error::missing_field("group_id"))?,
            group_management_type: field_group_management_type.ok_or_else(|| de::Error::missing_field("group_management_type"))?,
            group_type: field_group_type.ok_or_else(|| de::Error::missing_field("group_type"))?,
            is_member: field_is_member.ok_or_else(|| de::Error::missing_field("is_member"))?,
            is_owner: field_is_owner.ok_or_else(|| de::Error::missing_field("is_owner"))?,
            same_team: field_same_team.ok_or_else(|| de::Error::missing_field("same_team"))?,
            group_external_id: field_group_external_id,
            member_count: field_member_count,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group_name", &self.group_name)?;
        s.serialize_field("group_id", &self.group_id)?;
        s.serialize_field("group_management_type", &self.group_management_type)?;
        s.serialize_field("group_type", &self.group_type)?;
        s.serialize_field("is_member", &self.is_member)?;
        s.serialize_field("is_owner", &self.is_owner)?;
        s.serialize_field("same_team", &self.same_team)?;
        s.serialize_field("group_external_id", &self.group_external_id)?;
        s.serialize_field("member_count", &self.member_count)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupInfo", GROUP_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupInfo", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The information about a group member of the shared content.
#[derive(Debug)]
pub struct GroupMembershipInfo {
    /// The access type for this member.
    pub access_type: AccessLevel,
    /// The information about the membership group.
    pub group: GroupInfo,
    /// The permissions that requesting user has on this member. The set of permissions corresponds
    /// to the MemberActions in the request.
    pub permissions: Option<Vec<MemberPermission>>,
    /// Suggested name initials for a member.
    pub initials: Option<String>,
    /// True if the member has access from a parent folder.
    pub is_inherited: bool,
}

impl GroupMembershipInfo {
    pub fn new(access_type: AccessLevel, group: GroupInfo) -> Self {
        GroupMembershipInfo {
            access_type,
            group,
            permissions: None,
            initials: None,
            is_inherited: false,
        }
    }

    pub fn with_permissions(mut self, value: Option<Vec<MemberPermission>>) -> Self {
        self.permissions = value;
        self
    }

    pub fn with_initials(mut self, value: Option<String>) -> Self {
        self.initials = value;
        self
    }

    pub fn with_is_inherited(mut self, value: bool) -> Self {
        self.is_inherited = value;
        self
    }

}

const GROUP_MEMBERSHIP_INFO_FIELDS: &'static [&'static str] = &["access_type",
                                                                "group",
                                                                "permissions",
                                                                "initials",
                                                                "is_inherited"];
impl GroupMembershipInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<GroupMembershipInfo, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_group = None;
        let mut field_permissions = None;
        let mut field_initials = None;
        let mut field_is_inherited = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "initials" => {
                    if field_initials.is_some() {
                        return Err(de::Error::duplicate_field("initials"));
                    }
                    field_initials = Some(map.next_value()?);
                }
                "is_inherited" => {
                    if field_is_inherited.is_some() {
                        return Err(de::Error::duplicate_field("is_inherited"));
                    }
                    field_is_inherited = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERSHIP_INFO_FIELDS))
            }
        }
        Ok(GroupMembershipInfo {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            permissions: field_permissions,
            initials: field_initials,
            is_inherited: field_is_inherited.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("initials", &self.initials)?;
        s.serialize_field("is_inherited", &self.is_inherited)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembershipInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembershipInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembershipInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembershipInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembershipInfo", GROUP_MEMBERSHIP_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembershipInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembershipInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct InsufficientPlan {
    /// A message to tell the user to upgrade in order to support expected action.
    pub message: String,
    /// A URL to send the user to in order to obtain the account type they need, e.g. upgrading.
    /// Absent if there is no action the user can take to upgrade.
    pub upsell_url: Option<String>,
}

impl InsufficientPlan {
    pub fn new(message: String) -> Self {
        InsufficientPlan {
            message,
            upsell_url: None,
        }
    }

    pub fn with_upsell_url(mut self, value: Option<String>) -> Self {
        self.upsell_url = value;
        self
    }

}

const INSUFFICIENT_PLAN_FIELDS: &'static [&'static str] = &["message",
                                                            "upsell_url"];
impl InsufficientPlan {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<InsufficientPlan, V::Error> {
        use serde::de;
        let mut field_message = None;
        let mut field_upsell_url = None;
        while let Some(key) = map.next_key()? {
            match key {
                "message" => {
                    if field_message.is_some() {
                        return Err(de::Error::duplicate_field("message"));
                    }
                    field_message = Some(map.next_value()?);
                }
                "upsell_url" => {
                    if field_upsell_url.is_some() {
                        return Err(de::Error::duplicate_field("upsell_url"));
                    }
                    field_upsell_url = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, INSUFFICIENT_PLAN_FIELDS))
            }
        }
        Ok(InsufficientPlan {
            message: field_message.ok_or_else(|| de::Error::missing_field("message"))?,
            upsell_url: field_upsell_url,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("message", &self.message)?;
        s.serialize_field("upsell_url", &self.upsell_url)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for InsufficientPlan {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = InsufficientPlan;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a InsufficientPlan struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                InsufficientPlan::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("InsufficientPlan", INSUFFICIENT_PLAN_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for InsufficientPlan {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("InsufficientPlan", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct InsufficientQuotaAmounts {
    /// The amount of space needed to add the item (the size of the item).
    pub space_needed: u64,
    /// The amount of extra space needed to add the item.
    pub space_shortage: u64,
    /// The amount of space left in the user's Dropbox, less than space_needed.
    pub space_left: u64,
}

impl InsufficientQuotaAmounts {
    pub fn new(space_needed: u64, space_shortage: u64, space_left: u64) -> Self {
        InsufficientQuotaAmounts {
            space_needed,
            space_shortage,
            space_left,
        }
    }

}

const INSUFFICIENT_QUOTA_AMOUNTS_FIELDS: &'static [&'static str] = &["space_needed",
                                                                     "space_shortage",
                                                                     "space_left"];
impl InsufficientQuotaAmounts {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<InsufficientQuotaAmounts, V::Error> {
        use serde::de;
        let mut field_space_needed = None;
        let mut field_space_shortage = None;
        let mut field_space_left = None;
        while let Some(key) = map.next_key()? {
            match key {
                "space_needed" => {
                    if field_space_needed.is_some() {
                        return Err(de::Error::duplicate_field("space_needed"));
                    }
                    field_space_needed = Some(map.next_value()?);
                }
                "space_shortage" => {
                    if field_space_shortage.is_some() {
                        return Err(de::Error::duplicate_field("space_shortage"));
                    }
                    field_space_shortage = Some(map.next_value()?);
                }
                "space_left" => {
                    if field_space_left.is_some() {
                        return Err(de::Error::duplicate_field("space_left"));
                    }
                    field_space_left = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, INSUFFICIENT_QUOTA_AMOUNTS_FIELDS))
            }
        }
        Ok(InsufficientQuotaAmounts {
            space_needed: field_space_needed.ok_or_else(|| de::Error::missing_field("space_needed"))?,
            space_shortage: field_space_shortage.ok_or_else(|| de::Error::missing_field("space_shortage"))?,
            space_left: field_space_left.ok_or_else(|| de::Error::missing_field("space_left"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("space_needed", &self.space_needed)?;
        s.serialize_field("space_shortage", &self.space_shortage)?;
        s.serialize_field("space_left", &self.space_left)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for InsufficientQuotaAmounts {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = InsufficientQuotaAmounts;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a InsufficientQuotaAmounts struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                InsufficientQuotaAmounts::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("InsufficientQuotaAmounts", INSUFFICIENT_QUOTA_AMOUNTS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for InsufficientQuotaAmounts {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("InsufficientQuotaAmounts", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about the recipient of a shared content invitation.
#[derive(Debug)]
pub enum InviteeInfo {
    /// E-mail address of invited user.
    Email(super::common::EmailAddress),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for InviteeInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = InviteeInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a InviteeInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email" => {
                        if map.next_key()? != Some("email") {
                            return Err(de::Error::missing_field("email"));
                        }
                        Ok(InviteeInfo::Email(map.next_value()?))
                    }
                    _ => Ok(InviteeInfo::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["email",
                                                    "other"];
        deserializer.deserialize_struct("InviteeInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for InviteeInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            InviteeInfo::Email(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "email")?;
                s.serialize_field("email", x)?;
                s.end()
            }
            InviteeInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Information about an invited member of a shared content.
#[derive(Debug)]
pub struct InviteeMembershipInfo {
    /// The access type for this member.
    pub access_type: AccessLevel,
    /// Recipient of the invitation.
    pub invitee: InviteeInfo,
    /// The permissions that requesting user has on this member. The set of permissions corresponds
    /// to the MemberActions in the request.
    pub permissions: Option<Vec<MemberPermission>>,
    /// Suggested name initials for a member.
    pub initials: Option<String>,
    /// True if the member has access from a parent folder.
    pub is_inherited: bool,
    /// The user this invitation is tied to, if available.
    pub user: Option<UserInfo>,
}

impl InviteeMembershipInfo {
    pub fn new(access_type: AccessLevel, invitee: InviteeInfo) -> Self {
        InviteeMembershipInfo {
            access_type,
            invitee,
            permissions: None,
            initials: None,
            is_inherited: false,
            user: None,
        }
    }

    pub fn with_permissions(mut self, value: Option<Vec<MemberPermission>>) -> Self {
        self.permissions = value;
        self
    }

    pub fn with_initials(mut self, value: Option<String>) -> Self {
        self.initials = value;
        self
    }

    pub fn with_is_inherited(mut self, value: bool) -> Self {
        self.is_inherited = value;
        self
    }

    pub fn with_user(mut self, value: Option<UserInfo>) -> Self {
        self.user = value;
        self
    }

}

const INVITEE_MEMBERSHIP_INFO_FIELDS: &'static [&'static str] = &["access_type",
                                                                  "invitee",
                                                                  "permissions",
                                                                  "initials",
                                                                  "is_inherited",
                                                                  "user"];
impl InviteeMembershipInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<InviteeMembershipInfo, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_invitee = None;
        let mut field_permissions = None;
        let mut field_initials = None;
        let mut field_is_inherited = None;
        let mut field_user = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "invitee" => {
                    if field_invitee.is_some() {
                        return Err(de::Error::duplicate_field("invitee"));
                    }
                    field_invitee = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "initials" => {
                    if field_initials.is_some() {
                        return Err(de::Error::duplicate_field("initials"));
                    }
                    field_initials = Some(map.next_value()?);
                }
                "is_inherited" => {
                    if field_is_inherited.is_some() {
                        return Err(de::Error::duplicate_field("is_inherited"));
                    }
                    field_is_inherited = Some(map.next_value()?);
                }
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, INVITEE_MEMBERSHIP_INFO_FIELDS))
            }
        }
        Ok(InviteeMembershipInfo {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            invitee: field_invitee.ok_or_else(|| de::Error::missing_field("invitee"))?,
            permissions: field_permissions,
            initials: field_initials,
            is_inherited: field_is_inherited.unwrap_or(false),
            user: field_user,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("invitee", &self.invitee)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("initials", &self.initials)?;
        s.serialize_field("is_inherited", &self.is_inherited)?;
        s.serialize_field("user", &self.user)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for InviteeMembershipInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = InviteeMembershipInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a InviteeMembershipInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                InviteeMembershipInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("InviteeMembershipInfo", INVITEE_MEMBERSHIP_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for InviteeMembershipInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("InviteeMembershipInfo", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error occurred while performing an asynchronous job from :route:`unshare_folder` or
/// :route:`remove_folder_member`.
#[derive(Debug)]
pub enum JobError {
    /// Error occurred while performing :route:`unshare_folder` action.
    UnshareFolderError(UnshareFolderError),
    /// Error occurred while performing :route:`remove_folder_member` action.
    RemoveFolderMemberError(RemoveFolderMemberError),
    /// Error occurred while performing :route:`relinquish_folder_membership` action.
    RelinquishFolderMembershipError(RelinquishFolderMembershipError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for JobError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = JobError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a JobError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unshare_folder_error" => {
                        if map.next_key()? != Some("unshare_folder_error") {
                            return Err(de::Error::missing_field("unshare_folder_error"));
                        }
                        Ok(JobError::UnshareFolderError(map.next_value()?))
                    }
                    "remove_folder_member_error" => {
                        if map.next_key()? != Some("remove_folder_member_error") {
                            return Err(de::Error::missing_field("remove_folder_member_error"));
                        }
                        Ok(JobError::RemoveFolderMemberError(map.next_value()?))
                    }
                    "relinquish_folder_membership_error" => {
                        if map.next_key()? != Some("relinquish_folder_membership_error") {
                            return Err(de::Error::missing_field("relinquish_folder_membership_error"));
                        }
                        Ok(JobError::RelinquishFolderMembershipError(map.next_value()?))
                    }
                    _ => Ok(JobError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["unshare_folder_error",
                                                    "remove_folder_member_error",
                                                    "relinquish_folder_membership_error",
                                                    "other"];
        deserializer.deserialize_struct("JobError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for JobError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            JobError::UnshareFolderError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "unshare_folder_error")?;
                s.serialize_field("unshare_folder_error", x)?;
                s.end()
            }
            JobError::RemoveFolderMemberError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "remove_folder_member_error")?;
                s.serialize_field("remove_folder_member_error", x)?;
                s.end()
            }
            JobError::RelinquishFolderMembershipError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "relinquish_folder_membership_error")?;
                s.serialize_field("relinquish_folder_membership_error", x)?;
                s.end()
            }
            JobError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for JobError {
    fn description(&self) -> &str {
        "JobError"
    }
}

impl ::std::fmt::Display for JobError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum JobStatus {
    /// The asynchronous job is still in progress.
    InProgress,
    /// The asynchronous job has finished.
    Complete,
    /// The asynchronous job returned an error.
    Failed(JobError),
}

impl<'de> ::serde::de::Deserialize<'de> for JobStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = JobStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a JobStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "in_progress" => Ok(JobStatus::InProgress),
                    "complete" => Ok(JobStatus::Complete),
                    "failed" => {
                        if map.next_key()? != Some("failed") {
                            return Err(de::Error::missing_field("failed"));
                        }
                        Ok(JobStatus::Failed(map.next_value()?))
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["in_progress",
                                                    "complete",
                                                    "failed"];
        deserializer.deserialize_struct("JobStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for JobStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            JobStatus::InProgress => {
                // unit
                let mut s = serializer.serialize_struct("JobStatus", 1)?;
                s.serialize_field(".tag", "in_progress")?;
                s.end()
            }
            JobStatus::Complete => {
                // unit
                let mut s = serializer.serialize_struct("JobStatus", 1)?;
                s.serialize_field(".tag", "complete")?;
                s.end()
            }
            JobStatus::Failed(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "failed")?;
                s.serialize_field("failed", x)?;
                s.end()
            }
        }
    }
}

/// Actions that can be performed on a link.
#[derive(Debug)]
pub enum LinkAction {
    /// Change the access level of the link.
    ChangeAccessLevel,
    /// Change the audience of the link.
    ChangeAudience,
    /// Remove the expiry date of the link.
    RemoveExpiry,
    /// Remove the password of the link.
    RemovePassword,
    /// Create or modify the expiry date of the link.
    SetExpiry,
    /// Create or modify the password of the link.
    SetPassword,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "change_access_level" => Ok(LinkAction::ChangeAccessLevel),
                    "change_audience" => Ok(LinkAction::ChangeAudience),
                    "remove_expiry" => Ok(LinkAction::RemoveExpiry),
                    "remove_password" => Ok(LinkAction::RemovePassword),
                    "set_expiry" => Ok(LinkAction::SetExpiry),
                    "set_password" => Ok(LinkAction::SetPassword),
                    _ => Ok(LinkAction::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["change_access_level",
                                                    "change_audience",
                                                    "remove_expiry",
                                                    "remove_password",
                                                    "set_expiry",
                                                    "set_password",
                                                    "other"];
        deserializer.deserialize_struct("LinkAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkAction::ChangeAccessLevel => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "change_access_level")?;
                s.end()
            }
            LinkAction::ChangeAudience => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "change_audience")?;
                s.end()
            }
            LinkAction::RemoveExpiry => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "remove_expiry")?;
                s.end()
            }
            LinkAction::RemovePassword => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "remove_password")?;
                s.end()
            }
            LinkAction::SetExpiry => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "set_expiry")?;
                s.end()
            }
            LinkAction::SetPassword => {
                // unit
                let mut s = serializer.serialize_struct("LinkAction", 1)?;
                s.serialize_field(".tag", "set_password")?;
                s.end()
            }
            LinkAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum LinkAudience {
    /// Link is accessible by anyone.
    Public,
    /// Link is accessible only by team members.
    Team,
    /// Link is accessible only by members of the content.
    Members,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkAudience {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkAudience;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkAudience structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "public" => Ok(LinkAudience::Public),
                    "team" => Ok(LinkAudience::Team),
                    "members" => Ok(LinkAudience::Members),
                    _ => Ok(LinkAudience::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["public",
                                                    "team",
                                                    "members",
                                                    "other"];
        deserializer.deserialize_struct("LinkAudience", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkAudience {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkAudience::Public => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            LinkAudience::Team => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            LinkAudience::Members => {
                // unit
                let mut s = serializer.serialize_struct("LinkAudience", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            LinkAudience::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum LinkExpiry {
    /// Remove the currently set expiry for the link.
    RemoveExpiry,
    /// Set a new expiry or change an existing expiry.
    SetExpiry(super::common::DropboxTimestamp),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkExpiry {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkExpiry;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkExpiry structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove_expiry" => Ok(LinkExpiry::RemoveExpiry),
                    "set_expiry" => {
                        if map.next_key()? != Some("set_expiry") {
                            return Err(de::Error::missing_field("set_expiry"));
                        }
                        Ok(LinkExpiry::SetExpiry(map.next_value()?))
                    }
                    _ => Ok(LinkExpiry::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["remove_expiry",
                                                    "set_expiry",
                                                    "other"];
        deserializer.deserialize_struct("LinkExpiry", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkExpiry {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkExpiry::RemoveExpiry => {
                // unit
                let mut s = serializer.serialize_struct("LinkExpiry", 1)?;
                s.serialize_field(".tag", "remove_expiry")?;
                s.end()
            }
            LinkExpiry::SetExpiry(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "set_expiry")?;
                s.serialize_field("set_expiry", x)?;
                s.end()
            }
            LinkExpiry::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Metadata for a shared link. This can be either a :type:`PathLinkMetadata` or
/// :type:`CollectionLinkMetadata`.
#[derive(Debug)]
pub enum LinkMetadata {
    Path(PathLinkMetadata),
    Collection(CollectionLinkMetadata),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for LinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkMetadata structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "path" => Ok(LinkMetadata::Path(PathLinkMetadata::internal_deserialize(map)?)),
                    "collection" => Ok(LinkMetadata::Collection(CollectionLinkMetadata::internal_deserialize(map)?)),
                    _ => Ok(LinkMetadata::_Unknown)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["collection",
                                                    "collection"];
        deserializer.deserialize_struct("LinkMetadata", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkMetadata::Path(ref x) => {
                let mut s = serializer.serialize_struct("LinkMetadata", 5)?;
                s.serialize_field(".tag", "path")?;
                s.serialize_field("url", &x.url)?;
                s.serialize_field("visibility", &x.visibility)?;
                s.serialize_field("path", &x.path)?;
                s.serialize_field("expires", &x.expires)?;
                s.end()
            }
            LinkMetadata::Collection(ref x) => {
                let mut s = serializer.serialize_struct("LinkMetadata", 4)?;
                s.serialize_field(".tag", "collection")?;
                s.serialize_field("url", &x.url)?;
                s.serialize_field("visibility", &x.visibility)?;
                s.serialize_field("expires", &x.expires)?;
                s.end()
            }
            LinkMetadata::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

#[derive(Debug)]
pub enum LinkPassword {
    /// Remove the currently set password for the link.
    RemovePassword,
    /// Set a new password or change an existing password.
    SetPassword(String),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkPassword {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkPassword;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkPassword structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove_password" => Ok(LinkPassword::RemovePassword),
                    "set_password" => {
                        if map.next_key()? != Some("set_password") {
                            return Err(de::Error::missing_field("set_password"));
                        }
                        Ok(LinkPassword::SetPassword(map.next_value()?))
                    }
                    _ => Ok(LinkPassword::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["remove_password",
                                                    "set_password",
                                                    "other"];
        deserializer.deserialize_struct("LinkPassword", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkPassword {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkPassword::RemovePassword => {
                // unit
                let mut s = serializer.serialize_struct("LinkPassword", 1)?;
                s.serialize_field(".tag", "remove_password")?;
                s.end()
            }
            LinkPassword::SetPassword(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "set_password")?;
                s.serialize_field("set_password", x)?;
                s.end()
            }
            LinkPassword::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Permissions for actions that can be performed on a link.
#[derive(Debug)]
pub struct LinkPermission {
    pub action: LinkAction,
    pub allow: bool,
    pub reason: Option<PermissionDeniedReason>,
}

impl LinkPermission {
    pub fn new(action: LinkAction, allow: bool) -> Self {
        LinkPermission {
            action,
            allow,
            reason: None,
        }
    }

    pub fn with_reason(mut self, value: Option<PermissionDeniedReason>) -> Self {
        self.reason = value;
        self
    }

}

const LINK_PERMISSION_FIELDS: &'static [&'static str] = &["action",
                                                          "allow",
                                                          "reason"];
impl LinkPermission {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<LinkPermission, V::Error> {
        use serde::de;
        let mut field_action = None;
        let mut field_allow = None;
        let mut field_reason = None;
        while let Some(key) = map.next_key()? {
            match key {
                "action" => {
                    if field_action.is_some() {
                        return Err(de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                "allow" => {
                    if field_allow.is_some() {
                        return Err(de::Error::duplicate_field("allow"));
                    }
                    field_allow = Some(map.next_value()?);
                }
                "reason" => {
                    if field_reason.is_some() {
                        return Err(de::Error::duplicate_field("reason"));
                    }
                    field_reason = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LINK_PERMISSION_FIELDS))
            }
        }
        Ok(LinkPermission {
            action: field_action.ok_or_else(|| de::Error::missing_field("action"))?,
            allow: field_allow.ok_or_else(|| de::Error::missing_field("allow"))?,
            reason: field_reason,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("action", &self.action)?;
        s.serialize_field("allow", &self.allow)?;
        s.serialize_field("reason", &self.reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LinkPermission {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LinkPermission;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkPermission struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LinkPermission::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LinkPermission", LINK_PERMISSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LinkPermission {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LinkPermission", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LinkPermissions {
    /// Whether the caller can revoke the shared link
    pub can_revoke: bool,
    /// The current visibility of the link after considering the shared links policies of the the
    /// team (in case the link's owner is part of a team) and the shared folder (in case the linked
    /// file is part of a shared folder). This field is shown only if the caller has access to this
    /// info (the link's owner always has access to this data).
    pub resolved_visibility: Option<ResolvedVisibility>,
    /// The shared link's requested visibility. This can be overridden by the team and shared folder
    /// policies. The final visibility, after considering these policies, can be found in
    /// :field:`resolved_visibility`. This is shown only if the caller is the link's owner.
    pub requested_visibility: Option<RequestedVisibility>,
    /// The failure reason for revoking the link. This field will only be present if the
    /// :field:`can_revoke` is :val:`false`.
    pub revoke_failure_reason: Option<SharedLinkAccessFailureReason>,
}

impl LinkPermissions {
    pub fn new(can_revoke: bool) -> Self {
        LinkPermissions {
            can_revoke,
            resolved_visibility: None,
            requested_visibility: None,
            revoke_failure_reason: None,
        }
    }

    pub fn with_resolved_visibility(mut self, value: Option<ResolvedVisibility>) -> Self {
        self.resolved_visibility = value;
        self
    }

    pub fn with_requested_visibility(mut self, value: Option<RequestedVisibility>) -> Self {
        self.requested_visibility = value;
        self
    }

    pub fn with_revoke_failure_reason(mut self, value: Option<SharedLinkAccessFailureReason>) -> Self {
        self.revoke_failure_reason = value;
        self
    }

}

const LINK_PERMISSIONS_FIELDS: &'static [&'static str] = &["can_revoke",
                                                           "resolved_visibility",
                                                           "requested_visibility",
                                                           "revoke_failure_reason"];
impl LinkPermissions {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<LinkPermissions, V::Error> {
        use serde::de;
        let mut field_can_revoke = None;
        let mut field_resolved_visibility = None;
        let mut field_requested_visibility = None;
        let mut field_revoke_failure_reason = None;
        while let Some(key) = map.next_key()? {
            match key {
                "can_revoke" => {
                    if field_can_revoke.is_some() {
                        return Err(de::Error::duplicate_field("can_revoke"));
                    }
                    field_can_revoke = Some(map.next_value()?);
                }
                "resolved_visibility" => {
                    if field_resolved_visibility.is_some() {
                        return Err(de::Error::duplicate_field("resolved_visibility"));
                    }
                    field_resolved_visibility = Some(map.next_value()?);
                }
                "requested_visibility" => {
                    if field_requested_visibility.is_some() {
                        return Err(de::Error::duplicate_field("requested_visibility"));
                    }
                    field_requested_visibility = Some(map.next_value()?);
                }
                "revoke_failure_reason" => {
                    if field_revoke_failure_reason.is_some() {
                        return Err(de::Error::duplicate_field("revoke_failure_reason"));
                    }
                    field_revoke_failure_reason = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LINK_PERMISSIONS_FIELDS))
            }
        }
        Ok(LinkPermissions {
            can_revoke: field_can_revoke.ok_or_else(|| de::Error::missing_field("can_revoke"))?,
            resolved_visibility: field_resolved_visibility,
            requested_visibility: field_requested_visibility,
            revoke_failure_reason: field_revoke_failure_reason,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("can_revoke", &self.can_revoke)?;
        s.serialize_field("resolved_visibility", &self.resolved_visibility)?;
        s.serialize_field("requested_visibility", &self.requested_visibility)?;
        s.serialize_field("revoke_failure_reason", &self.revoke_failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LinkPermissions {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LinkPermissions;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkPermissions struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LinkPermissions::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LinkPermissions", LINK_PERMISSIONS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LinkPermissions {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LinkPermissions", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Settings that apply to a link.
#[derive(Debug)]
pub struct LinkSettings {
    /// The access level on the link for this file. Currently, it only accepts 'viewer' and
    /// 'viewer_no_comment'.
    pub access_level: Option<AccessLevel>,
    /// The type of audience on the link for this file.
    pub audience: Option<LinkAudience>,
    /// An expiry timestamp to set on a link.
    pub expiry: Option<LinkExpiry>,
    /// The password for the link.
    pub password: Option<LinkPassword>,
}

impl Default for LinkSettings {
    fn default() -> Self {
        LinkSettings {
            access_level: None,
            audience: None,
            expiry: None,
            password: None,
        }
    }
}

const LINK_SETTINGS_FIELDS: &'static [&'static str] = &["access_level",
                                                        "audience",
                                                        "expiry",
                                                        "password"];
impl LinkSettings {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<LinkSettings, V::Error> {
        use serde::de;
        let mut field_access_level = None;
        let mut field_audience = None;
        let mut field_expiry = None;
        let mut field_password = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "audience" => {
                    if field_audience.is_some() {
                        return Err(de::Error::duplicate_field("audience"));
                    }
                    field_audience = Some(map.next_value()?);
                }
                "expiry" => {
                    if field_expiry.is_some() {
                        return Err(de::Error::duplicate_field("expiry"));
                    }
                    field_expiry = Some(map.next_value()?);
                }
                "password" => {
                    if field_password.is_some() {
                        return Err(de::Error::duplicate_field("password"));
                    }
                    field_password = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LINK_SETTINGS_FIELDS))
            }
        }
        Ok(LinkSettings {
            access_level: field_access_level,
            audience: field_audience,
            expiry: field_expiry,
            password: field_password,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("audience", &self.audience)?;
        s.serialize_field("expiry", &self.expiry)?;
        s.serialize_field("password", &self.password)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LinkSettings {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LinkSettings;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a LinkSettings struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LinkSettings::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LinkSettings", LINK_SETTINGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LinkSettings {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LinkSettings", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for :route:`list_file_members`.
#[derive(Debug)]
pub struct ListFileMembersArg {
    /// The file for which you want to see members.
    pub file: PathOrId,
    /// The actions for which to return permissions on a member.
    pub actions: Option<Vec<MemberAction>>,
    /// Whether to include members who only have access from a parent shared folder.
    pub include_inherited: bool,
    /// Number of members to return max per query. Defaults to 100 if no limit is specified.
    pub limit: u32,
}

impl ListFileMembersArg {
    pub fn new(file: PathOrId) -> Self {
        ListFileMembersArg {
            file,
            actions: None,
            include_inherited: true,
            limit: 100,
        }
    }

    pub fn with_actions(mut self, value: Option<Vec<MemberAction>>) -> Self {
        self.actions = value;
        self
    }

    pub fn with_include_inherited(mut self, value: bool) -> Self {
        self.include_inherited = value;
        self
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

}

const LIST_FILE_MEMBERS_ARG_FIELDS: &'static [&'static str] = &["file",
                                                                "actions",
                                                                "include_inherited",
                                                                "limit"];
impl ListFileMembersArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFileMembersArg, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_actions = None;
        let mut field_include_inherited = None;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                "include_inherited" => {
                    if field_include_inherited.is_some() {
                        return Err(de::Error::duplicate_field("include_inherited"));
                    }
                    field_include_inherited = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILE_MEMBERS_ARG_FIELDS))
            }
        }
        Ok(ListFileMembersArg {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            actions: field_actions,
            include_inherited: field_include_inherited.unwrap_or(true),
            limit: field_limit.unwrap_or(100),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("actions", &self.actions)?;
        s.serialize_field("include_inherited", &self.include_inherited)?;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileMembersArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileMembersArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileMembersArg", LIST_FILE_MEMBERS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileMembersArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for :route:`list_file_members/batch`.
#[derive(Debug)]
pub struct ListFileMembersBatchArg {
    /// Files for which to return members.
    pub files: Vec<PathOrId>,
    /// Number of members to return max per query. Defaults to 10 if no limit is specified.
    pub limit: u32,
}

impl ListFileMembersBatchArg {
    pub fn new(files: Vec<PathOrId>) -> Self {
        ListFileMembersBatchArg {
            files,
            limit: 10,
        }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

}

const LIST_FILE_MEMBERS_BATCH_ARG_FIELDS: &'static [&'static str] = &["files",
                                                                      "limit"];
impl ListFileMembersBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFileMembersBatchArg, V::Error> {
        use serde::de;
        let mut field_files = None;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "files" => {
                    if field_files.is_some() {
                        return Err(de::Error::duplicate_field("files"));
                    }
                    field_files = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILE_MEMBERS_BATCH_ARG_FIELDS))
            }
        }
        Ok(ListFileMembersBatchArg {
            files: field_files.ok_or_else(|| de::Error::missing_field("files"))?,
            limit: field_limit.unwrap_or(10),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("files", &self.files)?;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileMembersBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileMembersBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileMembersBatchArg", LIST_FILE_MEMBERS_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileMembersBatchArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Per-file result for :route:`list_file_members/batch`.
#[derive(Debug)]
pub struct ListFileMembersBatchResult {
    /// This is the input file identifier, whether an ID or a path.
    pub file: PathOrId,
    /// The result for this particular file.
    pub result: ListFileMembersIndividualResult,
}

impl ListFileMembersBatchResult {
    pub fn new(file: PathOrId, result: ListFileMembersIndividualResult) -> Self {
        ListFileMembersBatchResult {
            file,
            result,
        }
    }

}

const LIST_FILE_MEMBERS_BATCH_RESULT_FIELDS: &'static [&'static str] = &["file",
                                                                         "result"];
impl ListFileMembersBatchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFileMembersBatchResult, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_result = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "result" => {
                    if field_result.is_some() {
                        return Err(de::Error::duplicate_field("result"));
                    }
                    field_result = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILE_MEMBERS_BATCH_RESULT_FIELDS))
            }
        }
        Ok(ListFileMembersBatchResult {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            result: field_result.ok_or_else(|| de::Error::missing_field("result"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("result", &self.result)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersBatchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileMembersBatchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersBatchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileMembersBatchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileMembersBatchResult", LIST_FILE_MEMBERS_BATCH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersBatchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileMembersBatchResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for :route:`list_file_members/continue`.
#[derive(Debug)]
pub struct ListFileMembersContinueArg {
    /// The cursor returned by your last call to :route:`list_file_members`,
    /// :route:`list_file_members/continue`, or :route:`list_file_members/batch`.
    pub cursor: String,
}

impl ListFileMembersContinueArg {
    pub fn new(cursor: String) -> Self {
        ListFileMembersContinueArg {
            cursor,
        }
    }

}

const LIST_FILE_MEMBERS_CONTINUE_ARG_FIELDS: &'static [&'static str] = &["cursor"];
impl ListFileMembersContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFileMembersContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILE_MEMBERS_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(ListFileMembersContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileMembersContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileMembersContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileMembersContinueArg", LIST_FILE_MEMBERS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileMembersContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error for :route:`list_file_members/continue`.
#[derive(Debug)]
pub enum ListFileMembersContinueError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    /// :field:`ListFileMembersContinueArg.cursor` is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFileMembersContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(ListFileMembersContinueError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(ListFileMembersContinueError::AccessError(map.next_value()?))
                    }
                    "invalid_cursor" => Ok(ListFileMembersContinueError::InvalidCursor),
                    _ => Ok(ListFileMembersContinueError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "invalid_cursor",
                                                    "other"];
        deserializer.deserialize_struct("ListFileMembersContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFileMembersContinueError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            ListFileMembersContinueError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            ListFileMembersContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("ListFileMembersContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            ListFileMembersContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFileMembersContinueError {
    fn description(&self) -> &str {
        "ListFileMembersContinueError"
    }
}

impl ::std::fmt::Display for ListFileMembersContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListFileMembersCountResult {
    /// A list of members on this file.
    pub members: SharedFileMembers,
    /// The number of members on this file. This does not include inherited members.
    pub member_count: u32,
}

impl ListFileMembersCountResult {
    pub fn new(members: SharedFileMembers, member_count: u32) -> Self {
        ListFileMembersCountResult {
            members,
            member_count,
        }
    }

}

const LIST_FILE_MEMBERS_COUNT_RESULT_FIELDS: &'static [&'static str] = &["members",
                                                                         "member_count"];
impl ListFileMembersCountResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFileMembersCountResult, V::Error> {
        use serde::de;
        let mut field_members = None;
        let mut field_member_count = None;
        while let Some(key) = map.next_key()? {
            match key {
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "member_count" => {
                    if field_member_count.is_some() {
                        return Err(de::Error::duplicate_field("member_count"));
                    }
                    field_member_count = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILE_MEMBERS_COUNT_RESULT_FIELDS))
            }
        }
        Ok(ListFileMembersCountResult {
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            member_count: field_member_count.ok_or_else(|| de::Error::missing_field("member_count"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("member_count", &self.member_count)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersCountResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileMembersCountResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersCountResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileMembersCountResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileMembersCountResult", LIST_FILE_MEMBERS_COUNT_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersCountResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileMembersCountResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error for :route:`list_file_members`.
#[derive(Debug)]
pub enum ListFileMembersError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFileMembersError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(ListFileMembersError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(ListFileMembersError::AccessError(map.next_value()?))
                    }
                    _ => Ok(ListFileMembersError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "other"];
        deserializer.deserialize_struct("ListFileMembersError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFileMembersError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            ListFileMembersError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            ListFileMembersError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFileMembersError {
    fn description(&self) -> &str {
        "ListFileMembersError"
    }
}

impl ::std::fmt::Display for ListFileMembersError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum ListFileMembersIndividualResult {
    /// The results of the query for this file if it was successful.
    ResultVariant(ListFileMembersCountResult),
    /// The result of the query for this file if it was an error.
    AccessError(SharingFileAccessError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileMembersIndividualResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFileMembersIndividualResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileMembersIndividualResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "result" => Ok(ListFileMembersIndividualResult::ResultVariant(ListFileMembersCountResult::internal_deserialize(map)?)),
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(ListFileMembersIndividualResult::AccessError(map.next_value()?))
                    }
                    _ => Ok(ListFileMembersIndividualResult::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["result",
                                                    "access_error",
                                                    "other"];
        deserializer.deserialize_struct("ListFileMembersIndividualResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileMembersIndividualResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFileMembersIndividualResult::ResultVariant(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ListFileMembersIndividualResult", 3)?;
                s.serialize_field(".tag", "result")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ListFileMembersIndividualResult::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            ListFileMembersIndividualResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Arguments for :route:`list_received_files`.
#[derive(Debug)]
pub struct ListFilesArg {
    /// Number of files to return max per query. Defaults to 100 if no limit is specified.
    pub limit: u32,
    /// A list of `FileAction`s corresponding to `FilePermission`s that should appear in the
    /// response's :field:`SharedFileMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the file.
    pub actions: Option<Vec<FileAction>>,
}

impl Default for ListFilesArg {
    fn default() -> Self {
        ListFilesArg {
            limit: 100,
            actions: None,
        }
    }
}

const LIST_FILES_ARG_FIELDS: &'static [&'static str] = &["limit",
                                                         "actions"];
impl ListFilesArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFilesArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILES_ARG_FIELDS))
            }
        }
        Ok(ListFilesArg {
            limit: field_limit.unwrap_or(100),
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFilesArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFilesArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFilesArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFilesArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFilesArg", LIST_FILES_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFilesArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFilesArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for :route:`list_received_files/continue`.
#[derive(Debug)]
pub struct ListFilesContinueArg {
    /// Cursor in :field:`ListFilesResult.cursor`.
    pub cursor: String,
}

impl ListFilesContinueArg {
    pub fn new(cursor: String) -> Self {
        ListFilesContinueArg {
            cursor,
        }
    }

}

const LIST_FILES_CONTINUE_ARG_FIELDS: &'static [&'static str] = &["cursor"];
impl ListFilesContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFilesContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILES_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(ListFilesContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFilesContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFilesContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFilesContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFilesContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFilesContinueArg", LIST_FILES_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFilesContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFilesContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error results for :route:`list_received_files/continue`.
#[derive(Debug)]
pub enum ListFilesContinueError {
    /// User account had a problem.
    UserError(SharingUserError),
    /// :field:`ListFilesContinueArg.cursor` is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFilesContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFilesContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFilesContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(ListFilesContinueError::UserError(map.next_value()?))
                    }
                    "invalid_cursor" => Ok(ListFilesContinueError::InvalidCursor),
                    _ => Ok(ListFilesContinueError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "invalid_cursor",
                                                    "other"];
        deserializer.deserialize_struct("ListFilesContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFilesContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFilesContinueError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            ListFilesContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("ListFilesContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            ListFilesContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFilesContinueError {
    fn description(&self) -> &str {
        "ListFilesContinueError"
    }
}

impl ::std::fmt::Display for ListFilesContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Success results for :route:`list_received_files`.
#[derive(Debug)]
pub struct ListFilesResult {
    /// Information about the files shared with current user.
    pub entries: Vec<SharedFileMetadata>,
    /// Cursor used to obtain additional shared files.
    pub cursor: Option<String>,
}

impl ListFilesResult {
    pub fn new(entries: Vec<SharedFileMetadata>) -> Self {
        ListFilesResult {
            entries,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_FILES_RESULT_FIELDS: &'static [&'static str] = &["entries",
                                                            "cursor"];
impl ListFilesResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFilesResult, V::Error> {
        use serde::de;
        let mut field_entries = None;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "entries" => {
                    if field_entries.is_some() {
                        return Err(de::Error::duplicate_field("entries"));
                    }
                    field_entries = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FILES_RESULT_FIELDS))
            }
        }
        Ok(ListFilesResult {
            entries: field_entries.ok_or_else(|| de::Error::missing_field("entries"))?,
            cursor: field_cursor,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entries", &self.entries)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFilesResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFilesResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFilesResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFilesResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFilesResult", LIST_FILES_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFilesResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFilesResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListFolderMembersArgs {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// This is a list indicating whether each returned member will include a boolean value
    /// :field:`MemberPermission.allow` that describes whether the current user can perform the
    /// MemberAction on the member.
    pub actions: Option<Vec<MemberAction>>,
    /// The maximum number of results that include members, groups and invitees to return per
    /// request.
    pub limit: u32,
}

impl ListFolderMembersArgs {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        ListFolderMembersArgs {
            shared_folder_id,
            actions: None,
            limit: 1000,
        }
    }

    pub fn with_actions(mut self, value: Option<Vec<MemberAction>>) -> Self {
        self.actions = value;
        self
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

}

const LIST_FOLDER_MEMBERS_ARGS_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                   "actions",
                                                                   "limit"];
impl ListFolderMembersArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFolderMembersArgs, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_actions = None;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDER_MEMBERS_ARGS_FIELDS))
            }
        }
        Ok(ListFolderMembersArgs {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            actions: field_actions,
            limit: field_limit.unwrap_or(1000),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("actions", &self.actions)?;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFolderMembersArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFolderMembersArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFolderMembersArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFolderMembersArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFolderMembersArgs", LIST_FOLDER_MEMBERS_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFolderMembersArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFolderMembersArgs", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListFolderMembersContinueArg {
    /// The cursor returned by your last call to :route:`list_folder_members` or
    /// :route:`list_folder_members/continue`.
    pub cursor: String,
}

impl ListFolderMembersContinueArg {
    pub fn new(cursor: String) -> Self {
        ListFolderMembersContinueArg {
            cursor,
        }
    }

}

const LIST_FOLDER_MEMBERS_CONTINUE_ARG_FIELDS: &'static [&'static str] = &["cursor"];
impl ListFolderMembersContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFolderMembersContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDER_MEMBERS_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(ListFolderMembersContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFolderMembersContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFolderMembersContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFolderMembersContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFolderMembersContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFolderMembersContinueArg", LIST_FOLDER_MEMBERS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFolderMembersContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFolderMembersContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListFolderMembersContinueError {
    AccessError(SharedFolderAccessError),
    /// :field:`ListFolderMembersContinueArg.cursor` is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFolderMembersContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFolderMembersContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFolderMembersContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(ListFolderMembersContinueError::AccessError(map.next_value()?))
                    }
                    "invalid_cursor" => Ok(ListFolderMembersContinueError::InvalidCursor),
                    _ => Ok(ListFolderMembersContinueError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "invalid_cursor",
                                                    "other"];
        deserializer.deserialize_struct("ListFolderMembersContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFolderMembersContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFolderMembersContinueError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            ListFolderMembersContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("ListFolderMembersContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            ListFolderMembersContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFolderMembersContinueError {
    fn description(&self) -> &str {
        "ListFolderMembersContinueError"
    }
}

impl ::std::fmt::Display for ListFolderMembersContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListFolderMembersCursorArg {
    /// This is a list indicating whether each returned member will include a boolean value
    /// :field:`MemberPermission.allow` that describes whether the current user can perform the
    /// MemberAction on the member.
    pub actions: Option<Vec<MemberAction>>,
    /// The maximum number of results that include members, groups and invitees to return per
    /// request.
    pub limit: u32,
}

impl Default for ListFolderMembersCursorArg {
    fn default() -> Self {
        ListFolderMembersCursorArg {
            actions: None,
            limit: 1000,
        }
    }
}

const LIST_FOLDER_MEMBERS_CURSOR_ARG_FIELDS: &'static [&'static str] = &["actions",
                                                                         "limit"];
impl ListFolderMembersCursorArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFolderMembersCursorArg, V::Error> {
        use serde::de;
        let mut field_actions = None;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDER_MEMBERS_CURSOR_ARG_FIELDS))
            }
        }
        Ok(ListFolderMembersCursorArg {
            actions: field_actions,
            limit: field_limit.unwrap_or(1000),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("actions", &self.actions)?;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFolderMembersCursorArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFolderMembersCursorArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFolderMembersCursorArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFolderMembersCursorArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFolderMembersCursorArg", LIST_FOLDER_MEMBERS_CURSOR_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFolderMembersCursorArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFolderMembersCursorArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListFoldersArgs {
    /// The maximum number of results to return per request.
    pub limit: u32,
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's :field:`SharedFolderMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the folder.
    pub actions: Option<Vec<FolderAction>>,
}

impl Default for ListFoldersArgs {
    fn default() -> Self {
        ListFoldersArgs {
            limit: 1000,
            actions: None,
        }
    }
}

const LIST_FOLDERS_ARGS_FIELDS: &'static [&'static str] = &["limit",
                                                            "actions"];
impl ListFoldersArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFoldersArgs, V::Error> {
        use serde::de;
        let mut field_limit = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDERS_ARGS_FIELDS))
            }
        }
        Ok(ListFoldersArgs {
            limit: field_limit.unwrap_or(1000),
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFoldersArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFoldersArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFoldersArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFoldersArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFoldersArgs", LIST_FOLDERS_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFoldersArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFoldersArgs", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListFoldersContinueArg {
    /// The cursor returned by the previous API call specified in the endpoint description.
    pub cursor: String,
}

impl ListFoldersContinueArg {
    pub fn new(cursor: String) -> Self {
        ListFoldersContinueArg {
            cursor,
        }
    }

}

const LIST_FOLDERS_CONTINUE_ARG_FIELDS: &'static [&'static str] = &["cursor"];
impl ListFoldersContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFoldersContinueArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDERS_CONTINUE_ARG_FIELDS))
            }
        }
        Ok(ListFoldersContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFoldersContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFoldersContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFoldersContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFoldersContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFoldersContinueArg", LIST_FOLDERS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFoldersContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFoldersContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListFoldersContinueError {
    /// :field:`ListFoldersContinueArg.cursor` is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFoldersContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFoldersContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFoldersContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(ListFoldersContinueError::InvalidCursor),
                    _ => Ok(ListFoldersContinueError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["invalid_cursor",
                                                    "other"];
        deserializer.deserialize_struct("ListFoldersContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFoldersContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFoldersContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("ListFoldersContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            ListFoldersContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFoldersContinueError {
    fn description(&self) -> &str {
        "ListFoldersContinueError"
    }
}

impl ::std::fmt::Display for ListFoldersContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Result for :route:`list_folders` or :route:`list_mountable_folders`, depending on which endpoint
/// was requested. Unmounted shared folders can be identified by the absence of
/// :field:`SharedFolderMetadata.path_lower`.
#[derive(Debug)]
pub struct ListFoldersResult {
    /// List of all shared folders the authenticated user has access to.
    pub entries: Vec<SharedFolderMetadata>,
    /// Present if there are additional shared folders that have not been returned yet. Pass the
    /// cursor into the corresponding continue endpoint (either :route:`list_folders/continue` or
    /// :route:`list_mountable_folders/continue`) to list additional folders.
    pub cursor: Option<String>,
}

impl ListFoldersResult {
    pub fn new(entries: Vec<SharedFolderMetadata>) -> Self {
        ListFoldersResult {
            entries,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_FOLDERS_RESULT_FIELDS: &'static [&'static str] = &["entries",
                                                              "cursor"];
impl ListFoldersResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListFoldersResult, V::Error> {
        use serde::de;
        let mut field_entries = None;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "entries" => {
                    if field_entries.is_some() {
                        return Err(de::Error::duplicate_field("entries"));
                    }
                    field_entries = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_FOLDERS_RESULT_FIELDS))
            }
        }
        Ok(ListFoldersResult {
            entries: field_entries.ok_or_else(|| de::Error::missing_field("entries"))?,
            cursor: field_cursor,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entries", &self.entries)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFoldersResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFoldersResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFoldersResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFoldersResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFoldersResult", LIST_FOLDERS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFoldersResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFoldersResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListSharedLinksArg {
    /// See :route:`list_shared_links` description.
    pub path: Option<ReadPath>,
    /// The cursor returned by your last call to :route:`list_shared_links`.
    pub cursor: Option<String>,
    /// See :route:`list_shared_links` description.
    pub direct_only: Option<bool>,
}

impl Default for ListSharedLinksArg {
    fn default() -> Self {
        ListSharedLinksArg {
            path: None,
            cursor: None,
            direct_only: None,
        }
    }
}

const LIST_SHARED_LINKS_ARG_FIELDS: &'static [&'static str] = &["path",
                                                                "cursor",
                                                                "direct_only"];
impl ListSharedLinksArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListSharedLinksArg, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_cursor = None;
        let mut field_direct_only = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "direct_only" => {
                    if field_direct_only.is_some() {
                        return Err(de::Error::duplicate_field("direct_only"));
                    }
                    field_direct_only = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_SHARED_LINKS_ARG_FIELDS))
            }
        }
        Ok(ListSharedLinksArg {
            path: field_path,
            cursor: field_cursor,
            direct_only: field_direct_only,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("direct_only", &self.direct_only)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListSharedLinksArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListSharedLinksArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListSharedLinksArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListSharedLinksArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListSharedLinksArg", LIST_SHARED_LINKS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListSharedLinksArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListSharedLinksArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListSharedLinksError {
    Path(super::files::LookupError),
    /// Indicates that the cursor has been invalidated. Call :route:`list_shared_links` to obtain a
    /// new cursor.
    Reset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListSharedLinksError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListSharedLinksError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListSharedLinksError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "path" => {
                        if map.next_key()? != Some("path") {
                            return Err(de::Error::missing_field("path"));
                        }
                        Ok(ListSharedLinksError::Path(map.next_value()?))
                    }
                    "reset" => Ok(ListSharedLinksError::Reset),
                    _ => Ok(ListSharedLinksError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["path",
                                                    "reset",
                                                    "other"];
        deserializer.deserialize_struct("ListSharedLinksError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListSharedLinksError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListSharedLinksError::Path(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "path")?;
                s.serialize_field("path", x)?;
                s.end()
            }
            ListSharedLinksError::Reset => {
                // unit
                let mut s = serializer.serialize_struct("ListSharedLinksError", 1)?;
                s.serialize_field(".tag", "reset")?;
                s.end()
            }
            ListSharedLinksError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListSharedLinksError {
    fn description(&self) -> &str {
        "ListSharedLinksError"
    }
}

impl ::std::fmt::Display for ListSharedLinksError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListSharedLinksResult {
    /// Shared links applicable to the path argument.
    pub links: Vec<SharedLinkMetadata>,
    /// Is true if there are additional shared links that have not been returned yet. Pass the
    /// cursor into :route:`list_shared_links` to retrieve them.
    pub has_more: bool,
    /// Pass the cursor into :route:`list_shared_links` to obtain the additional links. Cursor is
    /// returned only if no path is given.
    pub cursor: Option<String>,
}

impl ListSharedLinksResult {
    pub fn new(links: Vec<SharedLinkMetadata>, has_more: bool) -> Self {
        ListSharedLinksResult {
            links,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_SHARED_LINKS_RESULT_FIELDS: &'static [&'static str] = &["links",
                                                                   "has_more",
                                                                   "cursor"];
impl ListSharedLinksResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ListSharedLinksResult, V::Error> {
        use serde::de;
        let mut field_links = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "links" => {
                    if field_links.is_some() {
                        return Err(de::Error::duplicate_field("links"));
                    }
                    field_links = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_SHARED_LINKS_RESULT_FIELDS))
            }
        }
        Ok(ListSharedLinksResult {
            links: field_links.ok_or_else(|| de::Error::missing_field("links"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("links", &self.links)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListSharedLinksResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListSharedLinksResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListSharedLinksResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListSharedLinksResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListSharedLinksResult", LIST_SHARED_LINKS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListSharedLinksResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListSharedLinksResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Contains information about a member's access level to content after an operation.
#[derive(Debug)]
pub struct MemberAccessLevelResult {
    /// The member still has this level of access to the content through a parent folder.
    pub access_level: Option<AccessLevel>,
    /// A localized string with additional information about why the user has this access level to
    /// the content.
    pub warning: Option<String>,
    /// The parent folders that a member has access to. The field is present if the user has access
    /// to the first parent folder where the member gains access.
    pub access_details: Option<Vec<ParentFolderAccessInfo>>,
}

impl Default for MemberAccessLevelResult {
    fn default() -> Self {
        MemberAccessLevelResult {
            access_level: None,
            warning: None,
            access_details: None,
        }
    }
}

const MEMBER_ACCESS_LEVEL_RESULT_FIELDS: &'static [&'static str] = &["access_level",
                                                                     "warning",
                                                                     "access_details"];
impl MemberAccessLevelResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberAccessLevelResult, V::Error> {
        use serde::de;
        let mut field_access_level = None;
        let mut field_warning = None;
        let mut field_access_details = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "warning" => {
                    if field_warning.is_some() {
                        return Err(de::Error::duplicate_field("warning"));
                    }
                    field_warning = Some(map.next_value()?);
                }
                "access_details" => {
                    if field_access_details.is_some() {
                        return Err(de::Error::duplicate_field("access_details"));
                    }
                    field_access_details = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ACCESS_LEVEL_RESULT_FIELDS))
            }
        }
        Ok(MemberAccessLevelResult {
            access_level: field_access_level,
            warning: field_warning,
            access_details: field_access_details,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("warning", &self.warning)?;
        s.serialize_field("access_details", &self.access_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAccessLevelResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAccessLevelResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAccessLevelResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAccessLevelResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAccessLevelResult", MEMBER_ACCESS_LEVEL_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAccessLevelResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAccessLevelResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Actions that may be taken on members of a shared folder.
#[derive(Debug)]
pub enum MemberAction {
    /// Allow the member to keep a copy of the folder when removing.
    LeaveACopy,
    /// Make the member an editor of the folder.
    MakeEditor,
    /// Make the member an owner of the folder.
    MakeOwner,
    /// Make the member a viewer of the folder.
    MakeViewer,
    /// Make the member a viewer of the folder without commenting permissions.
    MakeViewerNoComment,
    /// Remove the member from the folder.
    Remove,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "leave_a_copy" => Ok(MemberAction::LeaveACopy),
                    "make_editor" => Ok(MemberAction::MakeEditor),
                    "make_owner" => Ok(MemberAction::MakeOwner),
                    "make_viewer" => Ok(MemberAction::MakeViewer),
                    "make_viewer_no_comment" => Ok(MemberAction::MakeViewerNoComment),
                    "remove" => Ok(MemberAction::Remove),
                    _ => Ok(MemberAction::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["leave_a_copy",
                                                    "make_editor",
                                                    "make_owner",
                                                    "make_viewer",
                                                    "make_viewer_no_comment",
                                                    "remove",
                                                    "other"];
        deserializer.deserialize_struct("MemberAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberAction::LeaveACopy => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "leave_a_copy")?;
                s.end()
            }
            MemberAction::MakeEditor => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "make_editor")?;
                s.end()
            }
            MemberAction::MakeOwner => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "make_owner")?;
                s.end()
            }
            MemberAction::MakeViewer => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "make_viewer")?;
                s.end()
            }
            MemberAction::MakeViewerNoComment => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "make_viewer_no_comment")?;
                s.end()
            }
            MemberAction::Remove => {
                // unit
                let mut s = serializer.serialize_struct("MemberAction", 1)?;
                s.serialize_field(".tag", "remove")?;
                s.end()
            }
            MemberAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Whether the user is allowed to take the action on the associated member.
#[derive(Debug)]
pub struct MemberPermission {
    /// The action that the user may wish to take on the member.
    pub action: MemberAction,
    /// True if the user is allowed to take the action.
    pub allow: bool,
    /// The reason why the user is denied the permission. Not present if the action is allowed.
    pub reason: Option<PermissionDeniedReason>,
}

impl MemberPermission {
    pub fn new(action: MemberAction, allow: bool) -> Self {
        MemberPermission {
            action,
            allow,
            reason: None,
        }
    }

    pub fn with_reason(mut self, value: Option<PermissionDeniedReason>) -> Self {
        self.reason = value;
        self
    }

}

const MEMBER_PERMISSION_FIELDS: &'static [&'static str] = &["action",
                                                            "allow",
                                                            "reason"];
impl MemberPermission {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MemberPermission, V::Error> {
        use serde::de;
        let mut field_action = None;
        let mut field_allow = None;
        let mut field_reason = None;
        while let Some(key) = map.next_key()? {
            match key {
                "action" => {
                    if field_action.is_some() {
                        return Err(de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                "allow" => {
                    if field_allow.is_some() {
                        return Err(de::Error::duplicate_field("allow"));
                    }
                    field_allow = Some(map.next_value()?);
                }
                "reason" => {
                    if field_reason.is_some() {
                        return Err(de::Error::duplicate_field("reason"));
                    }
                    field_reason = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_PERMISSION_FIELDS))
            }
        }
        Ok(MemberPermission {
            action: field_action.ok_or_else(|| de::Error::missing_field("action"))?,
            allow: field_allow.ok_or_else(|| de::Error::missing_field("allow"))?,
            reason: field_reason,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("action", &self.action)?;
        s.serialize_field("allow", &self.allow)?;
        s.serialize_field("reason", &self.reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermission {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermission;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberPermission struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermission::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermission", MEMBER_PERMISSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermission {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberPermission", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy governing who can be a member of a shared folder. Only applicable to folders owned by a
/// user on a team.
#[derive(Debug)]
pub enum MemberPolicy {
    /// Only a teammate can become a member.
    Team,
    /// Anyone can become a member.
    Anyone,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team" => Ok(MemberPolicy::Team),
                    "anyone" => Ok(MemberPolicy::Anyone),
                    _ => Ok(MemberPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["team",
                                                    "anyone",
                                                    "other"];
        deserializer.deserialize_struct("MemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberPolicy::Team => {
                // unit
                let mut s = serializer.serialize_struct("MemberPolicy", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            MemberPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("MemberPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            MemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Includes different ways to identify a member of a shared folder.
#[derive(Debug)]
pub enum MemberSelector {
    /// Dropbox account, team member, or group ID of member.
    DropboxId(DropboxId),
    /// E-mail address of member.
    Email(super::common::EmailAddress),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSelector {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSelector;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSelector structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "dropbox_id" => {
                        if map.next_key()? != Some("dropbox_id") {
                            return Err(de::Error::missing_field("dropbox_id"));
                        }
                        Ok(MemberSelector::DropboxId(map.next_value()?))
                    }
                    "email" => {
                        if map.next_key()? != Some("email") {
                            return Err(de::Error::missing_field("email"));
                        }
                        Ok(MemberSelector::Email(map.next_value()?))
                    }
                    _ => Ok(MemberSelector::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["dropbox_id",
                                                    "email",
                                                    "other"];
        deserializer.deserialize_struct("MemberSelector", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSelector {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSelector::DropboxId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "dropbox_id")?;
                s.serialize_field("dropbox_id", x)?;
                s.end()
            }
            MemberSelector::Email(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "email")?;
                s.serialize_field("email", x)?;
                s.end()
            }
            MemberSelector::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The information about a member of the shared content.
#[derive(Debug)]
pub struct MembershipInfo {
    /// The access type for this member.
    pub access_type: AccessLevel,
    /// The permissions that requesting user has on this member. The set of permissions corresponds
    /// to the MemberActions in the request.
    pub permissions: Option<Vec<MemberPermission>>,
    /// Suggested name initials for a member.
    pub initials: Option<String>,
    /// True if the member has access from a parent folder.
    pub is_inherited: bool,
}

impl MembershipInfo {
    pub fn new(access_type: AccessLevel) -> Self {
        MembershipInfo {
            access_type,
            permissions: None,
            initials: None,
            is_inherited: false,
        }
    }

    pub fn with_permissions(mut self, value: Option<Vec<MemberPermission>>) -> Self {
        self.permissions = value;
        self
    }

    pub fn with_initials(mut self, value: Option<String>) -> Self {
        self.initials = value;
        self
    }

    pub fn with_is_inherited(mut self, value: bool) -> Self {
        self.is_inherited = value;
        self
    }

}

const MEMBERSHIP_INFO_FIELDS: &'static [&'static str] = &["access_type",
                                                          "permissions",
                                                          "initials",
                                                          "is_inherited"];
impl MembershipInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MembershipInfo, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_permissions = None;
        let mut field_initials = None;
        let mut field_is_inherited = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "initials" => {
                    if field_initials.is_some() {
                        return Err(de::Error::duplicate_field("initials"));
                    }
                    field_initials = Some(map.next_value()?);
                }
                "is_inherited" => {
                    if field_is_inherited.is_some() {
                        return Err(de::Error::duplicate_field("is_inherited"));
                    }
                    field_is_inherited = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERSHIP_INFO_FIELDS))
            }
        }
        Ok(MembershipInfo {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            permissions: field_permissions,
            initials: field_initials,
            is_inherited: field_is_inherited.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("initials", &self.initials)?;
        s.serialize_field("is_inherited", &self.is_inherited)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembershipInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembershipInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembershipInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembershipInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembershipInfo", MEMBERSHIP_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembershipInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembershipInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ModifySharedLinkSettingsArgs {
    /// URL of the shared link to change its settings
    pub url: String,
    /// Set of settings for the shared link.
    pub settings: SharedLinkSettings,
    /// If set to true, removes the expiration of the shared link.
    pub remove_expiration: bool,
}

impl ModifySharedLinkSettingsArgs {
    pub fn new(url: String, settings: SharedLinkSettings) -> Self {
        ModifySharedLinkSettingsArgs {
            url,
            settings,
            remove_expiration: false,
        }
    }

    pub fn with_remove_expiration(mut self, value: bool) -> Self {
        self.remove_expiration = value;
        self
    }

}

const MODIFY_SHARED_LINK_SETTINGS_ARGS_FIELDS: &'static [&'static str] = &["url",
                                                                           "settings",
                                                                           "remove_expiration"];
impl ModifySharedLinkSettingsArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ModifySharedLinkSettingsArgs, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_settings = None;
        let mut field_remove_expiration = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "settings" => {
                    if field_settings.is_some() {
                        return Err(de::Error::duplicate_field("settings"));
                    }
                    field_settings = Some(map.next_value()?);
                }
                "remove_expiration" => {
                    if field_remove_expiration.is_some() {
                        return Err(de::Error::duplicate_field("remove_expiration"));
                    }
                    field_remove_expiration = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MODIFY_SHARED_LINK_SETTINGS_ARGS_FIELDS))
            }
        }
        Ok(ModifySharedLinkSettingsArgs {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            settings: field_settings.ok_or_else(|| de::Error::missing_field("settings"))?,
            remove_expiration: field_remove_expiration.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("settings", &self.settings)?;
        s.serialize_field("remove_expiration", &self.remove_expiration)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ModifySharedLinkSettingsArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ModifySharedLinkSettingsArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ModifySharedLinkSettingsArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ModifySharedLinkSettingsArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ModifySharedLinkSettingsArgs", MODIFY_SHARED_LINK_SETTINGS_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ModifySharedLinkSettingsArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ModifySharedLinkSettingsArgs", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ModifySharedLinkSettingsError {
    /// The shared link wasn't found.
    SharedLinkNotFound,
    /// The caller is not allowed to access this shared link.
    SharedLinkAccessDenied,
    /// This type of link is not supported.
    UnsupportedLinkType,
    Other,
    /// There is an error with the given settings
    SettingsError(SharedLinkSettingsError),
    /// The caller's email should be verified
    EmailNotVerified,
}

impl<'de> ::serde::de::Deserialize<'de> for ModifySharedLinkSettingsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ModifySharedLinkSettingsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ModifySharedLinkSettingsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "shared_link_not_found" => Ok(ModifySharedLinkSettingsError::SharedLinkNotFound),
                    "shared_link_access_denied" => Ok(ModifySharedLinkSettingsError::SharedLinkAccessDenied),
                    "unsupported_link_type" => Ok(ModifySharedLinkSettingsError::UnsupportedLinkType),
                    "settings_error" => {
                        if map.next_key()? != Some("settings_error") {
                            return Err(de::Error::missing_field("settings_error"));
                        }
                        Ok(ModifySharedLinkSettingsError::SettingsError(map.next_value()?))
                    }
                    "email_not_verified" => Ok(ModifySharedLinkSettingsError::EmailNotVerified),
                    _ => Ok(ModifySharedLinkSettingsError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["shared_link_not_found",
                                                    "shared_link_access_denied",
                                                    "unsupported_link_type",
                                                    "other",
                                                    "settings_error",
                                                    "email_not_verified"];
        deserializer.deserialize_struct("ModifySharedLinkSettingsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ModifySharedLinkSettingsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ModifySharedLinkSettingsError::SharedLinkNotFound => {
                // unit
                let mut s = serializer.serialize_struct("ModifySharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "shared_link_not_found")?;
                s.end()
            }
            ModifySharedLinkSettingsError::SharedLinkAccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("ModifySharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "shared_link_access_denied")?;
                s.end()
            }
            ModifySharedLinkSettingsError::UnsupportedLinkType => {
                // unit
                let mut s = serializer.serialize_struct("ModifySharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "unsupported_link_type")?;
                s.end()
            }
            ModifySharedLinkSettingsError::SettingsError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "settings_error")?;
                s.serialize_field("settings_error", x)?;
                s.end()
            }
            ModifySharedLinkSettingsError::EmailNotVerified => {
                // unit
                let mut s = serializer.serialize_struct("ModifySharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "email_not_verified")?;
                s.end()
            }
            ModifySharedLinkSettingsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ModifySharedLinkSettingsError {
    fn description(&self) -> &str {
        "ModifySharedLinkSettingsError"
    }
}

impl ::std::fmt::Display for ModifySharedLinkSettingsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MountFolderArg {
    /// The ID of the shared folder to mount.
    pub shared_folder_id: super::common::SharedFolderId,
}

impl MountFolderArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        MountFolderArg {
            shared_folder_id,
        }
    }

}

const MOUNT_FOLDER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id"];
impl MountFolderArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<MountFolderArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MOUNT_FOLDER_ARG_FIELDS))
            }
        }
        Ok(MountFolderArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MountFolderArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MountFolderArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MountFolderArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MountFolderArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MountFolderArg", MOUNT_FOLDER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MountFolderArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MountFolderArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MountFolderError {
    AccessError(SharedFolderAccessError),
    /// Mounting would cause a shared folder to be inside another, which is disallowed.
    InsideSharedFolder,
    /// The current user does not have enough space to mount the shared folder.
    InsufficientQuota(InsufficientQuotaAmounts),
    /// The shared folder is already mounted.
    AlreadyMounted,
    /// The current user does not have permission to perform this action.
    NoPermission,
    /// The shared folder is not mountable. One example where this can occur is when the shared
    /// folder belongs within a team folder in the user's Dropbox.
    NotMountable,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MountFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MountFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MountFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(MountFolderError::AccessError(map.next_value()?))
                    }
                    "inside_shared_folder" => Ok(MountFolderError::InsideSharedFolder),
                    "insufficient_quota" => Ok(MountFolderError::InsufficientQuota(InsufficientQuotaAmounts::internal_deserialize(map)?)),
                    "already_mounted" => Ok(MountFolderError::AlreadyMounted),
                    "no_permission" => Ok(MountFolderError::NoPermission),
                    "not_mountable" => Ok(MountFolderError::NotMountable),
                    _ => Ok(MountFolderError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "inside_shared_folder",
                                                    "insufficient_quota",
                                                    "already_mounted",
                                                    "no_permission",
                                                    "not_mountable",
                                                    "other"];
        deserializer.deserialize_struct("MountFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MountFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MountFolderError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            MountFolderError::InsideSharedFolder => {
                // unit
                let mut s = serializer.serialize_struct("MountFolderError", 1)?;
                s.serialize_field(".tag", "inside_shared_folder")?;
                s.end()
            }
            MountFolderError::InsufficientQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("MountFolderError", 4)?;
                s.serialize_field(".tag", "insufficient_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            MountFolderError::AlreadyMounted => {
                // unit
                let mut s = serializer.serialize_struct("MountFolderError", 1)?;
                s.serialize_field(".tag", "already_mounted")?;
                s.end()
            }
            MountFolderError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("MountFolderError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            MountFolderError::NotMountable => {
                // unit
                let mut s = serializer.serialize_struct("MountFolderError", 1)?;
                s.serialize_field(".tag", "not_mountable")?;
                s.end()
            }
            MountFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MountFolderError {
    fn description(&self) -> &str {
        "MountFolderError"
    }
}

impl ::std::fmt::Display for MountFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Contains information about a parent folder that a member has access to.
#[derive(Debug)]
pub struct ParentFolderAccessInfo {
    /// Display name for the folder.
    pub folder_name: String,
    /// The identifier of the parent shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// The user's permissions for the parent shared folder.
    pub permissions: Vec<MemberPermission>,
    /// The full path to the parent shared folder relative to the acting user's root.
    pub path: String,
}

impl ParentFolderAccessInfo {
    pub fn new(folder_name: String, shared_folder_id: super::common::SharedFolderId, permissions: Vec<MemberPermission>, path: String) -> Self {
        ParentFolderAccessInfo {
            folder_name,
            shared_folder_id,
            permissions,
            path,
        }
    }

}

const PARENT_FOLDER_ACCESS_INFO_FIELDS: &'static [&'static str] = &["folder_name",
                                                                    "shared_folder_id",
                                                                    "permissions",
                                                                    "path"];
impl ParentFolderAccessInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ParentFolderAccessInfo, V::Error> {
        use serde::de;
        let mut field_folder_name = None;
        let mut field_shared_folder_id = None;
        let mut field_permissions = None;
        let mut field_path = None;
        while let Some(key) = map.next_key()? {
            match key {
                "folder_name" => {
                    if field_folder_name.is_some() {
                        return Err(de::Error::duplicate_field("folder_name"));
                    }
                    field_folder_name = Some(map.next_value()?);
                }
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PARENT_FOLDER_ACCESS_INFO_FIELDS))
            }
        }
        Ok(ParentFolderAccessInfo {
            folder_name: field_folder_name.ok_or_else(|| de::Error::missing_field("folder_name"))?,
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            permissions: field_permissions.ok_or_else(|| de::Error::missing_field("permissions"))?,
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_name", &self.folder_name)?;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("path", &self.path)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ParentFolderAccessInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ParentFolderAccessInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ParentFolderAccessInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ParentFolderAccessInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ParentFolderAccessInfo", PARENT_FOLDER_ACCESS_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ParentFolderAccessInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ParentFolderAccessInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Metadata for a path-based shared link.
#[derive(Debug)]
pub struct PathLinkMetadata {
    /// URL of the shared link.
    pub url: String,
    /// Who can access the link.
    pub visibility: Visibility,
    /// Path in user's Dropbox.
    pub path: String,
    /// Expiration time, if set. By default the link won't expire.
    pub expires: Option<super::common::DropboxTimestamp>,
}

impl PathLinkMetadata {
    pub fn new(url: String, visibility: Visibility, path: String) -> Self {
        PathLinkMetadata {
            url,
            visibility,
            path,
            expires: None,
        }
    }

    pub fn with_expires(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expires = value;
        self
    }

}

const PATH_LINK_METADATA_FIELDS: &'static [&'static str] = &["url",
                                                             "visibility",
                                                             "path",
                                                             "expires"];
impl PathLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<PathLinkMetadata, V::Error> {
        use serde::de;
        let mut field_url = None;
        let mut field_visibility = None;
        let mut field_path = None;
        let mut field_expires = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "visibility" => {
                    if field_visibility.is_some() {
                        return Err(de::Error::duplicate_field("visibility"));
                    }
                    field_visibility = Some(map.next_value()?);
                }
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, PATH_LINK_METADATA_FIELDS))
            }
        }
        Ok(PathLinkMetadata {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            visibility: field_visibility.ok_or_else(|| de::Error::missing_field("visibility"))?,
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            expires: field_expires,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("visibility", &self.visibility)?;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("expires", &self.expires)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PathLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PathLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PathLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PathLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PathLinkMetadata", PATH_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PathLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PathLinkMetadata", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Flag to indicate pending upload default (for linking to not-yet-existing paths).
#[derive(Debug)]
pub enum PendingUploadMode {
    /// Assume pending uploads are files.
    File,
    /// Assume pending uploads are folders.
    Folder,
}

impl<'de> ::serde::de::Deserialize<'de> for PendingUploadMode {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PendingUploadMode;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PendingUploadMode structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file" => Ok(PendingUploadMode::File),
                    "folder" => Ok(PendingUploadMode::Folder),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["file",
                                                    "folder"];
        deserializer.deserialize_struct("PendingUploadMode", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PendingUploadMode {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PendingUploadMode::File => {
                // unit
                let mut s = serializer.serialize_struct("PendingUploadMode", 1)?;
                s.serialize_field(".tag", "file")?;
                s.end()
            }
            PendingUploadMode::Folder => {
                // unit
                let mut s = serializer.serialize_struct("PendingUploadMode", 1)?;
                s.serialize_field(".tag", "folder")?;
                s.end()
            }
        }
    }
}

/// Possible reasons the user is denied a permission.
#[derive(Debug)]
pub enum PermissionDeniedReason {
    /// User is not on the same team as the folder owner.
    UserNotSameTeamAsOwner,
    /// User is prohibited by the owner from taking the action.
    UserNotAllowedByOwner,
    /// Target is indirectly a member of the folder, for example by being part of a group.
    TargetIsIndirectMember,
    /// Target is the owner of the folder.
    TargetIsOwner,
    /// Target is the user itself.
    TargetIsSelf,
    /// Target is not an active member of the team.
    TargetNotActive,
    /// Folder is team folder for a limited team.
    FolderIsLimitedTeamFolder,
    /// The content owner needs to be on a Dropbox team to perform this action.
    OwnerNotOnTeam,
    /// The user does not have permission to perform this action on the link.
    PermissionDenied,
    /// The user's team policy prevents performing this action on the link.
    RestrictedByTeam,
    /// The user's account type does not support this action.
    UserAccountType,
    /// The user needs to be on a Dropbox team to perform this action.
    UserNotOnTeam,
    /// Folder is inside of another shared folder.
    FolderIsInsideSharedFolder,
    InsufficientPlan(InsufficientPlan),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PermissionDeniedReason {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PermissionDeniedReason;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a PermissionDeniedReason structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_same_team_as_owner" => Ok(PermissionDeniedReason::UserNotSameTeamAsOwner),
                    "user_not_allowed_by_owner" => Ok(PermissionDeniedReason::UserNotAllowedByOwner),
                    "target_is_indirect_member" => Ok(PermissionDeniedReason::TargetIsIndirectMember),
                    "target_is_owner" => Ok(PermissionDeniedReason::TargetIsOwner),
                    "target_is_self" => Ok(PermissionDeniedReason::TargetIsSelf),
                    "target_not_active" => Ok(PermissionDeniedReason::TargetNotActive),
                    "folder_is_limited_team_folder" => Ok(PermissionDeniedReason::FolderIsLimitedTeamFolder),
                    "owner_not_on_team" => Ok(PermissionDeniedReason::OwnerNotOnTeam),
                    "permission_denied" => Ok(PermissionDeniedReason::PermissionDenied),
                    "restricted_by_team" => Ok(PermissionDeniedReason::RestrictedByTeam),
                    "user_account_type" => Ok(PermissionDeniedReason::UserAccountType),
                    "user_not_on_team" => Ok(PermissionDeniedReason::UserNotOnTeam),
                    "folder_is_inside_shared_folder" => Ok(PermissionDeniedReason::FolderIsInsideSharedFolder),
                    "insufficient_plan" => Ok(PermissionDeniedReason::InsufficientPlan(InsufficientPlan::internal_deserialize(map)?)),
                    _ => Ok(PermissionDeniedReason::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_not_same_team_as_owner",
                                                    "user_not_allowed_by_owner",
                                                    "target_is_indirect_member",
                                                    "target_is_owner",
                                                    "target_is_self",
                                                    "target_not_active",
                                                    "folder_is_limited_team_folder",
                                                    "owner_not_on_team",
                                                    "permission_denied",
                                                    "restricted_by_team",
                                                    "user_account_type",
                                                    "user_not_on_team",
                                                    "folder_is_inside_shared_folder",
                                                    "insufficient_plan",
                                                    "other"];
        deserializer.deserialize_struct("PermissionDeniedReason", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PermissionDeniedReason {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PermissionDeniedReason::UserNotSameTeamAsOwner => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "user_not_same_team_as_owner")?;
                s.end()
            }
            PermissionDeniedReason::UserNotAllowedByOwner => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "user_not_allowed_by_owner")?;
                s.end()
            }
            PermissionDeniedReason::TargetIsIndirectMember => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "target_is_indirect_member")?;
                s.end()
            }
            PermissionDeniedReason::TargetIsOwner => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "target_is_owner")?;
                s.end()
            }
            PermissionDeniedReason::TargetIsSelf => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "target_is_self")?;
                s.end()
            }
            PermissionDeniedReason::TargetNotActive => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "target_not_active")?;
                s.end()
            }
            PermissionDeniedReason::FolderIsLimitedTeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "folder_is_limited_team_folder")?;
                s.end()
            }
            PermissionDeniedReason::OwnerNotOnTeam => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "owner_not_on_team")?;
                s.end()
            }
            PermissionDeniedReason::PermissionDenied => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "permission_denied")?;
                s.end()
            }
            PermissionDeniedReason::RestrictedByTeam => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "restricted_by_team")?;
                s.end()
            }
            PermissionDeniedReason::UserAccountType => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "user_account_type")?;
                s.end()
            }
            PermissionDeniedReason::UserNotOnTeam => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "user_not_on_team")?;
                s.end()
            }
            PermissionDeniedReason::FolderIsInsideSharedFolder => {
                // unit
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 1)?;
                s.serialize_field(".tag", "folder_is_inside_shared_folder")?;
                s.end()
            }
            PermissionDeniedReason::InsufficientPlan(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("PermissionDeniedReason", 3)?;
                s.serialize_field(".tag", "insufficient_plan")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            PermissionDeniedReason::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct RelinquishFileMembershipArg {
    /// The path or id for the file.
    pub file: PathOrId,
}

impl RelinquishFileMembershipArg {
    pub fn new(file: PathOrId) -> Self {
        RelinquishFileMembershipArg {
            file,
        }
    }

}

const RELINQUISH_FILE_MEMBERSHIP_ARG_FIELDS: &'static [&'static str] = &["file"];
impl RelinquishFileMembershipArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RelinquishFileMembershipArg, V::Error> {
        use serde::de;
        let mut field_file = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RELINQUISH_FILE_MEMBERSHIP_ARG_FIELDS))
            }
        }
        Ok(RelinquishFileMembershipArg {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RelinquishFileMembershipArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RelinquishFileMembershipArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelinquishFileMembershipArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RelinquishFileMembershipArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RelinquishFileMembershipArg", RELINQUISH_FILE_MEMBERSHIP_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RelinquishFileMembershipArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RelinquishFileMembershipArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RelinquishFileMembershipError {
    AccessError(SharingFileAccessError),
    /// The current user has access to the shared file via a group.  You can't relinquish membership
    /// to a file shared via groups.
    GroupAccess,
    /// The current user does not have permission to perform this action.
    NoPermission,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RelinquishFileMembershipError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RelinquishFileMembershipError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelinquishFileMembershipError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(RelinquishFileMembershipError::AccessError(map.next_value()?))
                    }
                    "group_access" => Ok(RelinquishFileMembershipError::GroupAccess),
                    "no_permission" => Ok(RelinquishFileMembershipError::NoPermission),
                    _ => Ok(RelinquishFileMembershipError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "group_access",
                                                    "no_permission",
                                                    "other"];
        deserializer.deserialize_struct("RelinquishFileMembershipError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RelinquishFileMembershipError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RelinquishFileMembershipError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            RelinquishFileMembershipError::GroupAccess => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFileMembershipError", 1)?;
                s.serialize_field(".tag", "group_access")?;
                s.end()
            }
            RelinquishFileMembershipError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFileMembershipError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            RelinquishFileMembershipError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RelinquishFileMembershipError {
    fn description(&self) -> &str {
        "RelinquishFileMembershipError"
    }
}

impl ::std::fmt::Display for RelinquishFileMembershipError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RelinquishFolderMembershipArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// Keep a copy of the folder's contents upon relinquishing membership.
    pub leave_a_copy: bool,
}

impl RelinquishFolderMembershipArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        RelinquishFolderMembershipArg {
            shared_folder_id,
            leave_a_copy: false,
        }
    }

    pub fn with_leave_a_copy(mut self, value: bool) -> Self {
        self.leave_a_copy = value;
        self
    }

}

const RELINQUISH_FOLDER_MEMBERSHIP_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                           "leave_a_copy"];
impl RelinquishFolderMembershipArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RelinquishFolderMembershipArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_leave_a_copy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "leave_a_copy" => {
                    if field_leave_a_copy.is_some() {
                        return Err(de::Error::duplicate_field("leave_a_copy"));
                    }
                    field_leave_a_copy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, RELINQUISH_FOLDER_MEMBERSHIP_ARG_FIELDS))
            }
        }
        Ok(RelinquishFolderMembershipArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            leave_a_copy: field_leave_a_copy.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("leave_a_copy", &self.leave_a_copy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RelinquishFolderMembershipArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RelinquishFolderMembershipArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelinquishFolderMembershipArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RelinquishFolderMembershipArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RelinquishFolderMembershipArg", RELINQUISH_FOLDER_MEMBERSHIP_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RelinquishFolderMembershipArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RelinquishFolderMembershipArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RelinquishFolderMembershipError {
    AccessError(SharedFolderAccessError),
    /// The current user is the owner of the shared folder. Owners cannot relinquish membership to
    /// their own folders. Try unsharing or transferring ownership first.
    FolderOwner,
    /// The shared folder is currently mounted.  Unmount the shared folder before relinquishing
    /// membership.
    Mounted,
    /// The current user has access to the shared folder via a group.  You can't relinquish
    /// membership to folders shared via groups.
    GroupAccess,
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    /// The current user does not have permission to perform this action.
    NoPermission,
    /// The current user only has inherited access to the shared folder.  You can't relinquish
    /// inherited membership to folders.
    NoExplicitAccess,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RelinquishFolderMembershipError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RelinquishFolderMembershipError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RelinquishFolderMembershipError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(RelinquishFolderMembershipError::AccessError(map.next_value()?))
                    }
                    "folder_owner" => Ok(RelinquishFolderMembershipError::FolderOwner),
                    "mounted" => Ok(RelinquishFolderMembershipError::Mounted),
                    "group_access" => Ok(RelinquishFolderMembershipError::GroupAccess),
                    "team_folder" => Ok(RelinquishFolderMembershipError::TeamFolder),
                    "no_permission" => Ok(RelinquishFolderMembershipError::NoPermission),
                    "no_explicit_access" => Ok(RelinquishFolderMembershipError::NoExplicitAccess),
                    _ => Ok(RelinquishFolderMembershipError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "folder_owner",
                                                    "mounted",
                                                    "group_access",
                                                    "team_folder",
                                                    "no_permission",
                                                    "no_explicit_access",
                                                    "other"];
        deserializer.deserialize_struct("RelinquishFolderMembershipError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RelinquishFolderMembershipError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RelinquishFolderMembershipError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            RelinquishFolderMembershipError::FolderOwner => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "folder_owner")?;
                s.end()
            }
            RelinquishFolderMembershipError::Mounted => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "mounted")?;
                s.end()
            }
            RelinquishFolderMembershipError::GroupAccess => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "group_access")?;
                s.end()
            }
            RelinquishFolderMembershipError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            RelinquishFolderMembershipError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            RelinquishFolderMembershipError::NoExplicitAccess => {
                // unit
                let mut s = serializer.serialize_struct("RelinquishFolderMembershipError", 1)?;
                s.serialize_field(".tag", "no_explicit_access")?;
                s.end()
            }
            RelinquishFolderMembershipError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RelinquishFolderMembershipError {
    fn description(&self) -> &str {
        "RelinquishFolderMembershipError"
    }
}

impl ::std::fmt::Display for RelinquishFolderMembershipError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Arguments for :route:`remove_file_member_2`.
#[derive(Debug)]
pub struct RemoveFileMemberArg {
    /// File from which to remove members.
    pub file: PathOrId,
    /// Member to remove from this file. Note that even if an email is specified, it may result in
    /// the removal of a user (not an invitee) if the user's main account corresponds to that email
    /// address.
    pub member: MemberSelector,
}

impl RemoveFileMemberArg {
    pub fn new(file: PathOrId, member: MemberSelector) -> Self {
        RemoveFileMemberArg {
            file,
            member,
        }
    }

}

const REMOVE_FILE_MEMBER_ARG_FIELDS: &'static [&'static str] = &["file",
                                                                 "member"];
impl RemoveFileMemberArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RemoveFileMemberArg, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_member = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REMOVE_FILE_MEMBER_ARG_FIELDS))
            }
        }
        Ok(RemoveFileMemberArg {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("member", &self.member)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveFileMemberArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RemoveFileMemberArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveFileMemberArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RemoveFileMemberArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RemoveFileMemberArg", REMOVE_FILE_MEMBER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveFileMemberArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RemoveFileMemberArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors for :route:`remove_file_member_2`.
#[derive(Debug)]
pub enum RemoveFileMemberError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    /// This member does not have explicit access to the file and therefore cannot be removed. The
    /// return value is the access that a user might have to the file from a parent folder.
    NoExplicitAccess(MemberAccessLevelResult),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveFileMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RemoveFileMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveFileMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(RemoveFileMemberError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(RemoveFileMemberError::AccessError(map.next_value()?))
                    }
                    "no_explicit_access" => Ok(RemoveFileMemberError::NoExplicitAccess(MemberAccessLevelResult::internal_deserialize(map)?)),
                    _ => Ok(RemoveFileMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "no_explicit_access",
                                                    "other"];
        deserializer.deserialize_struct("RemoveFileMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveFileMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RemoveFileMemberError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            RemoveFileMemberError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            RemoveFileMemberError::NoExplicitAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("RemoveFileMemberError", 4)?;
                s.serialize_field(".tag", "no_explicit_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            RemoveFileMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RemoveFileMemberError {
    fn description(&self) -> &str {
        "RemoveFileMemberError"
    }
}

impl ::std::fmt::Display for RemoveFileMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RemoveFolderMemberArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// The member to remove from the folder.
    pub member: MemberSelector,
    /// If true, the removed user will keep their copy of the folder after it's unshared, assuming
    /// it was mounted. Otherwise, it will be removed from their Dropbox. Also, this must be set to
    /// false when kicking a group.
    pub leave_a_copy: bool,
}

impl RemoveFolderMemberArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId, member: MemberSelector, leave_a_copy: bool) -> Self {
        RemoveFolderMemberArg {
            shared_folder_id,
            member,
            leave_a_copy,
        }
    }

}

const REMOVE_FOLDER_MEMBER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                   "member",
                                                                   "leave_a_copy"];
impl RemoveFolderMemberArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RemoveFolderMemberArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_member = None;
        let mut field_leave_a_copy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "leave_a_copy" => {
                    if field_leave_a_copy.is_some() {
                        return Err(de::Error::duplicate_field("leave_a_copy"));
                    }
                    field_leave_a_copy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REMOVE_FOLDER_MEMBER_ARG_FIELDS))
            }
        }
        Ok(RemoveFolderMemberArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            leave_a_copy: field_leave_a_copy.ok_or_else(|| de::Error::missing_field("leave_a_copy"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("leave_a_copy", &self.leave_a_copy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveFolderMemberArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RemoveFolderMemberArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveFolderMemberArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RemoveFolderMemberArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RemoveFolderMemberArg", REMOVE_FOLDER_MEMBER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveFolderMemberArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RemoveFolderMemberArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RemoveFolderMemberError {
    AccessError(SharedFolderAccessError),
    MemberError(SharedFolderMemberError),
    /// The target user is the owner of the shared folder. You can't remove this user until
    /// ownership has been transferred to another member.
    FolderOwner,
    /// The target user has access to the shared folder via a group.
    GroupAccess,
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    /// The current user does not have permission to perform this action.
    NoPermission,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveFolderMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RemoveFolderMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveFolderMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(RemoveFolderMemberError::AccessError(map.next_value()?))
                    }
                    "member_error" => {
                        if map.next_key()? != Some("member_error") {
                            return Err(de::Error::missing_field("member_error"));
                        }
                        Ok(RemoveFolderMemberError::MemberError(map.next_value()?))
                    }
                    "folder_owner" => Ok(RemoveFolderMemberError::FolderOwner),
                    "group_access" => Ok(RemoveFolderMemberError::GroupAccess),
                    "team_folder" => Ok(RemoveFolderMemberError::TeamFolder),
                    "no_permission" => Ok(RemoveFolderMemberError::NoPermission),
                    _ => Ok(RemoveFolderMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "member_error",
                                                    "folder_owner",
                                                    "group_access",
                                                    "team_folder",
                                                    "no_permission",
                                                    "other"];
        deserializer.deserialize_struct("RemoveFolderMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveFolderMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RemoveFolderMemberError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            RemoveFolderMemberError::MemberError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "member_error")?;
                s.serialize_field("member_error", x)?;
                s.end()
            }
            RemoveFolderMemberError::FolderOwner => {
                // unit
                let mut s = serializer.serialize_struct("RemoveFolderMemberError", 1)?;
                s.serialize_field(".tag", "folder_owner")?;
                s.end()
            }
            RemoveFolderMemberError::GroupAccess => {
                // unit
                let mut s = serializer.serialize_struct("RemoveFolderMemberError", 1)?;
                s.serialize_field(".tag", "group_access")?;
                s.end()
            }
            RemoveFolderMemberError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("RemoveFolderMemberError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            RemoveFolderMemberError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("RemoveFolderMemberError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            RemoveFolderMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RemoveFolderMemberError {
    fn description(&self) -> &str {
        "RemoveFolderMemberError"
    }
}

impl ::std::fmt::Display for RemoveFolderMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum RemoveMemberJobStatus {
    /// The asynchronous job is still in progress.
    InProgress,
    /// Removing the folder member has finished. The value is information about whether the member
    /// has another form of access.
    Complete(MemberAccessLevelResult),
    Failed(RemoveFolderMemberError),
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveMemberJobStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RemoveMemberJobStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveMemberJobStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "in_progress" => Ok(RemoveMemberJobStatus::InProgress),
                    "complete" => Ok(RemoveMemberJobStatus::Complete(MemberAccessLevelResult::internal_deserialize(map)?)),
                    "failed" => {
                        if map.next_key()? != Some("failed") {
                            return Err(de::Error::missing_field("failed"));
                        }
                        Ok(RemoveMemberJobStatus::Failed(map.next_value()?))
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["in_progress",
                                                    "complete",
                                                    "failed"];
        deserializer.deserialize_struct("RemoveMemberJobStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveMemberJobStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RemoveMemberJobStatus::InProgress => {
                // unit
                let mut s = serializer.serialize_struct("RemoveMemberJobStatus", 1)?;
                s.serialize_field(".tag", "in_progress")?;
                s.end()
            }
            RemoveMemberJobStatus::Complete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("RemoveMemberJobStatus", 4)?;
                s.serialize_field(".tag", "complete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            RemoveMemberJobStatus::Failed(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "failed")?;
                s.serialize_field("failed", x)?;
                s.end()
            }
        }
    }
}

/// The access permission that can be requested by the caller for the shared link. Note that the
/// final resolved visibility of the shared link takes into account other aspects, such as team and
/// shared folder settings. Check the :type:`ResolvedVisibility` for more info on the possible
/// resolved visibility values of shared links.
#[derive(Debug)]
pub enum RequestedVisibility {
    /// Anyone who has received the link can access it. No login required.
    Public,
    /// Only members of the same team can access the link. Login is required.
    TeamOnly,
    /// A link-specific password is required to access the link. Login is not required.
    Password,
}

impl<'de> ::serde::de::Deserialize<'de> for RequestedVisibility {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RequestedVisibility;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RequestedVisibility structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "public" => Ok(RequestedVisibility::Public),
                    "team_only" => Ok(RequestedVisibility::TeamOnly),
                    "password" => Ok(RequestedVisibility::Password),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["public",
                                                    "team_only",
                                                    "password"];
        deserializer.deserialize_struct("RequestedVisibility", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RequestedVisibility {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RequestedVisibility::Public => {
                // unit
                let mut s = serializer.serialize_struct("RequestedVisibility", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            RequestedVisibility::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("RequestedVisibility", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            RequestedVisibility::Password => {
                // unit
                let mut s = serializer.serialize_struct("RequestedVisibility", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
        }
    }
}

/// The actual access permissions values of shared links after taking into account user preferences
/// and the team and shared folder settings. Check the :type:`RequestedVisibility` for more info on
/// the possible visibility values that can be set by the shared link's owner.
#[derive(Debug)]
pub enum ResolvedVisibility {
    /// Anyone who has received the link can access it. No login required.
    Public,
    /// Only members of the same team can access the link. Login is required.
    TeamOnly,
    /// A link-specific password is required to access the link. Login is not required.
    Password,
    /// Only members of the same team who have the link-specific password can access the link. Login
    /// is required.
    TeamAndPassword,
    /// Only members of the shared folder containing the linked file can access the link. Login is
    /// required.
    SharedFolderOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ResolvedVisibility {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ResolvedVisibility;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ResolvedVisibility structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "public" => Ok(ResolvedVisibility::Public),
                    "team_only" => Ok(ResolvedVisibility::TeamOnly),
                    "password" => Ok(ResolvedVisibility::Password),
                    "team_and_password" => Ok(ResolvedVisibility::TeamAndPassword),
                    "shared_folder_only" => Ok(ResolvedVisibility::SharedFolderOnly),
                    _ => Ok(ResolvedVisibility::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["public",
                                                    "team_only",
                                                    "password",
                                                    "team_and_password",
                                                    "shared_folder_only",
                                                    "other"];
        deserializer.deserialize_struct("ResolvedVisibility", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ResolvedVisibility {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ResolvedVisibility::Public => {
                // unit
                let mut s = serializer.serialize_struct("ResolvedVisibility", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            ResolvedVisibility::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("ResolvedVisibility", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            ResolvedVisibility::Password => {
                // unit
                let mut s = serializer.serialize_struct("ResolvedVisibility", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            ResolvedVisibility::TeamAndPassword => {
                // unit
                let mut s = serializer.serialize_struct("ResolvedVisibility", 1)?;
                s.serialize_field(".tag", "team_and_password")?;
                s.end()
            }
            ResolvedVisibility::SharedFolderOnly => {
                // unit
                let mut s = serializer.serialize_struct("ResolvedVisibility", 1)?;
                s.serialize_field(".tag", "shared_folder_only")?;
                s.end()
            }
            ResolvedVisibility::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct RevokeSharedLinkArg {
    /// URL of the shared link.
    pub url: String,
}

impl RevokeSharedLinkArg {
    pub fn new(url: String) -> Self {
        RevokeSharedLinkArg {
            url,
        }
    }

}

const REVOKE_SHARED_LINK_ARG_FIELDS: &'static [&'static str] = &["url"];
impl RevokeSharedLinkArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<RevokeSharedLinkArg, V::Error> {
        use serde::de;
        let mut field_url = None;
        while let Some(key) = map.next_key()? {
            match key {
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_SHARED_LINK_ARG_FIELDS))
            }
        }
        Ok(RevokeSharedLinkArg {
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("url", &self.url)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeSharedLinkArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeSharedLinkArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeSharedLinkArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeSharedLinkArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeSharedLinkArg", REVOKE_SHARED_LINK_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeSharedLinkArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeSharedLinkArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RevokeSharedLinkError {
    /// The shared link wasn't found.
    SharedLinkNotFound,
    /// The caller is not allowed to access this shared link.
    SharedLinkAccessDenied,
    /// This type of link is not supported.
    UnsupportedLinkType,
    Other,
    /// Shared link is malformed.
    SharedLinkMalformed,
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeSharedLinkError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeSharedLinkError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeSharedLinkError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "shared_link_not_found" => Ok(RevokeSharedLinkError::SharedLinkNotFound),
                    "shared_link_access_denied" => Ok(RevokeSharedLinkError::SharedLinkAccessDenied),
                    "unsupported_link_type" => Ok(RevokeSharedLinkError::UnsupportedLinkType),
                    "shared_link_malformed" => Ok(RevokeSharedLinkError::SharedLinkMalformed),
                    _ => Ok(RevokeSharedLinkError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["shared_link_not_found",
                                                    "shared_link_access_denied",
                                                    "unsupported_link_type",
                                                    "other",
                                                    "shared_link_malformed"];
        deserializer.deserialize_struct("RevokeSharedLinkError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeSharedLinkError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RevokeSharedLinkError::SharedLinkNotFound => {
                // unit
                let mut s = serializer.serialize_struct("RevokeSharedLinkError", 1)?;
                s.serialize_field(".tag", "shared_link_not_found")?;
                s.end()
            }
            RevokeSharedLinkError::SharedLinkAccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("RevokeSharedLinkError", 1)?;
                s.serialize_field(".tag", "shared_link_access_denied")?;
                s.end()
            }
            RevokeSharedLinkError::UnsupportedLinkType => {
                // unit
                let mut s = serializer.serialize_struct("RevokeSharedLinkError", 1)?;
                s.serialize_field(".tag", "unsupported_link_type")?;
                s.end()
            }
            RevokeSharedLinkError::SharedLinkMalformed => {
                // unit
                let mut s = serializer.serialize_struct("RevokeSharedLinkError", 1)?;
                s.serialize_field(".tag", "shared_link_malformed")?;
                s.end()
            }
            RevokeSharedLinkError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RevokeSharedLinkError {
    fn description(&self) -> &str {
        "RevokeSharedLinkError"
    }
}

impl ::std::fmt::Display for RevokeSharedLinkError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ShareFolderArg {
    /// The path to the folder to share. If it does not exist, then a new one is created.
    pub path: super::files::WritePath,
    /// Who can add and remove members of this shared folder.
    pub acl_update_policy: Option<AclUpdatePolicy>,
    /// Whether to force the share to happen asynchronously.
    pub force_async: bool,
    /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
    pub member_policy: Option<MemberPolicy>,
    /// The policy to apply to shared links created for content inside this shared folder.  The
    /// current user must be on a team to set this policy to :field:`SharedLinkPolicy.members`.
    pub shared_link_policy: Option<SharedLinkPolicy>,
    /// Who can enable/disable viewer info for this shared folder.
    pub viewer_info_policy: Option<ViewerInfoPolicy>,
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's :field:`SharedFolderMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the folder.
    pub actions: Option<Vec<FolderAction>>,
    /// Settings on the link for this folder.
    pub link_settings: Option<LinkSettings>,
}

impl ShareFolderArg {
    pub fn new(path: super::files::WritePath) -> Self {
        ShareFolderArg {
            path,
            acl_update_policy: None,
            force_async: false,
            member_policy: None,
            shared_link_policy: None,
            viewer_info_policy: None,
            actions: None,
            link_settings: None,
        }
    }

    pub fn with_acl_update_policy(mut self, value: Option<AclUpdatePolicy>) -> Self {
        self.acl_update_policy = value;
        self
    }

    pub fn with_force_async(mut self, value: bool) -> Self {
        self.force_async = value;
        self
    }

    pub fn with_member_policy(mut self, value: Option<MemberPolicy>) -> Self {
        self.member_policy = value;
        self
    }

    pub fn with_shared_link_policy(mut self, value: Option<SharedLinkPolicy>) -> Self {
        self.shared_link_policy = value;
        self
    }

    pub fn with_viewer_info_policy(mut self, value: Option<ViewerInfoPolicy>) -> Self {
        self.viewer_info_policy = value;
        self
    }

    pub fn with_actions(mut self, value: Option<Vec<FolderAction>>) -> Self {
        self.actions = value;
        self
    }

    pub fn with_link_settings(mut self, value: Option<LinkSettings>) -> Self {
        self.link_settings = value;
        self
    }

}

const SHARE_FOLDER_ARG_FIELDS: &'static [&'static str] = &["path",
                                                           "acl_update_policy",
                                                           "force_async",
                                                           "member_policy",
                                                           "shared_link_policy",
                                                           "viewer_info_policy",
                                                           "actions",
                                                           "link_settings"];
impl ShareFolderArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShareFolderArg, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_acl_update_policy = None;
        let mut field_force_async = None;
        let mut field_member_policy = None;
        let mut field_shared_link_policy = None;
        let mut field_viewer_info_policy = None;
        let mut field_actions = None;
        let mut field_link_settings = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "acl_update_policy" => {
                    if field_acl_update_policy.is_some() {
                        return Err(de::Error::duplicate_field("acl_update_policy"));
                    }
                    field_acl_update_policy = Some(map.next_value()?);
                }
                "force_async" => {
                    if field_force_async.is_some() {
                        return Err(de::Error::duplicate_field("force_async"));
                    }
                    field_force_async = Some(map.next_value()?);
                }
                "member_policy" => {
                    if field_member_policy.is_some() {
                        return Err(de::Error::duplicate_field("member_policy"));
                    }
                    field_member_policy = Some(map.next_value()?);
                }
                "shared_link_policy" => {
                    if field_shared_link_policy.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_policy"));
                    }
                    field_shared_link_policy = Some(map.next_value()?);
                }
                "viewer_info_policy" => {
                    if field_viewer_info_policy.is_some() {
                        return Err(de::Error::duplicate_field("viewer_info_policy"));
                    }
                    field_viewer_info_policy = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                "link_settings" => {
                    if field_link_settings.is_some() {
                        return Err(de::Error::duplicate_field("link_settings"));
                    }
                    field_link_settings = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARE_FOLDER_ARG_FIELDS))
            }
        }
        Ok(ShareFolderArg {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            acl_update_policy: field_acl_update_policy,
            force_async: field_force_async.unwrap_or(false),
            member_policy: field_member_policy,
            shared_link_policy: field_shared_link_policy,
            viewer_info_policy: field_viewer_info_policy,
            actions: field_actions,
            link_settings: field_link_settings,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("acl_update_policy", &self.acl_update_policy)?;
        s.serialize_field("force_async", &self.force_async)?;
        s.serialize_field("member_policy", &self.member_policy)?;
        s.serialize_field("shared_link_policy", &self.shared_link_policy)?;
        s.serialize_field("viewer_info_policy", &self.viewer_info_policy)?;
        s.serialize_field("actions", &self.actions)?;
        s.serialize_field("link_settings", &self.link_settings)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShareFolderArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShareFolderArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShareFolderArg", SHARE_FOLDER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShareFolderArg", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShareFolderArgBase {
    /// The path to the folder to share. If it does not exist, then a new one is created.
    pub path: super::files::WritePath,
    /// Who can add and remove members of this shared folder.
    pub acl_update_policy: Option<AclUpdatePolicy>,
    /// Whether to force the share to happen asynchronously.
    pub force_async: bool,
    /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
    pub member_policy: Option<MemberPolicy>,
    /// The policy to apply to shared links created for content inside this shared folder.  The
    /// current user must be on a team to set this policy to :field:`SharedLinkPolicy.members`.
    pub shared_link_policy: Option<SharedLinkPolicy>,
    /// Who can enable/disable viewer info for this shared folder.
    pub viewer_info_policy: Option<ViewerInfoPolicy>,
}

impl ShareFolderArgBase {
    pub fn new(path: super::files::WritePath) -> Self {
        ShareFolderArgBase {
            path,
            acl_update_policy: None,
            force_async: false,
            member_policy: None,
            shared_link_policy: None,
            viewer_info_policy: None,
        }
    }

    pub fn with_acl_update_policy(mut self, value: Option<AclUpdatePolicy>) -> Self {
        self.acl_update_policy = value;
        self
    }

    pub fn with_force_async(mut self, value: bool) -> Self {
        self.force_async = value;
        self
    }

    pub fn with_member_policy(mut self, value: Option<MemberPolicy>) -> Self {
        self.member_policy = value;
        self
    }

    pub fn with_shared_link_policy(mut self, value: Option<SharedLinkPolicy>) -> Self {
        self.shared_link_policy = value;
        self
    }

    pub fn with_viewer_info_policy(mut self, value: Option<ViewerInfoPolicy>) -> Self {
        self.viewer_info_policy = value;
        self
    }

}

const SHARE_FOLDER_ARG_BASE_FIELDS: &'static [&'static str] = &["path",
                                                                "acl_update_policy",
                                                                "force_async",
                                                                "member_policy",
                                                                "shared_link_policy",
                                                                "viewer_info_policy"];
impl ShareFolderArgBase {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<ShareFolderArgBase, V::Error> {
        use serde::de;
        let mut field_path = None;
        let mut field_acl_update_policy = None;
        let mut field_force_async = None;
        let mut field_member_policy = None;
        let mut field_shared_link_policy = None;
        let mut field_viewer_info_policy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "acl_update_policy" => {
                    if field_acl_update_policy.is_some() {
                        return Err(de::Error::duplicate_field("acl_update_policy"));
                    }
                    field_acl_update_policy = Some(map.next_value()?);
                }
                "force_async" => {
                    if field_force_async.is_some() {
                        return Err(de::Error::duplicate_field("force_async"));
                    }
                    field_force_async = Some(map.next_value()?);
                }
                "member_policy" => {
                    if field_member_policy.is_some() {
                        return Err(de::Error::duplicate_field("member_policy"));
                    }
                    field_member_policy = Some(map.next_value()?);
                }
                "shared_link_policy" => {
                    if field_shared_link_policy.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_policy"));
                    }
                    field_shared_link_policy = Some(map.next_value()?);
                }
                "viewer_info_policy" => {
                    if field_viewer_info_policy.is_some() {
                        return Err(de::Error::duplicate_field("viewer_info_policy"));
                    }
                    field_viewer_info_policy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARE_FOLDER_ARG_BASE_FIELDS))
            }
        }
        Ok(ShareFolderArgBase {
            path: field_path.ok_or_else(|| de::Error::missing_field("path"))?,
            acl_update_policy: field_acl_update_policy,
            force_async: field_force_async.unwrap_or(false),
            member_policy: field_member_policy,
            shared_link_policy: field_shared_link_policy,
            viewer_info_policy: field_viewer_info_policy,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("acl_update_policy", &self.acl_update_policy)?;
        s.serialize_field("force_async", &self.force_async)?;
        s.serialize_field("member_policy", &self.member_policy)?;
        s.serialize_field("shared_link_policy", &self.shared_link_policy)?;
        s.serialize_field("viewer_info_policy", &self.viewer_info_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderArgBase {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShareFolderArgBase;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderArgBase struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShareFolderArgBase::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShareFolderArgBase", SHARE_FOLDER_ARG_BASE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderArgBase {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShareFolderArgBase", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ShareFolderError {
    /// The current user's e-mail address is unverified.
    EmailUnverified,
    /// :field:`ShareFolderArg.path` is invalid.
    BadPath(SharePathError),
    /// Team policy is more restrictive than :field:`ShareFolderArg.member_policy`.
    TeamPolicyDisallowsMemberPolicy,
    /// The current user's account is not allowed to select the specified
    /// :field:`ShareFolderArg.shared_link_policy`.
    DisallowedSharedLinkPolicy,
    Other,
    /// The current user does not have permission to perform this action.
    NoPermission,
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShareFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email_unverified" => Ok(ShareFolderError::EmailUnverified),
                    "bad_path" => {
                        if map.next_key()? != Some("bad_path") {
                            return Err(de::Error::missing_field("bad_path"));
                        }
                        Ok(ShareFolderError::BadPath(map.next_value()?))
                    }
                    "team_policy_disallows_member_policy" => Ok(ShareFolderError::TeamPolicyDisallowsMemberPolicy),
                    "disallowed_shared_link_policy" => Ok(ShareFolderError::DisallowedSharedLinkPolicy),
                    "no_permission" => Ok(ShareFolderError::NoPermission),
                    _ => Ok(ShareFolderError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["email_unverified",
                                                    "bad_path",
                                                    "team_policy_disallows_member_policy",
                                                    "disallowed_shared_link_policy",
                                                    "other",
                                                    "no_permission"];
        deserializer.deserialize_struct("ShareFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShareFolderError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            ShareFolderError::BadPath(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "bad_path")?;
                s.serialize_field("bad_path", x)?;
                s.end()
            }
            ShareFolderError::TeamPolicyDisallowsMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderError", 1)?;
                s.serialize_field(".tag", "team_policy_disallows_member_policy")?;
                s.end()
            }
            ShareFolderError::DisallowedSharedLinkPolicy => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderError", 1)?;
                s.serialize_field(".tag", "disallowed_shared_link_policy")?;
                s.end()
            }
            ShareFolderError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            ShareFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ShareFolderError {
    fn description(&self) -> &str {
        "ShareFolderError"
    }
}

impl ::std::fmt::Display for ShareFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum ShareFolderErrorBase {
    /// The current user's e-mail address is unverified.
    EmailUnverified,
    /// :field:`ShareFolderArg.path` is invalid.
    BadPath(SharePathError),
    /// Team policy is more restrictive than :field:`ShareFolderArg.member_policy`.
    TeamPolicyDisallowsMemberPolicy,
    /// The current user's account is not allowed to select the specified
    /// :field:`ShareFolderArg.shared_link_policy`.
    DisallowedSharedLinkPolicy,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderErrorBase {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShareFolderErrorBase;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderErrorBase structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email_unverified" => Ok(ShareFolderErrorBase::EmailUnverified),
                    "bad_path" => {
                        if map.next_key()? != Some("bad_path") {
                            return Err(de::Error::missing_field("bad_path"));
                        }
                        Ok(ShareFolderErrorBase::BadPath(map.next_value()?))
                    }
                    "team_policy_disallows_member_policy" => Ok(ShareFolderErrorBase::TeamPolicyDisallowsMemberPolicy),
                    "disallowed_shared_link_policy" => Ok(ShareFolderErrorBase::DisallowedSharedLinkPolicy),
                    _ => Ok(ShareFolderErrorBase::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["email_unverified",
                                                    "bad_path",
                                                    "team_policy_disallows_member_policy",
                                                    "disallowed_shared_link_policy",
                                                    "other"];
        deserializer.deserialize_struct("ShareFolderErrorBase", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderErrorBase {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShareFolderErrorBase::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderErrorBase", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            ShareFolderErrorBase::BadPath(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "bad_path")?;
                s.serialize_field("bad_path", x)?;
                s.end()
            }
            ShareFolderErrorBase::TeamPolicyDisallowsMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderErrorBase", 1)?;
                s.serialize_field(".tag", "team_policy_disallows_member_policy")?;
                s.end()
            }
            ShareFolderErrorBase::DisallowedSharedLinkPolicy => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderErrorBase", 1)?;
                s.serialize_field(".tag", "disallowed_shared_link_policy")?;
                s.end()
            }
            ShareFolderErrorBase::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum ShareFolderJobStatus {
    /// The asynchronous job is still in progress.
    InProgress,
    /// The share job has finished. The value is the metadata for the folder.
    Complete(SharedFolderMetadata),
    Failed(ShareFolderError),
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderJobStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShareFolderJobStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderJobStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "in_progress" => Ok(ShareFolderJobStatus::InProgress),
                    "complete" => Ok(ShareFolderJobStatus::Complete(SharedFolderMetadata::internal_deserialize(map)?)),
                    "failed" => {
                        if map.next_key()? != Some("failed") {
                            return Err(de::Error::missing_field("failed"));
                        }
                        Ok(ShareFolderJobStatus::Failed(map.next_value()?))
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["in_progress",
                                                    "complete",
                                                    "failed"];
        deserializer.deserialize_struct("ShareFolderJobStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderJobStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShareFolderJobStatus::InProgress => {
                // unit
                let mut s = serializer.serialize_struct("ShareFolderJobStatus", 1)?;
                s.serialize_field(".tag", "in_progress")?;
                s.end()
            }
            ShareFolderJobStatus::Complete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ShareFolderJobStatus", 15)?;
                s.serialize_field(".tag", "complete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ShareFolderJobStatus::Failed(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "failed")?;
                s.serialize_field("failed", x)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub enum ShareFolderLaunch {
    /// This response indicates that the processing is asynchronous. The string is an id that can be
    /// used to obtain the status of the asynchronous job.
    AsyncJobId(super::async::AsyncJobId),
    Complete(SharedFolderMetadata),
}

impl<'de> ::serde::de::Deserialize<'de> for ShareFolderLaunch {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShareFolderLaunch;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ShareFolderLaunch structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "async_job_id" => {
                        if map.next_key()? != Some("async_job_id") {
                            return Err(de::Error::missing_field("async_job_id"));
                        }
                        Ok(ShareFolderLaunch::AsyncJobId(map.next_value()?))
                    }
                    "complete" => Ok(ShareFolderLaunch::Complete(SharedFolderMetadata::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["async_job_id",
                                                    "complete"];
        deserializer.deserialize_struct("ShareFolderLaunch", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShareFolderLaunch {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShareFolderLaunch::AsyncJobId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "async_job_id")?;
                s.serialize_field("async_job_id", x)?;
                s.end()
            }
            ShareFolderLaunch::Complete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ShareFolderLaunch", 15)?;
                s.serialize_field(".tag", "complete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub enum SharePathError {
    /// A file is at the specified path.
    IsFile,
    /// We do not support sharing a folder inside a shared folder.
    InsideSharedFolder,
    /// We do not support shared folders that contain shared folders.
    ContainsSharedFolder,
    /// We do not support shared folders that contain app folders.
    ContainsAppFolder,
    /// We do not support shared folders that contain team folders.
    ContainsTeamFolder,
    /// We do not support sharing an app folder.
    IsAppFolder,
    /// We do not support sharing a folder inside an app folder.
    InsideAppFolder,
    /// A public folder can't be shared this way. Use a public link instead.
    IsPublicFolder,
    /// A folder inside a public folder can't be shared this way. Use a public link instead.
    InsidePublicFolder,
    /// Folder is already shared. Contains metadata about the existing shared folder.
    AlreadyShared(SharedFolderMetadata),
    /// Path is not valid.
    InvalidPath,
    /// We do not support sharing a Mac OS X package.
    IsOsxPackage,
    /// We do not support sharing a folder inside a Mac OS X package.
    InsideOsxPackage,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharePathError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharePathError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharePathError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "is_file" => Ok(SharePathError::IsFile),
                    "inside_shared_folder" => Ok(SharePathError::InsideSharedFolder),
                    "contains_shared_folder" => Ok(SharePathError::ContainsSharedFolder),
                    "contains_app_folder" => Ok(SharePathError::ContainsAppFolder),
                    "contains_team_folder" => Ok(SharePathError::ContainsTeamFolder),
                    "is_app_folder" => Ok(SharePathError::IsAppFolder),
                    "inside_app_folder" => Ok(SharePathError::InsideAppFolder),
                    "is_public_folder" => Ok(SharePathError::IsPublicFolder),
                    "inside_public_folder" => Ok(SharePathError::InsidePublicFolder),
                    "already_shared" => Ok(SharePathError::AlreadyShared(SharedFolderMetadata::internal_deserialize(map)?)),
                    "invalid_path" => Ok(SharePathError::InvalidPath),
                    "is_osx_package" => Ok(SharePathError::IsOsxPackage),
                    "inside_osx_package" => Ok(SharePathError::InsideOsxPackage),
                    _ => Ok(SharePathError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["is_file",
                                                    "inside_shared_folder",
                                                    "contains_shared_folder",
                                                    "contains_app_folder",
                                                    "contains_team_folder",
                                                    "is_app_folder",
                                                    "inside_app_folder",
                                                    "is_public_folder",
                                                    "inside_public_folder",
                                                    "already_shared",
                                                    "invalid_path",
                                                    "is_osx_package",
                                                    "inside_osx_package",
                                                    "other"];
        deserializer.deserialize_struct("SharePathError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharePathError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharePathError::IsFile => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "is_file")?;
                s.end()
            }
            SharePathError::InsideSharedFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "inside_shared_folder")?;
                s.end()
            }
            SharePathError::ContainsSharedFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "contains_shared_folder")?;
                s.end()
            }
            SharePathError::ContainsAppFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "contains_app_folder")?;
                s.end()
            }
            SharePathError::ContainsTeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "contains_team_folder")?;
                s.end()
            }
            SharePathError::IsAppFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "is_app_folder")?;
                s.end()
            }
            SharePathError::InsideAppFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "inside_app_folder")?;
                s.end()
            }
            SharePathError::IsPublicFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "is_public_folder")?;
                s.end()
            }
            SharePathError::InsidePublicFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "inside_public_folder")?;
                s.end()
            }
            SharePathError::AlreadyShared(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("SharePathError", 15)?;
                s.serialize_field(".tag", "already_shared")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            SharePathError::InvalidPath => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "invalid_path")?;
                s.end()
            }
            SharePathError::IsOsxPackage => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "is_osx_package")?;
                s.end()
            }
            SharePathError::InsideOsxPackage => {
                // unit
                let mut s = serializer.serialize_struct("SharePathError", 1)?;
                s.serialize_field(".tag", "inside_osx_package")?;
                s.end()
            }
            SharePathError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharePathError {
    fn description(&self) -> &str {
        "SharePathError"
    }
}

impl ::std::fmt::Display for SharePathError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Metadata of a shared link for a file or folder.
#[derive(Debug)]
pub struct SharedContentLinkMetadata {
    /// The audience options that are available for the content. Some audience options may be
    /// unavailable. For example, team_only may be unavailable if the content is not owned by a user
    /// on a team. The 'default' audience option is always available if the user can modify link
    /// settings.
    pub audience_options: Vec<LinkAudience>,
    /// The current audience of the link.
    pub current_audience: LinkAudience,
    /// A list of permissions for actions you can perform on the link.
    pub link_permissions: Vec<LinkPermission>,
    /// Whether the link is protected by a password.
    pub password_protected: bool,
    /// The URL of the link.
    pub url: String,
    /// The access level on the link for this file.
    pub access_level: Option<AccessLevel>,
    /// The shared folder that prevents the link audience for this link from being more restrictive.
    pub audience_restricting_shared_folder: Option<AudienceRestrictingSharedFolder>,
    /// Whether the link has an expiry set on it. A link with an expiry will have its  audience
    /// changed to members when the expiry is reached.
    pub expiry: Option<super::common::DropboxTimestamp>,
    /// The content inside this folder with link audience different than this folder's. This is only
    /// returned when an endpoint that returns metadata for a single shared folder is called, e.g.
    /// /get_folder_metadata.
    pub audience_exceptions: Option<AudienceExceptions>,
}

impl SharedContentLinkMetadata {
    pub fn new(audience_options: Vec<LinkAudience>, current_audience: LinkAudience, link_permissions: Vec<LinkPermission>, password_protected: bool, url: String) -> Self {
        SharedContentLinkMetadata {
            audience_options,
            current_audience,
            link_permissions,
            password_protected,
            url,
            access_level: None,
            audience_restricting_shared_folder: None,
            expiry: None,
            audience_exceptions: None,
        }
    }

    pub fn with_access_level(mut self, value: Option<AccessLevel>) -> Self {
        self.access_level = value;
        self
    }

    pub fn with_audience_restricting_shared_folder(mut self, value: Option<AudienceRestrictingSharedFolder>) -> Self {
        self.audience_restricting_shared_folder = value;
        self
    }

    pub fn with_expiry(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expiry = value;
        self
    }

    pub fn with_audience_exceptions(mut self, value: Option<AudienceExceptions>) -> Self {
        self.audience_exceptions = value;
        self
    }

}

const SHARED_CONTENT_LINK_METADATA_FIELDS: &'static [&'static str] = &["audience_options",
                                                                       "current_audience",
                                                                       "link_permissions",
                                                                       "password_protected",
                                                                       "url",
                                                                       "access_level",
                                                                       "audience_restricting_shared_folder",
                                                                       "expiry",
                                                                       "audience_exceptions"];
impl SharedContentLinkMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentLinkMetadata, V::Error> {
        use serde::de;
        let mut field_audience_options = None;
        let mut field_current_audience = None;
        let mut field_link_permissions = None;
        let mut field_password_protected = None;
        let mut field_url = None;
        let mut field_access_level = None;
        let mut field_audience_restricting_shared_folder = None;
        let mut field_expiry = None;
        let mut field_audience_exceptions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "audience_options" => {
                    if field_audience_options.is_some() {
                        return Err(de::Error::duplicate_field("audience_options"));
                    }
                    field_audience_options = Some(map.next_value()?);
                }
                "current_audience" => {
                    if field_current_audience.is_some() {
                        return Err(de::Error::duplicate_field("current_audience"));
                    }
                    field_current_audience = Some(map.next_value()?);
                }
                "link_permissions" => {
                    if field_link_permissions.is_some() {
                        return Err(de::Error::duplicate_field("link_permissions"));
                    }
                    field_link_permissions = Some(map.next_value()?);
                }
                "password_protected" => {
                    if field_password_protected.is_some() {
                        return Err(de::Error::duplicate_field("password_protected"));
                    }
                    field_password_protected = Some(map.next_value()?);
                }
                "url" => {
                    if field_url.is_some() {
                        return Err(de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "audience_restricting_shared_folder" => {
                    if field_audience_restricting_shared_folder.is_some() {
                        return Err(de::Error::duplicate_field("audience_restricting_shared_folder"));
                    }
                    field_audience_restricting_shared_folder = Some(map.next_value()?);
                }
                "expiry" => {
                    if field_expiry.is_some() {
                        return Err(de::Error::duplicate_field("expiry"));
                    }
                    field_expiry = Some(map.next_value()?);
                }
                "audience_exceptions" => {
                    if field_audience_exceptions.is_some() {
                        return Err(de::Error::duplicate_field("audience_exceptions"));
                    }
                    field_audience_exceptions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_LINK_METADATA_FIELDS))
            }
        }
        Ok(SharedContentLinkMetadata {
            audience_options: field_audience_options.ok_or_else(|| de::Error::missing_field("audience_options"))?,
            current_audience: field_current_audience.ok_or_else(|| de::Error::missing_field("current_audience"))?,
            link_permissions: field_link_permissions.ok_or_else(|| de::Error::missing_field("link_permissions"))?,
            password_protected: field_password_protected.ok_or_else(|| de::Error::missing_field("password_protected"))?,
            url: field_url.ok_or_else(|| de::Error::missing_field("url"))?,
            access_level: field_access_level,
            audience_restricting_shared_folder: field_audience_restricting_shared_folder,
            expiry: field_expiry,
            audience_exceptions: field_audience_exceptions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("audience_options", &self.audience_options)?;
        s.serialize_field("current_audience", &self.current_audience)?;
        s.serialize_field("link_permissions", &self.link_permissions)?;
        s.serialize_field("password_protected", &self.password_protected)?;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("audience_restricting_shared_folder", &self.audience_restricting_shared_folder)?;
        s.serialize_field("expiry", &self.expiry)?;
        s.serialize_field("audience_exceptions", &self.audience_exceptions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentLinkMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentLinkMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentLinkMetadata", SHARED_CONTENT_LINK_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentLinkMetadata", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentLinkMetadataBase {
    /// The audience options that are available for the content. Some audience options may be
    /// unavailable. For example, team_only may be unavailable if the content is not owned by a user
    /// on a team. The 'default' audience option is always available if the user can modify link
    /// settings.
    pub audience_options: Vec<LinkAudience>,
    /// The current audience of the link.
    pub current_audience: LinkAudience,
    /// A list of permissions for actions you can perform on the link.
    pub link_permissions: Vec<LinkPermission>,
    /// Whether the link is protected by a password.
    pub password_protected: bool,
    /// The access level on the link for this file.
    pub access_level: Option<AccessLevel>,
    /// The shared folder that prevents the link audience for this link from being more restrictive.
    pub audience_restricting_shared_folder: Option<AudienceRestrictingSharedFolder>,
    /// Whether the link has an expiry set on it. A link with an expiry will have its  audience
    /// changed to members when the expiry is reached.
    pub expiry: Option<super::common::DropboxTimestamp>,
}

impl SharedContentLinkMetadataBase {
    pub fn new(audience_options: Vec<LinkAudience>, current_audience: LinkAudience, link_permissions: Vec<LinkPermission>, password_protected: bool) -> Self {
        SharedContentLinkMetadataBase {
            audience_options,
            current_audience,
            link_permissions,
            password_protected,
            access_level: None,
            audience_restricting_shared_folder: None,
            expiry: None,
        }
    }

    pub fn with_access_level(mut self, value: Option<AccessLevel>) -> Self {
        self.access_level = value;
        self
    }

    pub fn with_audience_restricting_shared_folder(mut self, value: Option<AudienceRestrictingSharedFolder>) -> Self {
        self.audience_restricting_shared_folder = value;
        self
    }

    pub fn with_expiry(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expiry = value;
        self
    }

}

const SHARED_CONTENT_LINK_METADATA_BASE_FIELDS: &'static [&'static str] = &["audience_options",
                                                                            "current_audience",
                                                                            "link_permissions",
                                                                            "password_protected",
                                                                            "access_level",
                                                                            "audience_restricting_shared_folder",
                                                                            "expiry"];
impl SharedContentLinkMetadataBase {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedContentLinkMetadataBase, V::Error> {
        use serde::de;
        let mut field_audience_options = None;
        let mut field_current_audience = None;
        let mut field_link_permissions = None;
        let mut field_password_protected = None;
        let mut field_access_level = None;
        let mut field_audience_restricting_shared_folder = None;
        let mut field_expiry = None;
        while let Some(key) = map.next_key()? {
            match key {
                "audience_options" => {
                    if field_audience_options.is_some() {
                        return Err(de::Error::duplicate_field("audience_options"));
                    }
                    field_audience_options = Some(map.next_value()?);
                }
                "current_audience" => {
                    if field_current_audience.is_some() {
                        return Err(de::Error::duplicate_field("current_audience"));
                    }
                    field_current_audience = Some(map.next_value()?);
                }
                "link_permissions" => {
                    if field_link_permissions.is_some() {
                        return Err(de::Error::duplicate_field("link_permissions"));
                    }
                    field_link_permissions = Some(map.next_value()?);
                }
                "password_protected" => {
                    if field_password_protected.is_some() {
                        return Err(de::Error::duplicate_field("password_protected"));
                    }
                    field_password_protected = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                "audience_restricting_shared_folder" => {
                    if field_audience_restricting_shared_folder.is_some() {
                        return Err(de::Error::duplicate_field("audience_restricting_shared_folder"));
                    }
                    field_audience_restricting_shared_folder = Some(map.next_value()?);
                }
                "expiry" => {
                    if field_expiry.is_some() {
                        return Err(de::Error::duplicate_field("expiry"));
                    }
                    field_expiry = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_CONTENT_LINK_METADATA_BASE_FIELDS))
            }
        }
        Ok(SharedContentLinkMetadataBase {
            audience_options: field_audience_options.ok_or_else(|| de::Error::missing_field("audience_options"))?,
            current_audience: field_current_audience.ok_or_else(|| de::Error::missing_field("current_audience"))?,
            link_permissions: field_link_permissions.ok_or_else(|| de::Error::missing_field("link_permissions"))?,
            password_protected: field_password_protected.ok_or_else(|| de::Error::missing_field("password_protected"))?,
            access_level: field_access_level,
            audience_restricting_shared_folder: field_audience_restricting_shared_folder,
            expiry: field_expiry,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("audience_options", &self.audience_options)?;
        s.serialize_field("current_audience", &self.current_audience)?;
        s.serialize_field("link_permissions", &self.link_permissions)?;
        s.serialize_field("password_protected", &self.password_protected)?;
        s.serialize_field("access_level", &self.access_level)?;
        s.serialize_field("audience_restricting_shared_folder", &self.audience_restricting_shared_folder)?;
        s.serialize_field("expiry", &self.expiry)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentLinkMetadataBase {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentLinkMetadataBase;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedContentLinkMetadataBase struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentLinkMetadataBase::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentLinkMetadataBase", SHARED_CONTENT_LINK_METADATA_BASE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentLinkMetadataBase {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentLinkMetadataBase", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared file user, group, and invitee membership. Used for the results of
/// :route:`list_file_members` and :route:`list_file_members/continue`, and used as part of the
/// results for :route:`list_file_members/batch`.
#[derive(Debug)]
pub struct SharedFileMembers {
    /// The list of user members of the shared file.
    pub users: Vec<UserMembershipInfo>,
    /// The list of group members of the shared file.
    pub groups: Vec<GroupMembershipInfo>,
    /// The list of invited members of a file, but have not logged in and claimed this.
    pub invitees: Vec<InviteeMembershipInfo>,
    /// Present if there are additional shared file members that have not been returned yet. Pass
    /// the cursor into :route:`list_file_members/continue` to list additional members.
    pub cursor: Option<String>,
}

impl SharedFileMembers {
    pub fn new(users: Vec<UserMembershipInfo>, groups: Vec<GroupMembershipInfo>, invitees: Vec<InviteeMembershipInfo>) -> Self {
        SharedFileMembers {
            users,
            groups,
            invitees,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const SHARED_FILE_MEMBERS_FIELDS: &'static [&'static str] = &["users",
                                                              "groups",
                                                              "invitees",
                                                              "cursor"];
impl SharedFileMembers {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFileMembers, V::Error> {
        use serde::de;
        let mut field_users = None;
        let mut field_groups = None;
        let mut field_invitees = None;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                "groups" => {
                    if field_groups.is_some() {
                        return Err(de::Error::duplicate_field("groups"));
                    }
                    field_groups = Some(map.next_value()?);
                }
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FILE_MEMBERS_FIELDS))
            }
        }
        Ok(SharedFileMembers {
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
            groups: field_groups.ok_or_else(|| de::Error::missing_field("groups"))?,
            invitees: field_invitees.ok_or_else(|| de::Error::missing_field("invitees"))?,
            cursor: field_cursor,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users", &self.users)?;
        s.serialize_field("groups", &self.groups)?;
        s.serialize_field("invitees", &self.invitees)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFileMembers {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFileMembers;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFileMembers struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFileMembers::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFileMembers", SHARED_FILE_MEMBERS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFileMembers {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFileMembers", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Properties of the shared file.
#[derive(Debug)]
pub struct SharedFileMetadata {
    /// The ID of the file.
    pub id: FileId,
    /// The name of this file.
    pub name: String,
    /// Policies governing this shared file.
    pub policy: FolderPolicy,
    /// URL for displaying a web preview of the shared file.
    pub preview_url: String,
    /// The current user's access level for this shared file.
    pub access_type: Option<AccessLevel>,
    /// The expected metadata of the link associated for the file when it is first shared. Absent if
    /// the link already exists. This is for an unreleased feature so it may not be returned yet.
    pub expected_link_metadata: Option<ExpectedSharedContentLinkMetadata>,
    /// The metadata of the link associated for the file. This is for an unreleased feature so it
    /// may not be returned yet.
    pub link_metadata: Option<SharedContentLinkMetadata>,
    /// The display names of the users that own the file. If the file is part of a team folder, the
    /// display names of the team admins are also included. Absent if the owner display names cannot
    /// be fetched.
    pub owner_display_names: Option<Vec<String>>,
    /// The team that owns the file. This field is not present if the file is not owned by a team.
    pub owner_team: Option<super::users::Team>,
    /// The ID of the parent shared folder. This field is present only if the file is contained
    /// within a shared folder.
    pub parent_shared_folder_id: Option<super::common::SharedFolderId>,
    /// The cased path to be used for display purposes only. In rare instances the casing will not
    /// correctly match the user's filesystem, but this behavior will match the path provided in the
    /// Core API v1. Absent for unmounted files.
    pub path_display: Option<String>,
    /// The lower-case full path of this file. Absent for unmounted files.
    pub path_lower: Option<String>,
    /// The sharing permissions that requesting user has on this file. This corresponds to the
    /// entries given in :field:`GetFileMetadataBatchArg.actions` or
    /// :field:`GetFileMetadataArg.actions`.
    pub permissions: Option<Vec<FilePermission>>,
    /// Timestamp indicating when the current user was invited to this shared file. If the user was
    /// not invited to the shared file, the timestamp will indicate when the user was invited to the
    /// parent shared folder. This value may be absent.
    pub time_invited: Option<super::common::DropboxTimestamp>,
}

impl SharedFileMetadata {
    pub fn new(id: FileId, name: String, policy: FolderPolicy, preview_url: String) -> Self {
        SharedFileMetadata {
            id,
            name,
            policy,
            preview_url,
            access_type: None,
            expected_link_metadata: None,
            link_metadata: None,
            owner_display_names: None,
            owner_team: None,
            parent_shared_folder_id: None,
            path_display: None,
            path_lower: None,
            permissions: None,
            time_invited: None,
        }
    }

    pub fn with_access_type(mut self, value: Option<AccessLevel>) -> Self {
        self.access_type = value;
        self
    }

    pub fn with_expected_link_metadata(mut self, value: Option<ExpectedSharedContentLinkMetadata>) -> Self {
        self.expected_link_metadata = value;
        self
    }

    pub fn with_link_metadata(mut self, value: Option<SharedContentLinkMetadata>) -> Self {
        self.link_metadata = value;
        self
    }

    pub fn with_owner_display_names(mut self, value: Option<Vec<String>>) -> Self {
        self.owner_display_names = value;
        self
    }

    pub fn with_owner_team(mut self, value: Option<super::users::Team>) -> Self {
        self.owner_team = value;
        self
    }

    pub fn with_parent_shared_folder_id(mut self, value: Option<super::common::SharedFolderId>) -> Self {
        self.parent_shared_folder_id = value;
        self
    }

    pub fn with_path_display(mut self, value: Option<String>) -> Self {
        self.path_display = value;
        self
    }

    pub fn with_path_lower(mut self, value: Option<String>) -> Self {
        self.path_lower = value;
        self
    }

    pub fn with_permissions(mut self, value: Option<Vec<FilePermission>>) -> Self {
        self.permissions = value;
        self
    }

    pub fn with_time_invited(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.time_invited = value;
        self
    }

}

const SHARED_FILE_METADATA_FIELDS: &'static [&'static str] = &["id",
                                                               "name",
                                                               "policy",
                                                               "preview_url",
                                                               "access_type",
                                                               "expected_link_metadata",
                                                               "link_metadata",
                                                               "owner_display_names",
                                                               "owner_team",
                                                               "parent_shared_folder_id",
                                                               "path_display",
                                                               "path_lower",
                                                               "permissions",
                                                               "time_invited"];
impl SharedFileMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFileMetadata, V::Error> {
        use serde::de;
        let mut field_id = None;
        let mut field_name = None;
        let mut field_policy = None;
        let mut field_preview_url = None;
        let mut field_access_type = None;
        let mut field_expected_link_metadata = None;
        let mut field_link_metadata = None;
        let mut field_owner_display_names = None;
        let mut field_owner_team = None;
        let mut field_parent_shared_folder_id = None;
        let mut field_path_display = None;
        let mut field_path_lower = None;
        let mut field_permissions = None;
        let mut field_time_invited = None;
        while let Some(key) = map.next_key()? {
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "policy" => {
                    if field_policy.is_some() {
                        return Err(de::Error::duplicate_field("policy"));
                    }
                    field_policy = Some(map.next_value()?);
                }
                "preview_url" => {
                    if field_preview_url.is_some() {
                        return Err(de::Error::duplicate_field("preview_url"));
                    }
                    field_preview_url = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "expected_link_metadata" => {
                    if field_expected_link_metadata.is_some() {
                        return Err(de::Error::duplicate_field("expected_link_metadata"));
                    }
                    field_expected_link_metadata = Some(map.next_value()?);
                }
                "link_metadata" => {
                    if field_link_metadata.is_some() {
                        return Err(de::Error::duplicate_field("link_metadata"));
                    }
                    field_link_metadata = Some(map.next_value()?);
                }
                "owner_display_names" => {
                    if field_owner_display_names.is_some() {
                        return Err(de::Error::duplicate_field("owner_display_names"));
                    }
                    field_owner_display_names = Some(map.next_value()?);
                }
                "owner_team" => {
                    if field_owner_team.is_some() {
                        return Err(de::Error::duplicate_field("owner_team"));
                    }
                    field_owner_team = Some(map.next_value()?);
                }
                "parent_shared_folder_id" => {
                    if field_parent_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("parent_shared_folder_id"));
                    }
                    field_parent_shared_folder_id = Some(map.next_value()?);
                }
                "path_display" => {
                    if field_path_display.is_some() {
                        return Err(de::Error::duplicate_field("path_display"));
                    }
                    field_path_display = Some(map.next_value()?);
                }
                "path_lower" => {
                    if field_path_lower.is_some() {
                        return Err(de::Error::duplicate_field("path_lower"));
                    }
                    field_path_lower = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "time_invited" => {
                    if field_time_invited.is_some() {
                        return Err(de::Error::duplicate_field("time_invited"));
                    }
                    field_time_invited = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FILE_METADATA_FIELDS))
            }
        }
        Ok(SharedFileMetadata {
            id: field_id.ok_or_else(|| de::Error::missing_field("id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            policy: field_policy.ok_or_else(|| de::Error::missing_field("policy"))?,
            preview_url: field_preview_url.ok_or_else(|| de::Error::missing_field("preview_url"))?,
            access_type: field_access_type,
            expected_link_metadata: field_expected_link_metadata,
            link_metadata: field_link_metadata,
            owner_display_names: field_owner_display_names,
            owner_team: field_owner_team,
            parent_shared_folder_id: field_parent_shared_folder_id,
            path_display: field_path_display,
            path_lower: field_path_lower,
            permissions: field_permissions,
            time_invited: field_time_invited,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("policy", &self.policy)?;
        s.serialize_field("preview_url", &self.preview_url)?;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("expected_link_metadata", &self.expected_link_metadata)?;
        s.serialize_field("link_metadata", &self.link_metadata)?;
        s.serialize_field("owner_display_names", &self.owner_display_names)?;
        s.serialize_field("owner_team", &self.owner_team)?;
        s.serialize_field("parent_shared_folder_id", &self.parent_shared_folder_id)?;
        s.serialize_field("path_display", &self.path_display)?;
        s.serialize_field("path_lower", &self.path_lower)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("time_invited", &self.time_invited)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFileMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFileMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFileMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFileMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFileMetadata", SHARED_FILE_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFileMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFileMetadata", 14)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// There is an error accessing the shared folder.
#[derive(Debug)]
pub enum SharedFolderAccessError {
    /// This shared folder ID is invalid.
    InvalidId,
    /// The user is not a member of the shared folder thus cannot access it.
    NotAMember,
    /// The current user's e-mail address is unverified.
    EmailUnverified,
    /// The shared folder is unmounted.
    Unmounted,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderAccessError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderAccessError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderAccessError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_id" => Ok(SharedFolderAccessError::InvalidId),
                    "not_a_member" => Ok(SharedFolderAccessError::NotAMember),
                    "email_unverified" => Ok(SharedFolderAccessError::EmailUnverified),
                    "unmounted" => Ok(SharedFolderAccessError::Unmounted),
                    _ => Ok(SharedFolderAccessError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["invalid_id",
                                                    "not_a_member",
                                                    "email_unverified",
                                                    "unmounted",
                                                    "other"];
        deserializer.deserialize_struct("SharedFolderAccessError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderAccessError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderAccessError::InvalidId => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderAccessError", 1)?;
                s.serialize_field(".tag", "invalid_id")?;
                s.end()
            }
            SharedFolderAccessError::NotAMember => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderAccessError", 1)?;
                s.serialize_field(".tag", "not_a_member")?;
                s.end()
            }
            SharedFolderAccessError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderAccessError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            SharedFolderAccessError::Unmounted => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderAccessError", 1)?;
                s.serialize_field(".tag", "unmounted")?;
                s.end()
            }
            SharedFolderAccessError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharedFolderAccessError {
    fn description(&self) -> &str {
        "SharedFolderAccessError"
    }
}

impl ::std::fmt::Display for SharedFolderAccessError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum SharedFolderMemberError {
    /// The target dropbox_id is invalid.
    InvalidDropboxId,
    /// The target dropbox_id is not a member of the shared folder.
    NotAMember,
    /// The target member only has inherited access to the shared folder.
    NoExplicitAccess(MemberAccessLevelResult),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_dropbox_id" => Ok(SharedFolderMemberError::InvalidDropboxId),
                    "not_a_member" => Ok(SharedFolderMemberError::NotAMember),
                    "no_explicit_access" => Ok(SharedFolderMemberError::NoExplicitAccess(MemberAccessLevelResult::internal_deserialize(map)?)),
                    _ => Ok(SharedFolderMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["invalid_dropbox_id",
                                                    "not_a_member",
                                                    "no_explicit_access",
                                                    "other"];
        deserializer.deserialize_struct("SharedFolderMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderMemberError::InvalidDropboxId => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMemberError", 1)?;
                s.serialize_field(".tag", "invalid_dropbox_id")?;
                s.end()
            }
            SharedFolderMemberError::NotAMember => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMemberError", 1)?;
                s.serialize_field(".tag", "not_a_member")?;
                s.end()
            }
            SharedFolderMemberError::NoExplicitAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("SharedFolderMemberError", 4)?;
                s.serialize_field(".tag", "no_explicit_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            SharedFolderMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharedFolderMemberError {
    fn description(&self) -> &str {
        "SharedFolderMemberError"
    }
}

impl ::std::fmt::Display for SharedFolderMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Shared folder user and group membership.
#[derive(Debug)]
pub struct SharedFolderMembers {
    /// The list of user members of the shared folder.
    pub users: Vec<UserMembershipInfo>,
    /// The list of group members of the shared folder.
    pub groups: Vec<GroupMembershipInfo>,
    /// The list of invitees to the shared folder.
    pub invitees: Vec<InviteeMembershipInfo>,
    /// Present if there are additional shared folder members that have not been returned yet. Pass
    /// the cursor into :route:`list_folder_members/continue` to list additional members.
    pub cursor: Option<String>,
}

impl SharedFolderMembers {
    pub fn new(users: Vec<UserMembershipInfo>, groups: Vec<GroupMembershipInfo>, invitees: Vec<InviteeMembershipInfo>) -> Self {
        SharedFolderMembers {
            users,
            groups,
            invitees,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const SHARED_FOLDER_MEMBERS_FIELDS: &'static [&'static str] = &["users",
                                                                "groups",
                                                                "invitees",
                                                                "cursor"];
impl SharedFolderMembers {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderMembers, V::Error> {
        use serde::de;
        let mut field_users = None;
        let mut field_groups = None;
        let mut field_invitees = None;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                "groups" => {
                    if field_groups.is_some() {
                        return Err(de::Error::duplicate_field("groups"));
                    }
                    field_groups = Some(map.next_value()?);
                }
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_MEMBERS_FIELDS))
            }
        }
        Ok(SharedFolderMembers {
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
            groups: field_groups.ok_or_else(|| de::Error::missing_field("groups"))?,
            invitees: field_invitees.ok_or_else(|| de::Error::missing_field("invitees"))?,
            cursor: field_cursor,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users", &self.users)?;
        s.serialize_field("groups", &self.groups)?;
        s.serialize_field("invitees", &self.invitees)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMembers {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMembers;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMembers struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMembers::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMembers", SHARED_FOLDER_MEMBERS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMembers {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMembers", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The metadata which includes basic information about the shared folder.
#[derive(Debug)]
pub struct SharedFolderMetadata {
    /// The current user's access level for this shared folder.
    pub access_type: AccessLevel,
    /// Whether this folder is inside of a team folder.
    pub is_inside_team_folder: bool,
    /// Whether this folder is a :link:`team folder https://www.dropbox.com/en/help/986`.
    pub is_team_folder: bool,
    /// The name of the this shared folder.
    pub name: String,
    /// Policies governing this shared folder.
    pub policy: FolderPolicy,
    /// URL for displaying a web preview of the shared folder.
    pub preview_url: String,
    /// The ID of the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// Timestamp indicating when the current user was invited to this shared folder.
    pub time_invited: super::common::DropboxTimestamp,
    /// The display names of the users that own the folder. If the folder is part of a team folder,
    /// the display names of the team admins are also included. Absent if the owner display names
    /// cannot be fetched.
    pub owner_display_names: Option<Vec<String>>,
    /// The team that owns the folder. This field is not present if the folder is not owned by a
    /// team.
    pub owner_team: Option<super::users::Team>,
    /// The ID of the parent shared folder. This field is present only if the folder is contained
    /// within another shared folder.
    pub parent_shared_folder_id: Option<super::common::SharedFolderId>,
    /// The lower-cased full path of this shared folder. Absent for unmounted folders.
    pub path_lower: Option<String>,
    /// The metadata of the shared content link to this shared folder. Absent if there is no link on
    /// the folder. This is for an unreleased feature so it may not be returned yet.
    pub link_metadata: Option<SharedContentLinkMetadata>,
    /// Actions the current user may perform on the folder and its contents. The set of permissions
    /// corresponds to the FolderActions in the request.
    pub permissions: Option<Vec<FolderPermission>>,
}

impl SharedFolderMetadata {
    pub fn new(access_type: AccessLevel, is_inside_team_folder: bool, is_team_folder: bool, name: String, policy: FolderPolicy, preview_url: String, shared_folder_id: super::common::SharedFolderId, time_invited: super::common::DropboxTimestamp) -> Self {
        SharedFolderMetadata {
            access_type,
            is_inside_team_folder,
            is_team_folder,
            name,
            policy,
            preview_url,
            shared_folder_id,
            time_invited,
            owner_display_names: None,
            owner_team: None,
            parent_shared_folder_id: None,
            path_lower: None,
            link_metadata: None,
            permissions: None,
        }
    }

    pub fn with_owner_display_names(mut self, value: Option<Vec<String>>) -> Self {
        self.owner_display_names = value;
        self
    }

    pub fn with_owner_team(mut self, value: Option<super::users::Team>) -> Self {
        self.owner_team = value;
        self
    }

    pub fn with_parent_shared_folder_id(mut self, value: Option<super::common::SharedFolderId>) -> Self {
        self.parent_shared_folder_id = value;
        self
    }

    pub fn with_path_lower(mut self, value: Option<String>) -> Self {
        self.path_lower = value;
        self
    }

    pub fn with_link_metadata(mut self, value: Option<SharedContentLinkMetadata>) -> Self {
        self.link_metadata = value;
        self
    }

    pub fn with_permissions(mut self, value: Option<Vec<FolderPermission>>) -> Self {
        self.permissions = value;
        self
    }

}

const SHARED_FOLDER_METADATA_FIELDS: &'static [&'static str] = &["access_type",
                                                                 "is_inside_team_folder",
                                                                 "is_team_folder",
                                                                 "name",
                                                                 "policy",
                                                                 "preview_url",
                                                                 "shared_folder_id",
                                                                 "time_invited",
                                                                 "owner_display_names",
                                                                 "owner_team",
                                                                 "parent_shared_folder_id",
                                                                 "path_lower",
                                                                 "link_metadata",
                                                                 "permissions"];
impl SharedFolderMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderMetadata, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_is_inside_team_folder = None;
        let mut field_is_team_folder = None;
        let mut field_name = None;
        let mut field_policy = None;
        let mut field_preview_url = None;
        let mut field_shared_folder_id = None;
        let mut field_time_invited = None;
        let mut field_owner_display_names = None;
        let mut field_owner_team = None;
        let mut field_parent_shared_folder_id = None;
        let mut field_path_lower = None;
        let mut field_link_metadata = None;
        let mut field_permissions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "is_inside_team_folder" => {
                    if field_is_inside_team_folder.is_some() {
                        return Err(de::Error::duplicate_field("is_inside_team_folder"));
                    }
                    field_is_inside_team_folder = Some(map.next_value()?);
                }
                "is_team_folder" => {
                    if field_is_team_folder.is_some() {
                        return Err(de::Error::duplicate_field("is_team_folder"));
                    }
                    field_is_team_folder = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "policy" => {
                    if field_policy.is_some() {
                        return Err(de::Error::duplicate_field("policy"));
                    }
                    field_policy = Some(map.next_value()?);
                }
                "preview_url" => {
                    if field_preview_url.is_some() {
                        return Err(de::Error::duplicate_field("preview_url"));
                    }
                    field_preview_url = Some(map.next_value()?);
                }
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "time_invited" => {
                    if field_time_invited.is_some() {
                        return Err(de::Error::duplicate_field("time_invited"));
                    }
                    field_time_invited = Some(map.next_value()?);
                }
                "owner_display_names" => {
                    if field_owner_display_names.is_some() {
                        return Err(de::Error::duplicate_field("owner_display_names"));
                    }
                    field_owner_display_names = Some(map.next_value()?);
                }
                "owner_team" => {
                    if field_owner_team.is_some() {
                        return Err(de::Error::duplicate_field("owner_team"));
                    }
                    field_owner_team = Some(map.next_value()?);
                }
                "parent_shared_folder_id" => {
                    if field_parent_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("parent_shared_folder_id"));
                    }
                    field_parent_shared_folder_id = Some(map.next_value()?);
                }
                "path_lower" => {
                    if field_path_lower.is_some() {
                        return Err(de::Error::duplicate_field("path_lower"));
                    }
                    field_path_lower = Some(map.next_value()?);
                }
                "link_metadata" => {
                    if field_link_metadata.is_some() {
                        return Err(de::Error::duplicate_field("link_metadata"));
                    }
                    field_link_metadata = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_METADATA_FIELDS))
            }
        }
        Ok(SharedFolderMetadata {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            is_inside_team_folder: field_is_inside_team_folder.ok_or_else(|| de::Error::missing_field("is_inside_team_folder"))?,
            is_team_folder: field_is_team_folder.ok_or_else(|| de::Error::missing_field("is_team_folder"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            policy: field_policy.ok_or_else(|| de::Error::missing_field("policy"))?,
            preview_url: field_preview_url.ok_or_else(|| de::Error::missing_field("preview_url"))?,
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            time_invited: field_time_invited.ok_or_else(|| de::Error::missing_field("time_invited"))?,
            owner_display_names: field_owner_display_names,
            owner_team: field_owner_team,
            parent_shared_folder_id: field_parent_shared_folder_id,
            path_lower: field_path_lower,
            link_metadata: field_link_metadata,
            permissions: field_permissions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("is_inside_team_folder", &self.is_inside_team_folder)?;
        s.serialize_field("is_team_folder", &self.is_team_folder)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("policy", &self.policy)?;
        s.serialize_field("preview_url", &self.preview_url)?;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("time_invited", &self.time_invited)?;
        s.serialize_field("owner_display_names", &self.owner_display_names)?;
        s.serialize_field("owner_team", &self.owner_team)?;
        s.serialize_field("parent_shared_folder_id", &self.parent_shared_folder_id)?;
        s.serialize_field("path_lower", &self.path_lower)?;
        s.serialize_field("link_metadata", &self.link_metadata)?;
        s.serialize_field("permissions", &self.permissions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMetadata", SHARED_FOLDER_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMetadata", 14)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Properties of the shared folder.
#[derive(Debug)]
pub struct SharedFolderMetadataBase {
    /// The current user's access level for this shared folder.
    pub access_type: AccessLevel,
    /// Whether this folder is inside of a team folder.
    pub is_inside_team_folder: bool,
    /// Whether this folder is a :link:`team folder https://www.dropbox.com/en/help/986`.
    pub is_team_folder: bool,
    /// The display names of the users that own the folder. If the folder is part of a team folder,
    /// the display names of the team admins are also included. Absent if the owner display names
    /// cannot be fetched.
    pub owner_display_names: Option<Vec<String>>,
    /// The team that owns the folder. This field is not present if the folder is not owned by a
    /// team.
    pub owner_team: Option<super::users::Team>,
    /// The ID of the parent shared folder. This field is present only if the folder is contained
    /// within another shared folder.
    pub parent_shared_folder_id: Option<super::common::SharedFolderId>,
    /// The lower-cased full path of this shared folder. Absent for unmounted folders.
    pub path_lower: Option<String>,
}

impl SharedFolderMetadataBase {
    pub fn new(access_type: AccessLevel, is_inside_team_folder: bool, is_team_folder: bool) -> Self {
        SharedFolderMetadataBase {
            access_type,
            is_inside_team_folder,
            is_team_folder,
            owner_display_names: None,
            owner_team: None,
            parent_shared_folder_id: None,
            path_lower: None,
        }
    }

    pub fn with_owner_display_names(mut self, value: Option<Vec<String>>) -> Self {
        self.owner_display_names = value;
        self
    }

    pub fn with_owner_team(mut self, value: Option<super::users::Team>) -> Self {
        self.owner_team = value;
        self
    }

    pub fn with_parent_shared_folder_id(mut self, value: Option<super::common::SharedFolderId>) -> Self {
        self.parent_shared_folder_id = value;
        self
    }

    pub fn with_path_lower(mut self, value: Option<String>) -> Self {
        self.path_lower = value;
        self
    }

}

const SHARED_FOLDER_METADATA_BASE_FIELDS: &'static [&'static str] = &["access_type",
                                                                      "is_inside_team_folder",
                                                                      "is_team_folder",
                                                                      "owner_display_names",
                                                                      "owner_team",
                                                                      "parent_shared_folder_id",
                                                                      "path_lower"];
impl SharedFolderMetadataBase {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedFolderMetadataBase, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_is_inside_team_folder = None;
        let mut field_is_team_folder = None;
        let mut field_owner_display_names = None;
        let mut field_owner_team = None;
        let mut field_parent_shared_folder_id = None;
        let mut field_path_lower = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "is_inside_team_folder" => {
                    if field_is_inside_team_folder.is_some() {
                        return Err(de::Error::duplicate_field("is_inside_team_folder"));
                    }
                    field_is_inside_team_folder = Some(map.next_value()?);
                }
                "is_team_folder" => {
                    if field_is_team_folder.is_some() {
                        return Err(de::Error::duplicate_field("is_team_folder"));
                    }
                    field_is_team_folder = Some(map.next_value()?);
                }
                "owner_display_names" => {
                    if field_owner_display_names.is_some() {
                        return Err(de::Error::duplicate_field("owner_display_names"));
                    }
                    field_owner_display_names = Some(map.next_value()?);
                }
                "owner_team" => {
                    if field_owner_team.is_some() {
                        return Err(de::Error::duplicate_field("owner_team"));
                    }
                    field_owner_team = Some(map.next_value()?);
                }
                "parent_shared_folder_id" => {
                    if field_parent_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("parent_shared_folder_id"));
                    }
                    field_parent_shared_folder_id = Some(map.next_value()?);
                }
                "path_lower" => {
                    if field_path_lower.is_some() {
                        return Err(de::Error::duplicate_field("path_lower"));
                    }
                    field_path_lower = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_FOLDER_METADATA_BASE_FIELDS))
            }
        }
        Ok(SharedFolderMetadataBase {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            is_inside_team_folder: field_is_inside_team_folder.ok_or_else(|| de::Error::missing_field("is_inside_team_folder"))?,
            is_team_folder: field_is_team_folder.ok_or_else(|| de::Error::missing_field("is_team_folder"))?,
            owner_display_names: field_owner_display_names,
            owner_team: field_owner_team,
            parent_shared_folder_id: field_parent_shared_folder_id,
            path_lower: field_path_lower,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("is_inside_team_folder", &self.is_inside_team_folder)?;
        s.serialize_field("is_team_folder", &self.is_team_folder)?;
        s.serialize_field("owner_display_names", &self.owner_display_names)?;
        s.serialize_field("owner_team", &self.owner_team)?;
        s.serialize_field("parent_shared_folder_id", &self.parent_shared_folder_id)?;
        s.serialize_field("path_lower", &self.path_lower)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMetadataBase {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMetadataBase;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMetadataBase struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMetadataBase::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMetadataBase", SHARED_FOLDER_METADATA_BASE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMetadataBase {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMetadataBase", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SharedLinkAccessFailureReason {
    /// User is not logged in.
    LoginRequired,
    /// User's email is not verified.
    EmailVerifyRequired,
    /// The link is password protected.
    PasswordRequired,
    /// Access is allowed for team members only.
    TeamOnly,
    /// Access is allowed for the shared link's owner only.
    OwnerOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAccessFailureReason {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkAccessFailureReason;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAccessFailureReason structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "login_required" => Ok(SharedLinkAccessFailureReason::LoginRequired),
                    "email_verify_required" => Ok(SharedLinkAccessFailureReason::EmailVerifyRequired),
                    "password_required" => Ok(SharedLinkAccessFailureReason::PasswordRequired),
                    "team_only" => Ok(SharedLinkAccessFailureReason::TeamOnly),
                    "owner_only" => Ok(SharedLinkAccessFailureReason::OwnerOnly),
                    _ => Ok(SharedLinkAccessFailureReason::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["login_required",
                                                    "email_verify_required",
                                                    "password_required",
                                                    "team_only",
                                                    "owner_only",
                                                    "other"];
        deserializer.deserialize_struct("SharedLinkAccessFailureReason", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAccessFailureReason {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkAccessFailureReason::LoginRequired => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessFailureReason", 1)?;
                s.serialize_field(".tag", "login_required")?;
                s.end()
            }
            SharedLinkAccessFailureReason::EmailVerifyRequired => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessFailureReason", 1)?;
                s.serialize_field(".tag", "email_verify_required")?;
                s.end()
            }
            SharedLinkAccessFailureReason::PasswordRequired => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessFailureReason", 1)?;
                s.serialize_field(".tag", "password_required")?;
                s.end()
            }
            SharedLinkAccessFailureReason::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessFailureReason", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharedLinkAccessFailureReason::OwnerOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessFailureReason", 1)?;
                s.serialize_field(".tag", "owner_only")?;
                s.end()
            }
            SharedLinkAccessFailureReason::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SharedLinkError {
    /// The shared link wasn't found.
    SharedLinkNotFound,
    /// The caller is not allowed to access this shared link.
    SharedLinkAccessDenied,
    /// This type of link is not supported.
    UnsupportedLinkType,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "shared_link_not_found" => Ok(SharedLinkError::SharedLinkNotFound),
                    "shared_link_access_denied" => Ok(SharedLinkError::SharedLinkAccessDenied),
                    "unsupported_link_type" => Ok(SharedLinkError::UnsupportedLinkType),
                    _ => Ok(SharedLinkError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["shared_link_not_found",
                                                    "shared_link_access_denied",
                                                    "unsupported_link_type",
                                                    "other"];
        deserializer.deserialize_struct("SharedLinkError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkError::SharedLinkNotFound => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkError", 1)?;
                s.serialize_field(".tag", "shared_link_not_found")?;
                s.end()
            }
            SharedLinkError::SharedLinkAccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkError", 1)?;
                s.serialize_field(".tag", "shared_link_access_denied")?;
                s.end()
            }
            SharedLinkError::UnsupportedLinkType => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkError", 1)?;
                s.serialize_field(".tag", "unsupported_link_type")?;
                s.end()
            }
            SharedLinkError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharedLinkError {
    fn description(&self) -> &str {
        "SharedLinkError"
    }
}

impl ::std::fmt::Display for SharedLinkError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// The metadata of a shared link
#[derive(Debug)]
pub enum SharedLinkMetadata {
    File(FileLinkMetadata),
    Folder(FolderLinkMetadata),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkMetadata structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file" => Ok(SharedLinkMetadata::File(FileLinkMetadata::internal_deserialize(map)?)),
                    "folder" => Ok(SharedLinkMetadata::Folder(FolderLinkMetadata::internal_deserialize(map)?)),
                    _ => Ok(SharedLinkMetadata::_Unknown)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["folder",
                                                    "folder"];
        deserializer.deserialize_struct("SharedLinkMetadata", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkMetadata::File(ref x) => {
                let mut s = serializer.serialize_struct("SharedLinkMetadata", 13)?;
                s.serialize_field(".tag", "file")?;
                s.serialize_field("url", &x.url)?;
                s.serialize_field("name", &x.name)?;
                s.serialize_field("link_permissions", &x.link_permissions)?;
                s.serialize_field("client_modified", &x.client_modified)?;
                s.serialize_field("server_modified", &x.server_modified)?;
                s.serialize_field("rev", &x.rev)?;
                s.serialize_field("size", &x.size)?;
                s.serialize_field("id", &x.id)?;
                s.serialize_field("expires", &x.expires)?;
                s.serialize_field("path_lower", &x.path_lower)?;
                s.serialize_field("team_member_info", &x.team_member_info)?;
                s.serialize_field("content_owner_team_info", &x.content_owner_team_info)?;
                s.end()
            }
            SharedLinkMetadata::Folder(ref x) => {
                let mut s = serializer.serialize_struct("SharedLinkMetadata", 9)?;
                s.serialize_field(".tag", "folder")?;
                s.serialize_field("url", &x.url)?;
                s.serialize_field("name", &x.name)?;
                s.serialize_field("link_permissions", &x.link_permissions)?;
                s.serialize_field("id", &x.id)?;
                s.serialize_field("expires", &x.expires)?;
                s.serialize_field("path_lower", &x.path_lower)?;
                s.serialize_field("team_member_info", &x.team_member_info)?;
                s.serialize_field("content_owner_team_info", &x.content_owner_team_info)?;
                s.end()
            }
            SharedLinkMetadata::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Who can view shared links in this folder.
#[derive(Debug)]
pub enum SharedLinkPolicy {
    /// Links can be shared with anyone.
    Anyone,
    /// Links can be shared with anyone on the same team as the owner.
    Team,
    /// Links can only be shared among members of the shared folder.
    Members,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "anyone" => Ok(SharedLinkPolicy::Anyone),
                    "team" => Ok(SharedLinkPolicy::Team),
                    "members" => Ok(SharedLinkPolicy::Members),
                    _ => Ok(SharedLinkPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["anyone",
                                                    "team",
                                                    "members",
                                                    "other"];
        deserializer.deserialize_struct("SharedLinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkPolicy::Anyone => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkPolicy", 1)?;
                s.serialize_field(".tag", "anyone")?;
                s.end()
            }
            SharedLinkPolicy::Team => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkPolicy", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            SharedLinkPolicy::Members => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkPolicy", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            SharedLinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct SharedLinkSettings {
    /// The requested access for this shared link.
    pub requested_visibility: Option<RequestedVisibility>,
    /// If :field:`requested_visibility` is :field:`RequestedVisibility.password` this is needed to
    /// specify the password to access the link.
    pub link_password: Option<String>,
    /// Expiration time of the shared link. By default the link won't expire.
    pub expires: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedLinkSettings {
    fn default() -> Self {
        SharedLinkSettings {
            requested_visibility: None,
            link_password: None,
            expires: None,
        }
    }
}

const SHARED_LINK_SETTINGS_FIELDS: &'static [&'static str] = &["requested_visibility",
                                                               "link_password",
                                                               "expires"];
impl SharedLinkSettings {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<SharedLinkSettings, V::Error> {
        use serde::de;
        let mut field_requested_visibility = None;
        let mut field_link_password = None;
        let mut field_expires = None;
        while let Some(key) = map.next_key()? {
            match key {
                "requested_visibility" => {
                    if field_requested_visibility.is_some() {
                        return Err(de::Error::duplicate_field("requested_visibility"));
                    }
                    field_requested_visibility = Some(map.next_value()?);
                }
                "link_password" => {
                    if field_link_password.is_some() {
                        return Err(de::Error::duplicate_field("link_password"));
                    }
                    field_link_password = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SHARED_LINK_SETTINGS_FIELDS))
            }
        }
        Ok(SharedLinkSettings {
            requested_visibility: field_requested_visibility,
            link_password: field_link_password,
            expires: field_expires,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("requested_visibility", &self.requested_visibility)?;
        s.serialize_field("link_password", &self.link_password)?;
        s.serialize_field("expires", &self.expires)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettings {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettings;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettings struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettings::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettings", SHARED_LINK_SETTINGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettings {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettings", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SharedLinkSettingsError {
    /// The given settings are invalid (for example, all attributes of the
    /// :type:`SharedLinkSettings` are empty, the requested visibility is
    /// :field:`RequestedVisibility.password` but the :field:`SharedLinkSettings.link_password` is
    /// missing, :field:`SharedLinkSettings.expires` is set to the past, etc.)
    InvalidSettings,
    /// User is not allowed to modify the settings of this link. Note that basic users can only set
    /// :field:`RequestedVisibility.public` as the :field:`SharedLinkSettings.requested_visibility`
    /// and cannot set :field:`SharedLinkSettings.expires`
    NotAuthorized,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkSettingsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_settings" => Ok(SharedLinkSettingsError::InvalidSettings),
                    "not_authorized" => Ok(SharedLinkSettingsError::NotAuthorized),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["invalid_settings",
                                                    "not_authorized"];
        deserializer.deserialize_struct("SharedLinkSettingsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkSettingsError::InvalidSettings => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "invalid_settings")?;
                s.end()
            }
            SharedLinkSettingsError::NotAuthorized => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkSettingsError", 1)?;
                s.serialize_field(".tag", "not_authorized")?;
                s.end()
            }
        }
    }
}

impl ::std::error::Error for SharedLinkSettingsError {
    fn description(&self) -> &str {
        "SharedLinkSettingsError"
    }
}

impl ::std::fmt::Display for SharedLinkSettingsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// User could not access this file.
#[derive(Debug)]
pub enum SharingFileAccessError {
    /// Current user does not have sufficient privileges to perform the desired action.
    NoPermission,
    /// File specified was not found.
    InvalidFile,
    /// A folder can't be shared this way. Use folder sharing or a shared link instead.
    IsFolder,
    /// A file inside a public folder can't be shared this way. Use a public link instead.
    InsidePublicFolder,
    /// A Mac OS X package can't be shared this way. Use a shared link instead.
    InsideOsxPackage,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingFileAccessError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingFileAccessError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingFileAccessError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "no_permission" => Ok(SharingFileAccessError::NoPermission),
                    "invalid_file" => Ok(SharingFileAccessError::InvalidFile),
                    "is_folder" => Ok(SharingFileAccessError::IsFolder),
                    "inside_public_folder" => Ok(SharingFileAccessError::InsidePublicFolder),
                    "inside_osx_package" => Ok(SharingFileAccessError::InsideOsxPackage),
                    _ => Ok(SharingFileAccessError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["no_permission",
                                                    "invalid_file",
                                                    "is_folder",
                                                    "inside_public_folder",
                                                    "inside_osx_package",
                                                    "other"];
        deserializer.deserialize_struct("SharingFileAccessError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingFileAccessError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingFileAccessError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("SharingFileAccessError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            SharingFileAccessError::InvalidFile => {
                // unit
                let mut s = serializer.serialize_struct("SharingFileAccessError", 1)?;
                s.serialize_field(".tag", "invalid_file")?;
                s.end()
            }
            SharingFileAccessError::IsFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharingFileAccessError", 1)?;
                s.serialize_field(".tag", "is_folder")?;
                s.end()
            }
            SharingFileAccessError::InsidePublicFolder => {
                // unit
                let mut s = serializer.serialize_struct("SharingFileAccessError", 1)?;
                s.serialize_field(".tag", "inside_public_folder")?;
                s.end()
            }
            SharingFileAccessError::InsideOsxPackage => {
                // unit
                let mut s = serializer.serialize_struct("SharingFileAccessError", 1)?;
                s.serialize_field(".tag", "inside_osx_package")?;
                s.end()
            }
            SharingFileAccessError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharingFileAccessError {
    fn description(&self) -> &str {
        "SharingFileAccessError"
    }
}

impl ::std::fmt::Display for SharingFileAccessError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// User account had a problem preventing this action.
#[derive(Debug)]
pub enum SharingUserError {
    /// The current user must verify the account e-mail address before performing this action.
    EmailUnverified,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingUserError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingUserError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SharingUserError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email_unverified" => Ok(SharingUserError::EmailUnverified),
                    _ => Ok(SharingUserError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["email_unverified",
                                                    "other"];
        deserializer.deserialize_struct("SharingUserError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingUserError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingUserError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("SharingUserError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            SharingUserError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SharingUserError {
    fn description(&self) -> &str {
        "SharingUserError"
    }
}

impl ::std::fmt::Display for SharingUserError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Information about a team member.
#[derive(Debug)]
pub struct TeamMemberInfo {
    /// Information about the member's team
    pub team_info: TeamInfo,
    /// The display name of the user.
    pub display_name: String,
    /// ID of user as a member of a team. This field will only be present if the member is in the
    /// same team as current user.
    pub member_id: Option<String>,
}

impl TeamMemberInfo {
    pub fn new(team_info: TeamInfo, display_name: String) -> Self {
        TeamMemberInfo {
            team_info,
            display_name,
            member_id: None,
        }
    }

    pub fn with_member_id(mut self, value: Option<String>) -> Self {
        self.member_id = value;
        self
    }

}

const TEAM_MEMBER_INFO_FIELDS: &'static [&'static str] = &["team_info",
                                                           "display_name",
                                                           "member_id"];
impl TeamMemberInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TeamMemberInfo, V::Error> {
        use serde::de;
        let mut field_team_info = None;
        let mut field_display_name = None;
        let mut field_member_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "team_info" => {
                    if field_team_info.is_some() {
                        return Err(de::Error::duplicate_field("team_info"));
                    }
                    field_team_info = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "member_id" => {
                    if field_member_id.is_some() {
                        return Err(de::Error::duplicate_field("member_id"));
                    }
                    field_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MEMBER_INFO_FIELDS))
            }
        }
        Ok(TeamMemberInfo {
            team_info: field_team_info.ok_or_else(|| de::Error::missing_field("team_info"))?,
            display_name: field_display_name.ok_or_else(|| de::Error::missing_field("display_name"))?,
            member_id: field_member_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_info", &self.team_info)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("member_id", &self.member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberInfo", TEAM_MEMBER_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TransferFolderArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// A account or team member ID to transfer ownership to.
    pub to_dropbox_id: DropboxId,
}

impl TransferFolderArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId, to_dropbox_id: DropboxId) -> Self {
        TransferFolderArg {
            shared_folder_id,
            to_dropbox_id,
        }
    }

}

const TRANSFER_FOLDER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                              "to_dropbox_id"];
impl TransferFolderArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<TransferFolderArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_to_dropbox_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "to_dropbox_id" => {
                    if field_to_dropbox_id.is_some() {
                        return Err(de::Error::duplicate_field("to_dropbox_id"));
                    }
                    field_to_dropbox_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TRANSFER_FOLDER_ARG_FIELDS))
            }
        }
        Ok(TransferFolderArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            to_dropbox_id: field_to_dropbox_id.ok_or_else(|| de::Error::missing_field("to_dropbox_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("to_dropbox_id", &self.to_dropbox_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TransferFolderArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TransferFolderArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TransferFolderArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TransferFolderArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TransferFolderArg", TRANSFER_FOLDER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TransferFolderArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TransferFolderArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TransferFolderError {
    AccessError(SharedFolderAccessError),
    /// :field:`TransferFolderArg.to_dropbox_id` is invalid.
    InvalidDropboxId,
    /// The new designated owner is not currently a member of the shared folder.
    NewOwnerNotAMember,
    /// The new designated owner has not added the folder to their Dropbox.
    NewOwnerUnmounted,
    /// The new designated owner's e-mail address is unverified.
    NewOwnerEmailUnverified,
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    /// The current user does not have permission to perform this action.
    NoPermission,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TransferFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TransferFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TransferFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(TransferFolderError::AccessError(map.next_value()?))
                    }
                    "invalid_dropbox_id" => Ok(TransferFolderError::InvalidDropboxId),
                    "new_owner_not_a_member" => Ok(TransferFolderError::NewOwnerNotAMember),
                    "new_owner_unmounted" => Ok(TransferFolderError::NewOwnerUnmounted),
                    "new_owner_email_unverified" => Ok(TransferFolderError::NewOwnerEmailUnverified),
                    "team_folder" => Ok(TransferFolderError::TeamFolder),
                    "no_permission" => Ok(TransferFolderError::NoPermission),
                    _ => Ok(TransferFolderError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "invalid_dropbox_id",
                                                    "new_owner_not_a_member",
                                                    "new_owner_unmounted",
                                                    "new_owner_email_unverified",
                                                    "team_folder",
                                                    "no_permission",
                                                    "other"];
        deserializer.deserialize_struct("TransferFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TransferFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TransferFolderError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TransferFolderError::InvalidDropboxId => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "invalid_dropbox_id")?;
                s.end()
            }
            TransferFolderError::NewOwnerNotAMember => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "new_owner_not_a_member")?;
                s.end()
            }
            TransferFolderError::NewOwnerUnmounted => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "new_owner_unmounted")?;
                s.end()
            }
            TransferFolderError::NewOwnerEmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "new_owner_email_unverified")?;
                s.end()
            }
            TransferFolderError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            TransferFolderError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("TransferFolderError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            TransferFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TransferFolderError {
    fn description(&self) -> &str {
        "TransferFolderError"
    }
}

impl ::std::fmt::Display for TransferFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct UnmountFolderArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
}

impl UnmountFolderArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        UnmountFolderArg {
            shared_folder_id,
        }
    }

}

const UNMOUNT_FOLDER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id"];
impl UnmountFolderArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UnmountFolderArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UNMOUNT_FOLDER_ARG_FIELDS))
            }
        }
        Ok(UnmountFolderArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UnmountFolderArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UnmountFolderArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnmountFolderArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UnmountFolderArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UnmountFolderArg", UNMOUNT_FOLDER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UnmountFolderArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UnmountFolderArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UnmountFolderError {
    AccessError(SharedFolderAccessError),
    /// The current user does not have permission to perform this action.
    NoPermission,
    /// The shared folder can't be unmounted. One example where this can occur is when the shared
    /// folder's parent folder is also a shared folder that resides in the current user's Dropbox.
    NotUnmountable,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UnmountFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UnmountFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnmountFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(UnmountFolderError::AccessError(map.next_value()?))
                    }
                    "no_permission" => Ok(UnmountFolderError::NoPermission),
                    "not_unmountable" => Ok(UnmountFolderError::NotUnmountable),
                    _ => Ok(UnmountFolderError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "no_permission",
                                                    "not_unmountable",
                                                    "other"];
        deserializer.deserialize_struct("UnmountFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UnmountFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UnmountFolderError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            UnmountFolderError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("UnmountFolderError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            UnmountFolderError::NotUnmountable => {
                // unit
                let mut s = serializer.serialize_struct("UnmountFolderError", 1)?;
                s.serialize_field(".tag", "not_unmountable")?;
                s.end()
            }
            UnmountFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UnmountFolderError {
    fn description(&self) -> &str {
        "UnmountFolderError"
    }
}

impl ::std::fmt::Display for UnmountFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Arguments for :route:`unshare_file`.
#[derive(Debug)]
pub struct UnshareFileArg {
    /// The file to unshare.
    pub file: PathOrId,
}

impl UnshareFileArg {
    pub fn new(file: PathOrId) -> Self {
        UnshareFileArg {
            file,
        }
    }

}

const UNSHARE_FILE_ARG_FIELDS: &'static [&'static str] = &["file"];
impl UnshareFileArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UnshareFileArg, V::Error> {
        use serde::de;
        let mut field_file = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UNSHARE_FILE_ARG_FIELDS))
            }
        }
        Ok(UnshareFileArg {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UnshareFileArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UnshareFileArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnshareFileArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UnshareFileArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UnshareFileArg", UNSHARE_FILE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UnshareFileArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UnshareFileArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error result for :route:`unshare_file`.
#[derive(Debug)]
pub enum UnshareFileError {
    UserError(SharingUserError),
    AccessError(SharingFileAccessError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UnshareFileError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UnshareFileError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnshareFileError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_error" => {
                        if map.next_key()? != Some("user_error") {
                            return Err(de::Error::missing_field("user_error"));
                        }
                        Ok(UnshareFileError::UserError(map.next_value()?))
                    }
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(UnshareFileError::AccessError(map.next_value()?))
                    }
                    _ => Ok(UnshareFileError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["user_error",
                                                    "access_error",
                                                    "other"];
        deserializer.deserialize_struct("UnshareFileError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UnshareFileError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UnshareFileError::UserError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "user_error")?;
                s.serialize_field("user_error", x)?;
                s.end()
            }
            UnshareFileError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            UnshareFileError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UnshareFileError {
    fn description(&self) -> &str {
        "UnshareFileError"
    }
}

impl ::std::fmt::Display for UnshareFileError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct UnshareFolderArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// If true, members of this shared folder will get a copy of this folder after it's unshared.
    /// Otherwise, it will be removed from their Dropbox. The current user, who is an owner, will
    /// always retain their copy.
    pub leave_a_copy: bool,
}

impl UnshareFolderArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        UnshareFolderArg {
            shared_folder_id,
            leave_a_copy: false,
        }
    }

    pub fn with_leave_a_copy(mut self, value: bool) -> Self {
        self.leave_a_copy = value;
        self
    }

}

const UNSHARE_FOLDER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                             "leave_a_copy"];
impl UnshareFolderArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UnshareFolderArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_leave_a_copy = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "leave_a_copy" => {
                    if field_leave_a_copy.is_some() {
                        return Err(de::Error::duplicate_field("leave_a_copy"));
                    }
                    field_leave_a_copy = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UNSHARE_FOLDER_ARG_FIELDS))
            }
        }
        Ok(UnshareFolderArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            leave_a_copy: field_leave_a_copy.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("leave_a_copy", &self.leave_a_copy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UnshareFolderArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UnshareFolderArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnshareFolderArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UnshareFolderArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UnshareFolderArg", UNSHARE_FOLDER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UnshareFolderArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UnshareFolderArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UnshareFolderError {
    AccessError(SharedFolderAccessError),
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    /// The current user does not have permission to perform this action.
    NoPermission,
    /// This shared folder has too many files to be unshared.
    TooManyFiles,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UnshareFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UnshareFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UnshareFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(UnshareFolderError::AccessError(map.next_value()?))
                    }
                    "team_folder" => Ok(UnshareFolderError::TeamFolder),
                    "no_permission" => Ok(UnshareFolderError::NoPermission),
                    "too_many_files" => Ok(UnshareFolderError::TooManyFiles),
                    _ => Ok(UnshareFolderError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "team_folder",
                                                    "no_permission",
                                                    "too_many_files",
                                                    "other"];
        deserializer.deserialize_struct("UnshareFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UnshareFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UnshareFolderError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            UnshareFolderError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("UnshareFolderError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            UnshareFolderError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("UnshareFolderError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            UnshareFolderError::TooManyFiles => {
                // unit
                let mut s = serializer.serialize_struct("UnshareFolderError", 1)?;
                s.serialize_field(".tag", "too_many_files")?;
                s.end()
            }
            UnshareFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UnshareFolderError {
    fn description(&self) -> &str {
        "UnshareFolderError"
    }
}

impl ::std::fmt::Display for UnshareFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Arguments for :route:`update_file_member`.
#[derive(Debug)]
pub struct UpdateFileMemberArgs {
    /// File for which we are changing a member's access.
    pub file: PathOrId,
    /// The member whose access we are changing.
    pub member: MemberSelector,
    /// The new access level for the member.
    pub access_level: AccessLevel,
}

impl UpdateFileMemberArgs {
    pub fn new(file: PathOrId, member: MemberSelector, access_level: AccessLevel) -> Self {
        UpdateFileMemberArgs {
            file,
            member,
            access_level,
        }
    }

}

const UPDATE_FILE_MEMBER_ARGS_FIELDS: &'static [&'static str] = &["file",
                                                                  "member",
                                                                  "access_level"];
impl UpdateFileMemberArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UpdateFileMemberArgs, V::Error> {
        use serde::de;
        let mut field_file = None;
        let mut field_member = None;
        let mut field_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "file" => {
                    if field_file.is_some() {
                        return Err(de::Error::duplicate_field("file"));
                    }
                    field_file = Some(map.next_value()?);
                }
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UPDATE_FILE_MEMBER_ARGS_FIELDS))
            }
        }
        Ok(UpdateFileMemberArgs {
            file: field_file.ok_or_else(|| de::Error::missing_field("file"))?,
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            access_level: field_access_level.ok_or_else(|| de::Error::missing_field("access_level"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file", &self.file)?;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("access_level", &self.access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFileMemberArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateFileMemberArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFileMemberArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateFileMemberArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateFileMemberArgs", UPDATE_FILE_MEMBER_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFileMemberArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateFileMemberArgs", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct UpdateFolderMemberArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// The member of the shared folder to update.  Only the :field:`MemberSelector.dropbox_id` may
    /// be set at this time.
    pub member: MemberSelector,
    /// The new access level for :field:`member`. :field:`AccessLevel.owner` is disallowed.
    pub access_level: AccessLevel,
}

impl UpdateFolderMemberArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId, member: MemberSelector, access_level: AccessLevel) -> Self {
        UpdateFolderMemberArg {
            shared_folder_id,
            member,
            access_level,
        }
    }

}

const UPDATE_FOLDER_MEMBER_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                   "member",
                                                                   "access_level"];
impl UpdateFolderMemberArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UpdateFolderMemberArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_member = None;
        let mut field_access_level = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "member" => {
                    if field_member.is_some() {
                        return Err(de::Error::duplicate_field("member"));
                    }
                    field_member = Some(map.next_value()?);
                }
                "access_level" => {
                    if field_access_level.is_some() {
                        return Err(de::Error::duplicate_field("access_level"));
                    }
                    field_access_level = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UPDATE_FOLDER_MEMBER_ARG_FIELDS))
            }
        }
        Ok(UpdateFolderMemberArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            member: field_member.ok_or_else(|| de::Error::missing_field("member"))?,
            access_level: field_access_level.ok_or_else(|| de::Error::missing_field("access_level"))?,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("member", &self.member)?;
        s.serialize_field("access_level", &self.access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFolderMemberArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateFolderMemberArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFolderMemberArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateFolderMemberArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateFolderMemberArg", UPDATE_FOLDER_MEMBER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFolderMemberArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateFolderMemberArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UpdateFolderMemberError {
    AccessError(SharedFolderAccessError),
    MemberError(SharedFolderMemberError),
    /// If updating the access type required the member to be added to the shared folder and there
    /// was an error when adding the member.
    NoExplicitAccess(AddFolderMemberError),
    /// The current user's account doesn't support this action. An example of this is when
    /// downgrading a member from editor to viewer. This action can only be performed by users that
    /// have upgraded to a Pro or Business plan.
    InsufficientPlan,
    /// The current user does not have permission to perform this action.
    NoPermission,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFolderMemberError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UpdateFolderMemberError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFolderMemberError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(UpdateFolderMemberError::AccessError(map.next_value()?))
                    }
                    "member_error" => {
                        if map.next_key()? != Some("member_error") {
                            return Err(de::Error::missing_field("member_error"));
                        }
                        Ok(UpdateFolderMemberError::MemberError(map.next_value()?))
                    }
                    "no_explicit_access" => {
                        if map.next_key()? != Some("no_explicit_access") {
                            return Err(de::Error::missing_field("no_explicit_access"));
                        }
                        Ok(UpdateFolderMemberError::NoExplicitAccess(map.next_value()?))
                    }
                    "insufficient_plan" => Ok(UpdateFolderMemberError::InsufficientPlan),
                    "no_permission" => Ok(UpdateFolderMemberError::NoPermission),
                    _ => Ok(UpdateFolderMemberError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "member_error",
                                                    "no_explicit_access",
                                                    "insufficient_plan",
                                                    "no_permission",
                                                    "other"];
        deserializer.deserialize_struct("UpdateFolderMemberError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFolderMemberError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UpdateFolderMemberError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            UpdateFolderMemberError::MemberError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "member_error")?;
                s.serialize_field("member_error", x)?;
                s.end()
            }
            UpdateFolderMemberError::NoExplicitAccess(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "no_explicit_access")?;
                s.serialize_field("no_explicit_access", x)?;
                s.end()
            }
            UpdateFolderMemberError::InsufficientPlan => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderMemberError", 1)?;
                s.serialize_field(".tag", "insufficient_plan")?;
                s.end()
            }
            UpdateFolderMemberError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderMemberError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            UpdateFolderMemberError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UpdateFolderMemberError {
    fn description(&self) -> &str {
        "UpdateFolderMemberError"
    }
}

impl ::std::fmt::Display for UpdateFolderMemberError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// If any of the policies are unset, then they retain their current setting.
#[derive(Debug)]
pub struct UpdateFolderPolicyArg {
    /// The ID for the shared folder.
    pub shared_folder_id: super::common::SharedFolderId,
    /// Who can be a member of this shared folder. Only applicable if the current user is on a team.
    pub member_policy: Option<MemberPolicy>,
    /// Who can add and remove members of this shared folder.
    pub acl_update_policy: Option<AclUpdatePolicy>,
    /// Who can enable/disable viewer info for this shared folder.
    pub viewer_info_policy: Option<ViewerInfoPolicy>,
    /// The policy to apply to shared links created for content inside this shared folder. The
    /// current user must be on a team to set this policy to :field:`SharedLinkPolicy.members`.
    pub shared_link_policy: Option<SharedLinkPolicy>,
    /// Settings on the link for this folder.
    pub link_settings: Option<LinkSettings>,
    /// A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the
    /// response's :field:`SharedFolderMetadata.permissions` field describing the actions the
    /// authenticated user can perform on the folder.
    pub actions: Option<Vec<FolderAction>>,
}

impl UpdateFolderPolicyArg {
    pub fn new(shared_folder_id: super::common::SharedFolderId) -> Self {
        UpdateFolderPolicyArg {
            shared_folder_id,
            member_policy: None,
            acl_update_policy: None,
            viewer_info_policy: None,
            shared_link_policy: None,
            link_settings: None,
            actions: None,
        }
    }

    pub fn with_member_policy(mut self, value: Option<MemberPolicy>) -> Self {
        self.member_policy = value;
        self
    }

    pub fn with_acl_update_policy(mut self, value: Option<AclUpdatePolicy>) -> Self {
        self.acl_update_policy = value;
        self
    }

    pub fn with_viewer_info_policy(mut self, value: Option<ViewerInfoPolicy>) -> Self {
        self.viewer_info_policy = value;
        self
    }

    pub fn with_shared_link_policy(mut self, value: Option<SharedLinkPolicy>) -> Self {
        self.shared_link_policy = value;
        self
    }

    pub fn with_link_settings(mut self, value: Option<LinkSettings>) -> Self {
        self.link_settings = value;
        self
    }

    pub fn with_actions(mut self, value: Option<Vec<FolderAction>>) -> Self {
        self.actions = value;
        self
    }

}

const UPDATE_FOLDER_POLICY_ARG_FIELDS: &'static [&'static str] = &["shared_folder_id",
                                                                   "member_policy",
                                                                   "acl_update_policy",
                                                                   "viewer_info_policy",
                                                                   "shared_link_policy",
                                                                   "link_settings",
                                                                   "actions"];
impl UpdateFolderPolicyArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UpdateFolderPolicyArg, V::Error> {
        use serde::de;
        let mut field_shared_folder_id = None;
        let mut field_member_policy = None;
        let mut field_acl_update_policy = None;
        let mut field_viewer_info_policy = None;
        let mut field_shared_link_policy = None;
        let mut field_link_settings = None;
        let mut field_actions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "shared_folder_id" => {
                    if field_shared_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("shared_folder_id"));
                    }
                    field_shared_folder_id = Some(map.next_value()?);
                }
                "member_policy" => {
                    if field_member_policy.is_some() {
                        return Err(de::Error::duplicate_field("member_policy"));
                    }
                    field_member_policy = Some(map.next_value()?);
                }
                "acl_update_policy" => {
                    if field_acl_update_policy.is_some() {
                        return Err(de::Error::duplicate_field("acl_update_policy"));
                    }
                    field_acl_update_policy = Some(map.next_value()?);
                }
                "viewer_info_policy" => {
                    if field_viewer_info_policy.is_some() {
                        return Err(de::Error::duplicate_field("viewer_info_policy"));
                    }
                    field_viewer_info_policy = Some(map.next_value()?);
                }
                "shared_link_policy" => {
                    if field_shared_link_policy.is_some() {
                        return Err(de::Error::duplicate_field("shared_link_policy"));
                    }
                    field_shared_link_policy = Some(map.next_value()?);
                }
                "link_settings" => {
                    if field_link_settings.is_some() {
                        return Err(de::Error::duplicate_field("link_settings"));
                    }
                    field_link_settings = Some(map.next_value()?);
                }
                "actions" => {
                    if field_actions.is_some() {
                        return Err(de::Error::duplicate_field("actions"));
                    }
                    field_actions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, UPDATE_FOLDER_POLICY_ARG_FIELDS))
            }
        }
        Ok(UpdateFolderPolicyArg {
            shared_folder_id: field_shared_folder_id.ok_or_else(|| de::Error::missing_field("shared_folder_id"))?,
            member_policy: field_member_policy,
            acl_update_policy: field_acl_update_policy,
            viewer_info_policy: field_viewer_info_policy,
            shared_link_policy: field_shared_link_policy,
            link_settings: field_link_settings,
            actions: field_actions,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_folder_id", &self.shared_folder_id)?;
        s.serialize_field("member_policy", &self.member_policy)?;
        s.serialize_field("acl_update_policy", &self.acl_update_policy)?;
        s.serialize_field("viewer_info_policy", &self.viewer_info_policy)?;
        s.serialize_field("shared_link_policy", &self.shared_link_policy)?;
        s.serialize_field("link_settings", &self.link_settings)?;
        s.serialize_field("actions", &self.actions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFolderPolicyArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateFolderPolicyArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFolderPolicyArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateFolderPolicyArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateFolderPolicyArg", UPDATE_FOLDER_POLICY_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFolderPolicyArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateFolderPolicyArg", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UpdateFolderPolicyError {
    AccessError(SharedFolderAccessError),
    /// :field:`UpdateFolderPolicyArg.member_policy` was set even though user is not on a team.
    NotOnTeam,
    /// Team policy is more restrictive than :field:`ShareFolderArg.member_policy`.
    TeamPolicyDisallowsMemberPolicy,
    /// The current account is not allowed to select the specified
    /// :field:`ShareFolderArg.shared_link_policy`.
    DisallowedSharedLinkPolicy,
    /// The current user does not have permission to perform this action.
    NoPermission,
    /// This action cannot be performed on a team shared folder.
    TeamFolder,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFolderPolicyError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UpdateFolderPolicyError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFolderPolicyError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        if map.next_key()? != Some("access_error") {
                            return Err(de::Error::missing_field("access_error"));
                        }
                        Ok(UpdateFolderPolicyError::AccessError(map.next_value()?))
                    }
                    "not_on_team" => Ok(UpdateFolderPolicyError::NotOnTeam),
                    "team_policy_disallows_member_policy" => Ok(UpdateFolderPolicyError::TeamPolicyDisallowsMemberPolicy),
                    "disallowed_shared_link_policy" => Ok(UpdateFolderPolicyError::DisallowedSharedLinkPolicy),
                    "no_permission" => Ok(UpdateFolderPolicyError::NoPermission),
                    "team_folder" => Ok(UpdateFolderPolicyError::TeamFolder),
                    _ => Ok(UpdateFolderPolicyError::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["access_error",
                                                    "not_on_team",
                                                    "team_policy_disallows_member_policy",
                                                    "disallowed_shared_link_policy",
                                                    "no_permission",
                                                    "team_folder",
                                                    "other"];
        deserializer.deserialize_struct("UpdateFolderPolicyError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFolderPolicyError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UpdateFolderPolicyError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("{}", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            UpdateFolderPolicyError::NotOnTeam => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderPolicyError", 1)?;
                s.serialize_field(".tag", "not_on_team")?;
                s.end()
            }
            UpdateFolderPolicyError::TeamPolicyDisallowsMemberPolicy => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderPolicyError", 1)?;
                s.serialize_field(".tag", "team_policy_disallows_member_policy")?;
                s.end()
            }
            UpdateFolderPolicyError::DisallowedSharedLinkPolicy => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderPolicyError", 1)?;
                s.serialize_field(".tag", "disallowed_shared_link_policy")?;
                s.end()
            }
            UpdateFolderPolicyError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderPolicyError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            UpdateFolderPolicyError::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFolderPolicyError", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            UpdateFolderPolicyError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UpdateFolderPolicyError {
    fn description(&self) -> &str {
        "UpdateFolderPolicyError"
    }
}

impl ::std::fmt::Display for UpdateFolderPolicyError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Basic information about a user. Use :route:`users.get_account` and
/// :route:`users.get_account_batch` to obtain more detailed information.
#[derive(Debug)]
pub struct UserInfo {
    /// The account ID of the user.
    pub account_id: super::users_common::AccountId,
    /// If the user is in the same team as current user.
    pub same_team: bool,
    /// The team member ID of the shared folder member. Only present if :field:`same_team` is true.
    pub team_member_id: Option<String>,
}

impl UserInfo {
    pub fn new(account_id: super::users_common::AccountId, same_team: bool) -> Self {
        UserInfo {
            account_id,
            same_team,
            team_member_id: None,
        }
    }

    pub fn with_team_member_id(mut self, value: Option<String>) -> Self {
        self.team_member_id = value;
        self
    }

}

const USER_INFO_FIELDS: &'static [&'static str] = &["account_id",
                                                    "same_team",
                                                    "team_member_id"];
impl UserInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UserInfo, V::Error> {
        use serde::de;
        let mut field_account_id = None;
        let mut field_same_team = None;
        let mut field_team_member_id = None;
        while let Some(key) = map.next_key()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "same_team" => {
                    if field_same_team.is_some() {
                        return Err(de::Error::duplicate_field("same_team"));
                    }
                    field_same_team = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_INFO_FIELDS))
            }
        }
        Ok(UserInfo {
            account_id: field_account_id.ok_or_else(|| de::Error::missing_field("account_id"))?,
            same_team: field_same_team.ok_or_else(|| de::Error::missing_field("same_team"))?,
            team_member_id: field_team_member_id,
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("same_team", &self.same_team)?;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserInfo", USER_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The information about a user member of the shared content.
#[derive(Debug)]
pub struct UserMembershipInfo {
    /// The access type for this member.
    pub access_type: AccessLevel,
    /// The account information for the membership user.
    pub user: UserInfo,
    /// The permissions that requesting user has on this member. The set of permissions corresponds
    /// to the MemberActions in the request.
    pub permissions: Option<Vec<MemberPermission>>,
    /// Suggested name initials for a member.
    pub initials: Option<String>,
    /// True if the member has access from a parent folder.
    pub is_inherited: bool,
}

impl UserMembershipInfo {
    pub fn new(access_type: AccessLevel, user: UserInfo) -> Self {
        UserMembershipInfo {
            access_type,
            user,
            permissions: None,
            initials: None,
            is_inherited: false,
        }
    }

    pub fn with_permissions(mut self, value: Option<Vec<MemberPermission>>) -> Self {
        self.permissions = value;
        self
    }

    pub fn with_initials(mut self, value: Option<String>) -> Self {
        self.initials = value;
        self
    }

    pub fn with_is_inherited(mut self, value: bool) -> Self {
        self.is_inherited = value;
        self
    }

}

const USER_MEMBERSHIP_INFO_FIELDS: &'static [&'static str] = &["access_type",
                                                               "user",
                                                               "permissions",
                                                               "initials",
                                                               "is_inherited"];
impl UserMembershipInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(mut map: V) -> Result<UserMembershipInfo, V::Error> {
        use serde::de;
        let mut field_access_type = None;
        let mut field_user = None;
        let mut field_permissions = None;
        let mut field_initials = None;
        let mut field_is_inherited = None;
        while let Some(key) = map.next_key()? {
            match key {
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "permissions" => {
                    if field_permissions.is_some() {
                        return Err(de::Error::duplicate_field("permissions"));
                    }
                    field_permissions = Some(map.next_value()?);
                }
                "initials" => {
                    if field_initials.is_some() {
                        return Err(de::Error::duplicate_field("initials"));
                    }
                    field_initials = Some(map.next_value()?);
                }
                "is_inherited" => {
                    if field_is_inherited.is_some() {
                        return Err(de::Error::duplicate_field("is_inherited"));
                    }
                    field_is_inherited = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_MEMBERSHIP_INFO_FIELDS))
            }
        }
        Ok(UserMembershipInfo {
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            permissions: field_permissions,
            initials: field_initials,
            is_inherited: field_is_inherited.unwrap_or(false),
        })
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(&self, s: &mut S::SerializeStruct) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("permissions", &self.permissions)?;
        s.serialize_field("initials", &self.initials)?;
        s.serialize_field("is_inherited", &self.is_inherited)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserMembershipInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserMembershipInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserMembershipInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserMembershipInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserMembershipInfo", USER_MEMBERSHIP_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserMembershipInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserMembershipInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ViewerInfoPolicy {
    /// Viewer information is available on this file.
    Enabled,
    /// Viewer information is disabled on this file.
    Disabled,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ViewerInfoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ViewerInfoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ViewerInfoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "enabled" => Ok(ViewerInfoPolicy::Enabled),
                    "disabled" => Ok(ViewerInfoPolicy::Disabled),
                    _ => Ok(ViewerInfoPolicy::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["enabled",
                                                    "disabled",
                                                    "other"];
        deserializer.deserialize_struct("ViewerInfoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ViewerInfoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ViewerInfoPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ViewerInfoPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ViewerInfoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ViewerInfoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ViewerInfoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Who can access a shared link. The most open visibility is :field:`public`. The default depends
/// on many aspects, such as team and user preferences and shared folder settings.
#[derive(Debug)]
pub enum Visibility {
    /// Anyone who has received the link can access it. No login required.
    Public,
    /// Only members of the same team can access the link. Login is required.
    TeamOnly,
    /// A link-specific password is required to access the link. Login is not required.
    Password,
    /// Only members of the same team who have the link-specific password can access the link.
    TeamAndPassword,
    /// Only members of the shared folder containing the linked file can access the link. Login is
    /// required.
    SharedFolderOnly,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for Visibility {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = Visibility;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Visibility structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "public" => Ok(Visibility::Public),
                    "team_only" => Ok(Visibility::TeamOnly),
                    "password" => Ok(Visibility::Password),
                    "team_and_password" => Ok(Visibility::TeamAndPassword),
                    "shared_folder_only" => Ok(Visibility::SharedFolderOnly),
                    _ => Ok(Visibility::Other)
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["public",
                                                    "team_only",
                                                    "password",
                                                    "team_and_password",
                                                    "shared_folder_only",
                                                    "other"];
        deserializer.deserialize_struct("Visibility", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for Visibility {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            Visibility::Public => {
                // unit
                let mut s = serializer.serialize_struct("Visibility", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            Visibility::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("Visibility", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            Visibility::Password => {
                // unit
                let mut s = serializer.serialize_struct("Visibility", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            Visibility::TeamAndPassword => {
                // unit
                let mut s = serializer.serialize_struct("Visibility", 1)?;
                s.serialize_field(".tag", "team_and_password")?;
                s.end()
            }
            Visibility::SharedFolderOnly => {
                // unit
                let mut s = serializer.serialize_struct("Visibility", 1)?;
                s.serialize_field(".tag", "shared_folder_only")?;
                s.end()
            }
            Visibility::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

