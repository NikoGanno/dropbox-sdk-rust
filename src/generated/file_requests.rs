// DO NOT EDIT
// This file was generated by Stone

#![cfg_attr(feature="cargo-clippy", allow(
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
))]

//! This namespace contains endpoints and data types for file request operations.

pub type FileRequestId = String;
pub type FileRequestValidationError = Option<String>;

/// Creates a file request for this user.
pub fn create(
    client: &::client_trait::HttpClient,
    arg: &CreateFileRequestArgs,
) -> ::Result<Result<FileRequest, CreateFileRequestError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        ::client_trait::Style::Rpc,
        "file_requests/create",
        arg,
        None)
}

/// Returns the specified file request.
pub fn get(
    client: &::client_trait::HttpClient,
    arg: &GetFileRequestArgs,
) -> ::Result<Result<FileRequest, GetFileRequestError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        ::client_trait::Style::Rpc,
        "file_requests/get",
        arg,
        None)
}

/// Returns a list of file requests owned by this user. For apps with the app folder permission,
/// this will only return file requests with destinations in the app folder.
pub fn list(
    client: &::client_trait::HttpClient,
) -> ::Result<Result<ListFileRequestsResult, ListFileRequestsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        ::client_trait::Style::Rpc,
        "file_requests/list",
        &(),
        None)
}

/// Update a file request.
pub fn update(
    client: &::client_trait::HttpClient,
    arg: &UpdateFileRequestArgs,
) -> ::Result<Result<FileRequest, UpdateFileRequestError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        ::client_trait::Style::Rpc,
        "file_requests/update",
        arg,
        None)
}

/// Arguments for [`create()`](create).
#[derive(Debug)]
pub struct CreateFileRequestArgs {
    /// The title of the file request. Must not be empty.
    pub title: String,
    /// The path of the folder in the Dropbox where uploaded files will be sent. For apps with the
    /// app folder permission, this will be relative to the app folder.
    pub destination: super::files::Path,
    /// The deadline for the file request. Deadlines can only be set by Professional and Business
    /// accounts.
    pub deadline: Option<FileRequestDeadline>,
    /// Whether or not the file request should be open. If the file request is closed, it will not
    /// accept any file submissions, but it can be opened later.
    pub open: bool,
}

impl CreateFileRequestArgs {
    pub fn new(title: String, destination: super::files::Path) -> Self {
        CreateFileRequestArgs {
            title,
            destination,
            deadline: None,
            open: true,
        }
    }

    pub fn with_deadline(mut self, value: Option<FileRequestDeadline>) -> Self {
        self.deadline = value;
        self
    }

    pub fn with_open(mut self, value: bool) -> Self {
        self.open = value;
        self
    }

}

const CREATE_FILE_REQUEST_ARGS_FIELDS: &[&str] = &["title",
                                                   "destination",
                                                   "deadline",
                                                   "open"];
impl CreateFileRequestArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CreateFileRequestArgs, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CreateFileRequestArgs>, V::Error> {
        let mut field_title = None;
        let mut field_destination = None;
        let mut field_deadline = None;
        let mut field_open = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                "destination" => {
                    if field_destination.is_some() {
                        return Err(::serde::de::Error::duplicate_field("destination"));
                    }
                    field_destination = Some(map.next_value()?);
                }
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                "open" => {
                    if field_open.is_some() {
                        return Err(::serde::de::Error::duplicate_field("open"));
                    }
                    field_open = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CreateFileRequestArgs {
            title: field_title.ok_or_else(|| ::serde::de::Error::missing_field("title"))?,
            destination: field_destination.ok_or_else(|| ::serde::de::Error::missing_field("destination"))?,
            deadline: field_deadline,
            open: field_open.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("title", &self.title)?;
        s.serialize_field("destination", &self.destination)?;
        s.serialize_field("deadline", &self.deadline)?;
        s.serialize_field("open", &self.open)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFileRequestArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFileRequestArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateFileRequestArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFileRequestArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFileRequestArgs", CREATE_FILE_REQUEST_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFileRequestArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateFileRequestArgs", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// There was an error creating the file request.
#[derive(Debug)]
pub enum CreateFileRequestError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
    /// This file request ID was not found.
    NotFound,
    /// The specified path is not a folder.
    NotAFolder,
    /// This file request is not accessible to this app. Apps with the app folder permission can
    /// only access file requests in their app folder.
    AppLacksAccess,
    /// This user doesn't have permission to access or modify this file request.
    NoPermission,
    /// This user's email address is not verified. File requests are only available on accounts with
    /// a verified email address. Users can verify their email address
    /// [here](https://www.dropbox.com/help/317).
    EmailUnverified,
    /// There was an error validating the request. For example, the title was invalid, or there were
    /// disallowed characters in the destination path.
    ValidationError,
    /// File requests are not available on the specified folder.
    InvalidLocation,
    /// The user has reached the rate limit for creating file requests. The limit is currently 100
    /// file requests per day.
    RateLimit,
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFileRequestError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CreateFileRequestError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CreateFileRequestError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::DisabledForTeam)
                    }
                    "not_found" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::NotFound)
                    }
                    "not_a_folder" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::NotAFolder)
                    }
                    "app_lacks_access" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::AppLacksAccess)
                    }
                    "no_permission" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::NoPermission)
                    }
                    "email_unverified" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::EmailUnverified)
                    }
                    "validation_error" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::ValidationError)
                    }
                    "invalid_location" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::InvalidLocation)
                    }
                    "rate_limit" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::RateLimit)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(CreateFileRequestError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other",
                                    "not_found",
                                    "not_a_folder",
                                    "app_lacks_access",
                                    "no_permission",
                                    "email_unverified",
                                    "validation_error",
                                    "invalid_location",
                                    "rate_limit"];
        deserializer.deserialize_struct("CreateFileRequestError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFileRequestError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CreateFileRequestError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            CreateFileRequestError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            CreateFileRequestError::NotAFolder => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "not_a_folder")?;
                s.end()
            }
            CreateFileRequestError::AppLacksAccess => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "app_lacks_access")?;
                s.end()
            }
            CreateFileRequestError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            CreateFileRequestError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            CreateFileRequestError::ValidationError => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "validation_error")?;
                s.end()
            }
            CreateFileRequestError::InvalidLocation => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "invalid_location")?;
                s.end()
            }
            CreateFileRequestError::RateLimit => {
                // unit
                let mut s = serializer.serialize_struct("CreateFileRequestError", 1)?;
                s.serialize_field(".tag", "rate_limit")?;
                s.end()
            }
            CreateFileRequestError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for CreateFileRequestError {
    fn description(&self) -> &str {
        "CreateFileRequestError"
    }
}

impl ::std::fmt::Display for CreateFileRequestError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// A [file request](https://www.dropbox.com/help/9090) for receiving files into the user's Dropbox
/// account.
#[derive(Debug)]
pub struct FileRequest {
    /// The ID of the file request.
    pub id: FileRequestId,
    /// The URL of the file request.
    pub url: String,
    /// The title of the file request.
    pub title: String,
    /// When this file request was created.
    pub created: super::common::DropboxTimestamp,
    /// Whether or not the file request is open. If the file request is closed, it will not accept
    /// any more file submissions.
    pub is_open: bool,
    /// The number of files this file request has received.
    pub file_count: i64,
    /// The path of the folder in the Dropbox where uploaded files will be sent. This can be `None`
    /// if the destination was removed. For apps with the app folder permission, this will be
    /// relative to the app folder.
    pub destination: Option<super::files::Path>,
    /// The deadline for this file request. Only set if the request has a deadline.
    pub deadline: Option<FileRequestDeadline>,
}

impl FileRequest {
    pub fn new(
        id: FileRequestId,
        url: String,
        title: String,
        created: super::common::DropboxTimestamp,
        is_open: bool,
        file_count: i64,
    ) -> Self {
        FileRequest {
            id,
            url,
            title,
            created,
            is_open,
            file_count,
            destination: None,
            deadline: None,
        }
    }

    pub fn with_destination(mut self, value: Option<super::files::Path>) -> Self {
        self.destination = value;
        self
    }

    pub fn with_deadline(mut self, value: Option<FileRequestDeadline>) -> Self {
        self.deadline = value;
        self
    }

}

const FILE_REQUEST_FIELDS: &[&str] = &["id",
                                       "url",
                                       "title",
                                       "created",
                                       "is_open",
                                       "file_count",
                                       "destination",
                                       "deadline"];
impl FileRequest {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequest, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequest>, V::Error> {
        let mut field_id = None;
        let mut field_url = None;
        let mut field_title = None;
        let mut field_created = None;
        let mut field_is_open = None;
        let mut field_file_count = None;
        let mut field_destination = None;
        let mut field_deadline = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "url" => {
                    if field_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "is_open" => {
                    if field_is_open.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_open"));
                    }
                    field_is_open = Some(map.next_value()?);
                }
                "file_count" => {
                    if field_file_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_count"));
                    }
                    field_file_count = Some(map.next_value()?);
                }
                "destination" => {
                    if field_destination.is_some() {
                        return Err(::serde::de::Error::duplicate_field("destination"));
                    }
                    field_destination = Some(map.next_value()?);
                }
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequest {
            id: field_id.ok_or_else(|| ::serde::de::Error::missing_field("id"))?,
            url: field_url.ok_or_else(|| ::serde::de::Error::missing_field("url"))?,
            title: field_title.ok_or_else(|| ::serde::de::Error::missing_field("title"))?,
            created: field_created.ok_or_else(|| ::serde::de::Error::missing_field("created"))?,
            is_open: field_is_open.ok_or_else(|| ::serde::de::Error::missing_field("is_open"))?,
            file_count: field_file_count.ok_or_else(|| ::serde::de::Error::missing_field("file_count"))?,
            destination: field_destination,
            deadline: field_deadline,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("url", &self.url)?;
        s.serialize_field("title", &self.title)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("is_open", &self.is_open)?;
        s.serialize_field("file_count", &self.file_count)?;
        s.serialize_field("destination", &self.destination)?;
        s.serialize_field("deadline", &self.deadline)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequest {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequest;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequest struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequest::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequest", FILE_REQUEST_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequest {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequest", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestDeadline {
    /// The deadline for this file request.
    pub deadline: super::common::DropboxTimestamp,
    /// If set, allow uploads after the deadline has passed. These     uploads will be marked
    /// overdue.
    pub allow_late_uploads: Option<GracePeriod>,
}

impl FileRequestDeadline {
    pub fn new(deadline: super::common::DropboxTimestamp) -> Self {
        FileRequestDeadline {
            deadline,
            allow_late_uploads: None,
        }
    }

    pub fn with_allow_late_uploads(mut self, value: Option<GracePeriod>) -> Self {
        self.allow_late_uploads = value;
        self
    }

}

const FILE_REQUEST_DEADLINE_FIELDS: &[&str] = &["deadline",
                                                "allow_late_uploads"];
impl FileRequestDeadline {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestDeadline, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestDeadline>, V::Error> {
        let mut field_deadline = None;
        let mut field_allow_late_uploads = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                "allow_late_uploads" => {
                    if field_allow_late_uploads.is_some() {
                        return Err(::serde::de::Error::duplicate_field("allow_late_uploads"));
                    }
                    field_allow_late_uploads = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestDeadline {
            deadline: field_deadline.ok_or_else(|| ::serde::de::Error::missing_field("deadline"))?,
            allow_late_uploads: field_allow_late_uploads,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("deadline", &self.deadline)?;
        s.serialize_field("allow_late_uploads", &self.allow_late_uploads)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDeadline {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDeadline;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestDeadline struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDeadline::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDeadline", FILE_REQUEST_DEADLINE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDeadline {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDeadline", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// There is an error with the file request.
#[derive(Debug)]
pub enum FileRequestError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
    /// This file request ID was not found.
    NotFound,
    /// The specified path is not a folder.
    NotAFolder,
    /// This file request is not accessible to this app. Apps with the app folder permission can
    /// only access file requests in their app folder.
    AppLacksAccess,
    /// This user doesn't have permission to access or modify this file request.
    NoPermission,
    /// This user's email address is not verified. File requests are only available on accounts with
    /// a verified email address. Users can verify their email address
    /// [here](https://www.dropbox.com/help/317).
    EmailUnverified,
    /// There was an error validating the request. For example, the title was invalid, or there were
    /// disallowed characters in the destination path.
    ValidationError,
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileRequestError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FileRequestError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::DisabledForTeam)
                    }
                    "not_found" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::NotFound)
                    }
                    "not_a_folder" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::NotAFolder)
                    }
                    "app_lacks_access" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::AppLacksAccess)
                    }
                    "no_permission" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::NoPermission)
                    }
                    "email_unverified" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::EmailUnverified)
                    }
                    "validation_error" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::ValidationError)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(FileRequestError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other",
                                    "not_found",
                                    "not_a_folder",
                                    "app_lacks_access",
                                    "no_permission",
                                    "email_unverified",
                                    "validation_error"];
        deserializer.deserialize_struct("FileRequestError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileRequestError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            FileRequestError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            FileRequestError::NotAFolder => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "not_a_folder")?;
                s.end()
            }
            FileRequestError::AppLacksAccess => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "app_lacks_access")?;
                s.end()
            }
            FileRequestError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            FileRequestError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            FileRequestError::ValidationError => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestError", 1)?;
                s.serialize_field(".tag", "validation_error")?;
                s.end()
            }
            FileRequestError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for FileRequestError {
    fn description(&self) -> &str {
        "FileRequestError"
    }
}

impl ::std::fmt::Display for FileRequestError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// There is an error accessing the file requests functionality.
#[derive(Debug)]
pub enum GeneralFileRequestsError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GeneralFileRequestsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GeneralFileRequestsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GeneralFileRequestsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GeneralFileRequestsError::DisabledForTeam)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GeneralFileRequestsError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other"];
        deserializer.deserialize_struct("GeneralFileRequestsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GeneralFileRequestsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GeneralFileRequestsError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("GeneralFileRequestsError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            GeneralFileRequestsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GeneralFileRequestsError {
    fn description(&self) -> &str {
        "GeneralFileRequestsError"
    }
}

impl ::std::fmt::Display for GeneralFileRequestsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Arguments for [`get()`](get).
#[derive(Debug)]
pub struct GetFileRequestArgs {
    /// The ID of the file request to retrieve.
    pub id: FileRequestId,
}

impl GetFileRequestArgs {
    pub fn new(id: FileRequestId) -> Self {
        GetFileRequestArgs {
            id,
        }
    }

}

const GET_FILE_REQUEST_ARGS_FIELDS: &[&str] = &["id"];
impl GetFileRequestArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetFileRequestArgs, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetFileRequestArgs>, V::Error> {
        let mut field_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetFileRequestArgs {
            id: field_id.ok_or_else(|| ::serde::de::Error::missing_field("id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileRequestArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetFileRequestArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileRequestArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetFileRequestArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetFileRequestArgs", GET_FILE_REQUEST_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileRequestArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetFileRequestArgs", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// There was an error retrieving the specified file request.
#[derive(Debug)]
pub enum GetFileRequestError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
    /// This file request ID was not found.
    NotFound,
    /// The specified path is not a folder.
    NotAFolder,
    /// This file request is not accessible to this app. Apps with the app folder permission can
    /// only access file requests in their app folder.
    AppLacksAccess,
    /// This user doesn't have permission to access or modify this file request.
    NoPermission,
    /// This user's email address is not verified. File requests are only available on accounts with
    /// a verified email address. Users can verify their email address
    /// [here](https://www.dropbox.com/help/317).
    EmailUnverified,
    /// There was an error validating the request. For example, the title was invalid, or there were
    /// disallowed characters in the destination path.
    ValidationError,
}

impl<'de> ::serde::de::Deserialize<'de> for GetFileRequestError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetFileRequestError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetFileRequestError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::DisabledForTeam)
                    }
                    "not_found" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::NotFound)
                    }
                    "not_a_folder" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::NotAFolder)
                    }
                    "app_lacks_access" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::AppLacksAccess)
                    }
                    "no_permission" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::NoPermission)
                    }
                    "email_unverified" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::EmailUnverified)
                    }
                    "validation_error" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::ValidationError)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GetFileRequestError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other",
                                    "not_found",
                                    "not_a_folder",
                                    "app_lacks_access",
                                    "no_permission",
                                    "email_unverified",
                                    "validation_error"];
        deserializer.deserialize_struct("GetFileRequestError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetFileRequestError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetFileRequestError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            GetFileRequestError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            GetFileRequestError::NotAFolder => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "not_a_folder")?;
                s.end()
            }
            GetFileRequestError::AppLacksAccess => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "app_lacks_access")?;
                s.end()
            }
            GetFileRequestError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            GetFileRequestError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            GetFileRequestError::ValidationError => {
                // unit
                let mut s = serializer.serialize_struct("GetFileRequestError", 1)?;
                s.serialize_field(".tag", "validation_error")?;
                s.end()
            }
            GetFileRequestError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetFileRequestError {
    fn description(&self) -> &str {
        "GetFileRequestError"
    }
}

impl ::std::fmt::Display for GetFileRequestError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GracePeriod {
    OneDay,
    TwoDays,
    SevenDays,
    ThirtyDays,
    Always,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GracePeriod {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GracePeriod;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GracePeriod structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "one_day" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::OneDay)
                    }
                    "two_days" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::TwoDays)
                    }
                    "seven_days" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::SevenDays)
                    }
                    "thirty_days" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::ThirtyDays)
                    }
                    "always" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::Always)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(GracePeriod::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["one_day",
                                    "two_days",
                                    "seven_days",
                                    "thirty_days",
                                    "always",
                                    "other"];
        deserializer.deserialize_struct("GracePeriod", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GracePeriod {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GracePeriod::OneDay => {
                // unit
                let mut s = serializer.serialize_struct("GracePeriod", 1)?;
                s.serialize_field(".tag", "one_day")?;
                s.end()
            }
            GracePeriod::TwoDays => {
                // unit
                let mut s = serializer.serialize_struct("GracePeriod", 1)?;
                s.serialize_field(".tag", "two_days")?;
                s.end()
            }
            GracePeriod::SevenDays => {
                // unit
                let mut s = serializer.serialize_struct("GracePeriod", 1)?;
                s.serialize_field(".tag", "seven_days")?;
                s.end()
            }
            GracePeriod::ThirtyDays => {
                // unit
                let mut s = serializer.serialize_struct("GracePeriod", 1)?;
                s.serialize_field(".tag", "thirty_days")?;
                s.end()
            }
            GracePeriod::Always => {
                // unit
                let mut s = serializer.serialize_struct("GracePeriod", 1)?;
                s.serialize_field(".tag", "always")?;
                s.end()
            }
            GracePeriod::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// There was an error retrieving the file requests.
#[derive(Debug)]
pub enum ListFileRequestsError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileRequestsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListFileRequestsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileRequestsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(ListFileRequestsError::DisabledForTeam)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(ListFileRequestsError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other"];
        deserializer.deserialize_struct("ListFileRequestsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileRequestsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListFileRequestsError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("ListFileRequestsError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            ListFileRequestsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListFileRequestsError {
    fn description(&self) -> &str {
        "ListFileRequestsError"
    }
}

impl ::std::fmt::Display for ListFileRequestsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Result for [`list()`](list).
#[derive(Debug)]
pub struct ListFileRequestsResult {
    /// The file requests owned by this user. Apps with the app folder permission will only see file
    /// requests in their app folder.
    pub file_requests: Vec<FileRequest>,
}

impl ListFileRequestsResult {
    pub fn new(file_requests: Vec<FileRequest>) -> Self {
        ListFileRequestsResult {
            file_requests,
        }
    }

}

const LIST_FILE_REQUESTS_RESULT_FIELDS: &[&str] = &["file_requests"];
impl ListFileRequestsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListFileRequestsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListFileRequestsResult>, V::Error> {
        let mut field_file_requests = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_requests" => {
                    if field_file_requests.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_requests"));
                    }
                    field_file_requests = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListFileRequestsResult {
            file_requests: field_file_requests.ok_or_else(|| ::serde::de::Error::missing_field("file_requests"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_requests", &self.file_requests)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListFileRequestsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListFileRequestsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListFileRequestsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListFileRequestsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListFileRequestsResult", LIST_FILE_REQUESTS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListFileRequestsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListFileRequestsResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for [`update()`](update).
#[derive(Debug)]
pub struct UpdateFileRequestArgs {
    /// The ID of the file request to update.
    pub id: FileRequestId,
    /// The new title of the file request. Must not be empty.
    pub title: Option<String>,
    /// The new path of the folder in the Dropbox where uploaded files will be sent. For apps with
    /// the app folder permission, this will be relative to the app folder.
    pub destination: Option<super::files::Path>,
    /// The new deadline for the file request. Deadlines can only be set by Professional and
    /// Business accounts.
    pub deadline: UpdateFileRequestDeadline,
    /// Whether to set this file request as open or closed.
    pub open: Option<bool>,
}

impl UpdateFileRequestArgs {
    pub fn new(id: FileRequestId) -> Self {
        UpdateFileRequestArgs {
            id,
            title: None,
            destination: None,
            deadline: UpdateFileRequestDeadline::NoUpdate,
            open: None,
        }
    }

    pub fn with_title(mut self, value: Option<String>) -> Self {
        self.title = value;
        self
    }

    pub fn with_destination(mut self, value: Option<super::files::Path>) -> Self {
        self.destination = value;
        self
    }

    pub fn with_deadline(mut self, value: UpdateFileRequestDeadline) -> Self {
        self.deadline = value;
        self
    }

    pub fn with_open(mut self, value: Option<bool>) -> Self {
        self.open = value;
        self
    }

}

const UPDATE_FILE_REQUEST_ARGS_FIELDS: &[&str] = &["id",
                                                   "title",
                                                   "destination",
                                                   "deadline",
                                                   "open"];
impl UpdateFileRequestArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UpdateFileRequestArgs, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UpdateFileRequestArgs>, V::Error> {
        let mut field_id = None;
        let mut field_title = None;
        let mut field_destination = None;
        let mut field_deadline = None;
        let mut field_open = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                "destination" => {
                    if field_destination.is_some() {
                        return Err(::serde::de::Error::duplicate_field("destination"));
                    }
                    field_destination = Some(map.next_value()?);
                }
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                "open" => {
                    if field_open.is_some() {
                        return Err(::serde::de::Error::duplicate_field("open"));
                    }
                    field_open = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UpdateFileRequestArgs {
            id: field_id.ok_or_else(|| ::serde::de::Error::missing_field("id"))?,
            title: field_title,
            destination: field_destination,
            deadline: field_deadline.unwrap_or_else(|| UpdateFileRequestDeadline::NoUpdate),
            open: field_open,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("title", &self.title)?;
        s.serialize_field("destination", &self.destination)?;
        s.serialize_field("deadline", &self.deadline)?;
        s.serialize_field("open", &self.open)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFileRequestArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateFileRequestArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFileRequestArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateFileRequestArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateFileRequestArgs", UPDATE_FILE_REQUEST_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFileRequestArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateFileRequestArgs", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UpdateFileRequestDeadline {
    /// Do not change the file request's deadline.
    NoUpdate,
    /// If `None`, the file request's deadline is cleared.
    Update(Option<FileRequestDeadline>),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFileRequestDeadline {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UpdateFileRequestDeadline;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFileRequestDeadline structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "no_update" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestDeadline::NoUpdate)
                    }
                    "update" => Ok(UpdateFileRequestDeadline::Update(FileRequestDeadline::internal_deserialize_opt(map, true)?)),
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestDeadline::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["no_update",
                                    "update",
                                    "other"];
        deserializer.deserialize_struct("UpdateFileRequestDeadline", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFileRequestDeadline {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UpdateFileRequestDeadline::NoUpdate => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestDeadline", 1)?;
                s.serialize_field(".tag", "no_update")?;
                s.end()
            }
            UpdateFileRequestDeadline::Update(ref x) => {
                // nullable (struct or primitive)
                let n = if x.is_some() { 4 } else { 1 };
                let mut s = serializer.serialize_struct("UpdateFileRequestDeadline", n)?;
                s.serialize_field(".tag", "update")?;
                if let Some(ref x) = x {
                    x.internal_serialize::<S>(&mut s)?;
                }
                s.end()
            }
            UpdateFileRequestDeadline::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// There is an error updating the file request.
#[derive(Debug)]
pub enum UpdateFileRequestError {
    /// This user's Dropbox Business team doesn't allow file requests.
    DisabledForTeam,
    Other,
    /// This file request ID was not found.
    NotFound,
    /// The specified path is not a folder.
    NotAFolder,
    /// This file request is not accessible to this app. Apps with the app folder permission can
    /// only access file requests in their app folder.
    AppLacksAccess,
    /// This user doesn't have permission to access or modify this file request.
    NoPermission,
    /// This user's email address is not verified. File requests are only available on accounts with
    /// a verified email address. Users can verify their email address
    /// [here](https://www.dropbox.com/help/317).
    EmailUnverified,
    /// There was an error validating the request. For example, the title was invalid, or there were
    /// disallowed characters in the destination path.
    ValidationError,
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateFileRequestError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UpdateFileRequestError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UpdateFileRequestError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled_for_team" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::DisabledForTeam)
                    }
                    "not_found" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::NotFound)
                    }
                    "not_a_folder" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::NotAFolder)
                    }
                    "app_lacks_access" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::AppLacksAccess)
                    }
                    "no_permission" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::NoPermission)
                    }
                    "email_unverified" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::EmailUnverified)
                    }
                    "validation_error" => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::ValidationError)
                    }
                    _ => {
                        ::eat_json_fields(&mut map)?;
                        Ok(UpdateFileRequestError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled_for_team",
                                    "other",
                                    "not_found",
                                    "not_a_folder",
                                    "app_lacks_access",
                                    "no_permission",
                                    "email_unverified",
                                    "validation_error"];
        deserializer.deserialize_struct("UpdateFileRequestError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateFileRequestError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UpdateFileRequestError::DisabledForTeam => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "disabled_for_team")?;
                s.end()
            }
            UpdateFileRequestError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            UpdateFileRequestError::NotAFolder => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "not_a_folder")?;
                s.end()
            }
            UpdateFileRequestError::AppLacksAccess => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "app_lacks_access")?;
                s.end()
            }
            UpdateFileRequestError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            UpdateFileRequestError::EmailUnverified => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "email_unverified")?;
                s.end()
            }
            UpdateFileRequestError::ValidationError => {
                // unit
                let mut s = serializer.serialize_struct("UpdateFileRequestError", 1)?;
                s.serialize_field(".tag", "validation_error")?;
                s.end()
            }
            UpdateFileRequestError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UpdateFileRequestError {
    fn description(&self) -> &str {
        "UpdateFileRequestError"
    }
}

impl ::std::fmt::Display for UpdateFileRequestError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

