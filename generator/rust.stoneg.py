from stone import data_type
from stone.generator import CodeGenerator
from stone.target.helpers import (
    fmt_pascal,
    fmt_underscores,
)

RUST_RESERVED_WORDS = [
    "abstract", "alignof", "as", "become", "box", "break", "const", "continue", "crate", "do",
    "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop",
    "macro", "match", "mod", "move", "mut", "offsetof", "override", "priv", "proc", "pub", "pure",
    "ref", "return", "Self", "self", "sizeof", "static", "struct", "super", "trait", "true", "type",
    "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",

    # Also include names of types that are in the prelude:
    "Copy", "Send", "Sized", "Sync", "Drop", "Fn", "FnMut", "FnOnce", "drop", "Box", "ToOwned",
    "Clone", "PartialEq", "PartialOrd", "Eq", "Ord", "AsRef", "AsMut", "Into", "From", "Default",
    "Iterator", "Extend", "IntoIterator", "DoubleEndedIterator", "ExactSizeIterator", "Option",
    "Some", "None", "Result", "Ok", "Err", "SliceConcatExt", "String", "ToString", "Vec",
]

class RustGenerator(CodeGenerator):
    def __init__(self, target_folder_path, args):
        super(RustGenerator, self).__init__(target_folder_path, args)
        self._modules = []
        self.preserve_aliases = True

    # File Generators

    def generate(self, api):
        for namespace in api.namespaces.values():
            self._emit_namespace(namespace)
        self._generate_mod_file()

    def _generate_mod_file(self):
        with self.output_to_relative_path('mod.rs'):
            self._emit_header()
            for module in self._modules:
                self.emit(u'pub mod {};'.format(module))

    # Type Emitters

    def _emit_namespace(self, namespace):
        with self.output_to_relative_path(namespace.name + '.rs'):
            self._emit_header()

            for alias in namespace.aliases:
                self._emit_alias(alias)
            if namespace.aliases:
                self.emit()

            for fn in namespace.routes:
                self._emit_route(namespace.name, fn)

            for typ in namespace.data_type_by_name.values():
                if isinstance(typ, data_type.Struct):
                    if typ.has_enumerated_subtypes():
                        self._emit_polymorphic_struct(typ)
                    else:
                        self._emit_struct(typ)
                elif isinstance(typ, data_type.Union):
                    self._emit_union(typ)
                else:
                    print('WARNING: unhandled type "{}" of field "{}"'.format(
                        type(typ).__name__,
                        typ.name))

        self._modules.append(namespace.name)

    def _emit_header(self):
        self.emit(u'// DO NOT EDIT')
        self.emit(u'// This file was generated by Stone')
        self.emit()

    def _emit_struct(self, struct):
        struct_name = self._struct_name(struct)
        self.emit(u'#[derive(Debug, Deserialize, Serialize)]')
        with self.block(u'pub struct {}'.format(struct_name)):
            for field in struct.all_fields:
                self.emit(u'#[serde(rename = "{}")] pub {}: {},'.format(
                    field.name,
                    self._field_name(field),
                    self._rust_type(field.data_type)))
                # TODO: do optional fields also need `default` serde attributes?
        self.emit()

        if not struct.all_required_fields:
            self._impl_default_for_struct(struct)

        if struct.all_required_fields:
            with self._impl_struct(struct):
                self._emit_new_for_struct(struct)

    def _emit_polymorphic_struct(self, struct):
        enum_name = self._enum_name(struct)
        self.emit(u'#[derive(Debug, Deserialize, Serialize)]')
        self.emit(u'#[serde(tag = ".tag")]')
        with self.block(u'pub enum {}'.format(enum_name)):
            for subtype in struct.get_enumerated_subtypes():
                self.emit(u'#[serde(rename = "{}")] {}({}),'.format(
                    subtype.name,
                    self._enum_variant_name(subtype.data_type),
                    self._rust_type(subtype.data_type)))
            if struct.is_catch_all():
                # TODO implement this
                print(u'WARNING: open unions are not implemented yet: {}::{}'.format(
                    struct.namespace.name,
                    struct.name))
                self.emit(u'#[serde(skip_deserializing)] _Unknown(::serde_json::value::Value),')

    def _emit_union(self, union):
        enum_name = self._enum_name(union)
        self.emit(u'#[derive(Debug, Deserialize, Serialize)]')
        self.emit(u'#[serde(tag = ".tag")]') # TODO: is the tag always ".tag"?
        with self.block(u'pub enum {}'.format(enum_name)):
            for field in union.all_fields:
                variant_name = self._enum_variant_name(field)
                if isinstance(field.data_type, data_type.Void):
                    self.emit(u'#[serde(rename = "{}")] {},'.format(field.name, variant_name))
                else:
                    self.emit(u'#[serde(rename = "{}")] {}({}),'.format(
                        field.name,
                        variant_name,
                        self._rust_type(field.data_type)))
        self.emit()

    def _emit_route(self, ns, fn):
        route_name = self._route_name(fn)
        with self.block(u'pub fn {}(client: &::client_trait::HttpClient, arg: &{}) -> ::Result<Result<{}, {}>>'.format(
                route_name,
                self._rust_type(fn.arg_data_type),
                self._rust_type(fn.result_data_type),
                self._rust_type(fn.error_data_type))):
            endpoint = u'::client_trait::Endpoint::Api' # TODO: support content endpoints
            self.emit(u'::client_helpers::request(client, {}, "{}/{}", arg, None)'.format(
                endpoint,
                ns,
                fn.name))
        self.emit()

    def _emit_alias(self, alias):
        alias_name = self._alias_name(alias)
        self.emit(u'pub type {} = {};'.format(alias_name, self._rust_type(alias.data_type)))

    # Helpers

    def _impl_default_for_struct(self, struct):
        struct_name = self._struct_name(struct)
        with self.block(u'impl Default for {}'.format(struct_name)):
            with self.block(u'fn default() -> Self'):
                with self.block(struct_name):
                    for field in struct.all_fields:
                        self.emit(u'{}: {},'.format(
                            self._field_name(field), self._default_value(field)))

    def _impl_struct(self, struct):
        return self.block(u'impl {}'.format(self._struct_name(struct)))

    def _emit_new_for_struct(self, struct):
        struct_name = self._struct_name(struct)
        args = u''
        for field in struct.all_required_fields:
            args += u'{}: {}, '.format(self._field_name(field), self._rust_type(field.data_type))
        args = args[:-2]

        with self.block(u'pub fn new({}) -> Self'.format(args)):
            with self.block(struct_name):
                for field in struct.all_required_fields:
                    self.emit(u'{},'.format(self._field_name(field))) # shorthand assignment
                for field in struct.all_optional_fields:
                    self.emit(u'{}: {},'.format(self._field_name(field), self._default_value(field)))

        for field in struct.all_optional_fields:
            self.emit()
            field_name = self._field_name(field)
            with self.block(u'pub fn {}(mut self, value: {}) -> Self'.format(
                    field_name,
                    self._rust_type(field.data_type))):
                self.emit(u'self.{} = value;'.format(field_name))
                self.emit(u'self')

        self.emit()

    def _default_value(self, field):
        if isinstance(field.data_type, data_type.Nullable):
            return u'None'
        elif data_type.is_numeric_type(field.data_type):
            return field.default
        elif isinstance(field.default, data_type.TagRef):
            for variant in field.default.union_data_type.fields:
                if variant.name == field.default.tag_name:
                    default_variant = variant
            return u'{}::{}'.format(
                self._rust_type(field.default.union_data_type),
                self._enum_variant_name(default_variant))
        elif isinstance(field.data_type, data_type.Boolean):
            if field.default:
                return u'true'
            else:
                return u'false'
        elif isinstance(field.data_type, data_type.String):
            if not field.default:
                return u'String::new()'
            else:
                return u'"{}".to_owned()'.format(field.default)
        else:
            print(u'WARNING: unhandled default value {}'.format(field.default))
            print(u'    in field: {}'.format(field))
            return field.default

    # Naming Rules

    def _rust_type(self, typ):
        if isinstance(typ, data_type.Nullable):
            return u'Option<{}>'.format(self._rust_type(typ.data_type))
        elif isinstance(typ, data_type.Void):       return u'()'
        elif isinstance(typ, data_type.Bytes):      return u'Vec<u8>'
        elif isinstance(typ, data_type.Int32):      return u'i32'
        elif isinstance(typ, data_type.UInt32):     return u'u32'
        elif isinstance(typ, data_type.Int64):      return u'i64'
        elif isinstance(typ, data_type.UInt64):     return u'u64'
        elif isinstance(typ, data_type.Float32):    return u'f32'
        elif isinstance(typ, data_type.Float64):    return u'f64'
        elif isinstance(typ, data_type.Boolean):    return u'bool'
        elif isinstance(typ, data_type.String):     return u'String'
        elif isinstance(typ, data_type.Timestamp):  return u'String /*Timestamp*/' # TODO
        elif isinstance(typ, data_type.List):
            return u'Vec<{}>'.format(self._rust_type(typ.data_type))
        elif isinstance(typ, data_type.Map):
            return u'HashMap<{}, {}>'.format(
                self._rust_type(typ.key_data_type),
                self._rust_type(typ.value_data_type))
        elif isinstance(typ, data_type.Alias):
            return u'super::{}::{}'.format(
                self._namespace_name(typ.namespace),
                self._alias_name(typ))
        elif isinstance(typ, data_type.UserDefined):
            if isinstance(typ, data_type.Struct):
                name = self._struct_name(typ)
            elif isinstance(typ, data_type.Union):
                name = self._enum_name(typ)
            else:
                print(u'ERROR: user-defined type "{}" is neither Struct nor Union???'.format(typ))
                name = u'()'
            return u'super::{}::{}'.format(
                self._namespace_name(typ.namespace),
                name)
        else:
            print(u'ERROR: unhandled type "{}"'.format(typ))
            return u'()'

    def _namespace_name(self, ns):
        name = fmt_underscores(ns.name)
        if name in RUST_RESERVED_WORDS:
            name += '_namespace'
        return name

    def _struct_name(self, struct):
        name = fmt_pascal(struct.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Struct'
        return name

    def _enum_name(self, union):
        name = fmt_pascal(union.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Union'
        return name

    def _field_name(self, field):
        name = fmt_underscores(field.name)
        if name in RUST_RESERVED_WORDS:
            name += '_field'
        return name

    def _enum_variant_name(self, field):
        name = fmt_pascal(field.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Variant'
        return name

    def _route_name(self, route):
        name = fmt_underscores(route.name)
        if name in RUST_RESERVED_WORDS:
            name += '_route'
        return name

    def _alias_name(self, alias):
        name = fmt_pascal(alias.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Alias'
        return name