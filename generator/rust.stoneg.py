from stone import data_type
from stone.generator import CodeGenerator
from stone.target.helpers import (
    fmt_pascal,
    fmt_underscores,
)

RUST_RESERVED_WORDS = [
    "abstract", "alignof", "as", "become", "box", "break", "const", "continue", "crate", "do",
    "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop",
    "macro", "match", "mod", "move", "mut", "offsetof", "override", "priv", "proc", "pub", "pure",
    "ref", "return", "Self", "self", "sizeof", "static", "struct", "super", "trait", "true", "type",
    "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
]

class RustGenerator(CodeGenerator):
    def __init__(self, target_folder_path, args):
        super(RustGenerator, self).__init__(target_folder_path, args)
        self._modules = []

    # File Generators

    def generate(self, api):
        for namespace in api.namespaces.values():
            self._emit_namespace(namespace)
        self._generate_mod_file()

    def _generate_mod_file(self):
        with self.output_to_relative_path('mod.rs'):
            self._emit_header()
            for module in self._modules:
                self.emit(u'pub mod {};'.format(module))

    # Type Emitters

    def _emit_namespace(self, namespace):
        with self.output_to_relative_path(namespace.name + '.rs'):
            self._emit_header()

            self.emit(u'use client_trait;')
            self.emit(u'use client_helpers;')

            for fn in namespace.routes:
                self._emit_route(namespace.name, fn)

            for typ in namespace.data_type_by_name.values():
                if isinstance(typ, data_type.Struct):
                    self._emit_struct(typ)
                elif isinstance(typ, data_type.Union):
                    self._emit_union(typ)
                else:
                    print('WARNING: unhandled type "{}" of field "{}"'.format(
                        type(typ).__name__,
                        typ.name))

        self._modules.append(namespace.name)

    def _emit_header(self):
        self.emit(u'// DO NOT EDIT')
        self.emit(u'// This file was generated by Stone')
        self.emit()

    def _emit_struct(self, struct):
        struct_name = self._struct_name(struct)
        self.emit(u'#[derive(Debug, Deserialize, Serialize)]')
        with self.block(u'pub struct {}'.format(struct_name)):
            for field in struct.all_fields:
                self.emit(u'#[serde(rename = "{}")] pub {}: {},'.format(
                    field.name,
                    self._field_name(field),
                    self._rust_type(field.data_type)))
                # TODO: do optional fields also need `default` serde attributes?
        self.emit()

    def _emit_union(self, union):
        enum_name = self._enum_name(union)
        self.emit(u'#[derive(Debug, Deserialize, Serialize)]')
        self.emit(u'#[serde(tag = ".tag")]') # TODO: is the tag always ".tag"?
        with self.block(u'pub enum {}'.format(enum_name)):
            for field in union.all_fields:
                variant_name = self._enum_variant_name(field)
                if isinstance(field.data_type, data_type.Void):
                    self.emit(u'#[serde(rename = "{}")] {},'.format(field.name, variant_name))
                else:
                    self.emit(u'#[serde(rename = "{}")] {}({}),'.format(
                        field.name,
                        variant_name,
                        self._rust_type(field.data_type)))
        self.emit()

    def _emit_route(self, ns, fn):
        route_name = self._route_name(fn)
        with self.block(u'pub fn {}(client: &client_trait::HttpClient, arg: &{}) -> ::Result<Result<{}, {}>>'.format(
                route_name,
                self._rust_type(fn.arg_data_type),
                self._rust_type(fn.result_data_type),
                self._rust_type(fn.error_data_type))):
            endpoint = u'client_trait::Endpoint::Api' # TODO: support content endpoints
            self.emit(u'client_helpers::request(client, {}, "{}/{}", arg, None)'.format(
                endpoint,
                ns,
                fn.name))
        self.emit()

    # Naming Rules

    def _rust_type(self, typ):
        if isinstance(typ, data_type.Nullable):
            return u'Option<{}>'.format(self._rust_type(typ.data_type))
        elif isinstance(typ, data_type.Void):       return u'()'
        elif isinstance(typ, data_type.Bytes):      return u'Vec<u8>'
        elif isinstance(typ, data_type.Int32):      return u'i32'
        elif isinstance(typ, data_type.UInt32):     return u'u32'
        elif isinstance(typ, data_type.Int64):      return u'i64'
        elif isinstance(typ, data_type.UInt64):     return u'u64'
        elif isinstance(typ, data_type.Float32):    return u'f32'
        elif isinstance(typ, data_type.Float64):    return u'f64'
        elif isinstance(typ, data_type.Boolean):    return u'bool'
        elif isinstance(typ, data_type.String):     return u'String'
        elif isinstance(typ, data_type.Timestamp):  return u'String /*Timestamp*/' # TODO
        elif isinstance(typ, data_type.List):
            return u'Vec<{}>'.format(self._rust_type(typ.data_type))
        elif isinstance(typ, data_type.Map):
            return u'HashMap<{}, {}>'.format(
                self._rust_type(typ.key_data_type),
                self._rust_type(typ.value_data_type))
        elif isinstance(typ, data_type.UserDefined):
            if isinstance(typ, data_type.Struct):
                name = self._struct_name(typ)
            elif isinstance(typ, data_type.Union):
                name = self._enum_name(typ)
            else:
                print(u'ERROR: user-defined type "{}" is neither Struct nor Union???'.format(typ))
                name = u'()'
            return u'super::{}::{}'.format(
                self._namespace_name(typ.namespace),
                name)
        else:
            print(u'ERROR: unhandled type "{}"'.format(typ))
            return u'()'

    def _namespace_name(self, ns):
        name = fmt_underscores(ns.name)
        if name in RUST_RESERVED_WORDS:
            name += '_namespace'
        return name

    def _struct_name(self, struct):
        name = fmt_pascal(struct.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Struct'
        return name

    def _enum_name(self, union):
        name = fmt_pascal(union.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Union'
        return name

    def _field_name(self, field):
        name = fmt_underscores(field.name)
        if name in RUST_RESERVED_WORDS:
            name += '_field'
        return name

    def _enum_variant_name(self, field):
        name = fmt_pascal(field.name)
        if name in RUST_RESERVED_WORDS:
            name += 'Variant'
        return name

    def _route_name(self, route):
        name = fmt_underscores(route.name)
        if name in RUST_RESERVED_WORDS:
            name += '_route'
        return name
